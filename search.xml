<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode 16.3Sum Cloest</title>
    <url>/2017/08/18/2017-08-18-3Sum-Closest/</url>
    <content><![CDATA[<h2 id="16-3Sum-Cloest"><a href="#16-3Sum-Cloest" class="headerlink" title="16.3Sum Cloest"></a>16.3Sum Cloest</h2><blockquote>
<p>Description:</p>
<blockquote>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
</blockquote>
<p>example</p>
<blockquote>
<p>For example, given array S = {-1 2 1 -4}, and target = 1.</p>
<p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
</blockquote>
<hr>
<p>题目理解：输入一个数组和一个目标值，求数组中三个数的和，返回和与目标值之间的最小差值。</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dis = Integer.MAX_VALUE, result = -<span class="number">1</span>, m = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>, bound = m - <span class="number">2</span> ; i &lt; bound &amp;&amp; dis != <span class="number">0</span> &amp;&amp; nums[i] - target &lt; dis; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>, r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ( l &lt; r ) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">int</span> temp_dis = sum - target;</span><br><span class="line">                temp_dis = temp_dis &gt; <span class="number">0</span> ? temp_dis : -temp_dis;</span><br><span class="line">                <span class="keyword">if</span> ( temp_dis &lt; dis ) &#123;</span><br><span class="line">                    dis = temp_dis;</span><br><span class="line">                    result = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( sum - target &lt; <span class="number">0</span> ) l++;</span><br><span class="line">                <span class="keyword">else</span> r--;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> ( i &lt; bound &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] ) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法和3Sum几乎一样，只是多进行一下距离的比较。</p>
<p>复杂度 n^2, 运行时间 18ms.</p>
<p><img src="/images/leetcode/3Sum_Closest.png" alt="images"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>博客bug记录</title>
    <url>/2017/08/18/2017-08-18-blog-bugs/</url>
    <content><![CDATA[<hr>
<h2 id="2017-08-18-公式符号导致搜索功能无法使用（jekyll）"><a href="#2017-08-18-公式符号导致搜索功能无法使用（jekyll）" class="headerlink" title="2017-08-18 公式符号导致搜索功能无法使用（jekyll）"></a>2017-08-18 公式符号导致搜索功能无法使用（jekyll）</h2><p>本来以为弄好了博客，结果发现搜索功能不能使用了，重新来了一遍，控制变量法。<br>终于发现问题是因为一个公式内的符号<code>&amp;</code>，造成的问题。</p>
<p>去掉公式内的<code>&amp;</code>符号后，一切恢复正常…</p>
<hr>
<h2 id="2017-08-20-image标签与photos标签（jekyll）"><a href="#2017-08-20-image标签与photos标签（jekyll）" class="headerlink" title="2017-08-20 image标签与photos标签（jekyll）"></a>2017-08-20 image标签与photos标签（jekyll）</h2><p>试了一下在文件头加入这两个标签，想试一试加上封面的效果，
结果发现image标签我根本用不了，但是photos标签可以用，
不过需要注意的是photos标签后面内链直接<code>source/images/...</code>，
不再需要前面那个<code>site.url</code>。</p>
<p>但是用了photos标签后，文章内部会有一个加载失败的图片，看来是用不了了。</p>
<hr>
<h2 id="hexo-Error-fatal-bad-config-line-1-in-file-git-config（hexo）"><a href="#hexo-Error-fatal-bad-config-line-1-in-file-git-config（hexo）" class="headerlink" title="hexo Error: fatal: bad config line 1 in file .git/config（hexo）"></a>hexo Error: fatal: bad config line 1 in file .git/config（hexo）</h2><p>今天在部署博客时，突然出现了错误，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo Error: fatal: bad config line 1 in file .git&#x2F;config</span><br></pre></td></tr></table></figure>
<p>完全不明白为什么，又没有改过配置文件。</p>
<p>搜索了发现是<code>.deploy_git/.git/config</code>文件里面的配置出现了问题，不是hexo的问题，而是git的问题。
这里的<code>config</code>文件里面的内容不知道为什么被修改了，变成了乱码。</p>
<p>删除了<code>config</code>文件，找了一个<code>idea</code>下面的一个同步工程的<code>config</code>文件，但是还是报错。</p>
<p>最后找了一个同步之前的<code>config</code>文件，才总于解决了问题。</p>
<p>里面的配置为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">	repositoryformatversion &#x3D; 0</span><br><span class="line">	filemode &#x3D; false</span><br><span class="line">	bare &#x3D; false</span><br><span class="line">	logallrefupdates &#x3D; true</span><br><span class="line">	symlinks &#x3D; false</span><br><span class="line">	ignorecase &#x3D; true</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">	remote &#x3D; git@github.com:isadamu&#x2F;isadamu.github.io.git</span><br><span class="line">	merge &#x3D; refs&#x2F;heads&#x2F;master</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>guide</category>
        <category>jekyll</category>
      </categories>
      <tags>
        <tag>guide</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 15.3Sum</title>
    <url>/2017/08/18/2017-08-18-3Sum/</url>
    <content><![CDATA[<h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15.3Sum"></a>15.3Sum</h2><blockquote>
<p>Description:</p>
<blockquote>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
</blockquote>
<p>Note: The solution set must not contain duplicate triplets.</p>
</blockquote>
<hr>
<p>题目理解：输入一个数组和一个目标值，求3个数之和等于目标值。返回所有这些3个数的组合，但是不能有重复的组合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span>, m = nums.length;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>, bound = m - <span class="number">2</span> ; i &lt; bound &amp;&amp; nums[i] &lt;= target ; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>, r = m - <span class="number">1</span>, sum = target - nums[i];</span><br><span class="line">            <span class="keyword">while</span> ( l &lt; r ) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp_sum = nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> ( temp_sum &lt; sum ) l++; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( temp_sum &gt; sum ) r--; </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    item.add(nums[i]);</span><br><span class="line">                    item.add(nums[l]);</span><br><span class="line">                    item.add(nums[r]);</span><br><span class="line">                    result.add(item);</span><br><span class="line">                    l++;</span><br><span class="line">                    <span class="keyword">while</span> ( l &lt; r &amp;&amp; nums[l] == nums[l-<span class="number">1</span>] ) l++;</span><br><span class="line">                    r--;</span><br><span class="line">                    <span class="keyword">while</span> ( l &lt; r &amp;&amp; nums[r] == nums[r+<span class="number">1</span>] ) r--;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> ( i &lt; bound &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] ) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">  &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将数组进行排序，外层循环从左向右，内部就是一个Two_Sum，这里注意要跳过重复的值。</p>
<p>复杂度n^2，运行时间69ms。</p>
<p><img src="/images/leetcode/3Sum.png" alt="images"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 18.4Sum</title>
    <url>/2017/08/18/2017-08-18-4Sum/</url>
    <content><![CDATA[<h2 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18.4Sum"></a>18.4Sum</h2><blockquote>
<p>Description:</p>
<blockquote>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
</blockquote>
<p>Note: The solution set must not contain duplicate quadruplets.</p>
<p>example:</p>
<blockquote>
<p>For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.</p>
<p>A solution set is:</p>
<p>[ [-1,  0, 0, 1], [-2, -1, 1, 2], [-2,  0, 0, 2] ]</p>
</blockquote>
</blockquote>
<hr>
<p>题目理解：与3Sum一个意思。</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> m = nums.length;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> idx1 = <span class="number">0</span>, bound1 = m - <span class="number">3</span> ; idx1 &lt; bound1 &amp;&amp; nums[idx1] * <span class="number">4</span> &lt;= target ;  ) &#123;</span><br><span class="line">            <span class="keyword">int</span> target3 = target - nums[idx1];</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = idx1 + <span class="number">1</span>, bound = m - <span class="number">2</span> ; i &lt; bound &amp;&amp; nums[i] * <span class="number">3</span> &lt;= target3; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> l = i + <span class="number">1</span>, r = m - <span class="number">1</span>, sum = target3 - nums[i];</span><br><span class="line">                <span class="keyword">if</span> ( sum &lt;= nums[r] * <span class="number">2</span> &amp;&amp; sum &gt;= nums[l] * <span class="number">2</span> ) &#123;</span><br><span class="line">                    <span class="keyword">while</span> ( l &lt; r ) &#123;</span><br><span class="line">                        <span class="keyword">int</span> temp_sum = nums[l] + nums[r];</span><br><span class="line">                        <span class="keyword">if</span> ( temp_sum &lt; sum ) l++; </span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ( temp_sum &gt; sum ) r--; </span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                            item.add(nums[idx1]);item.add(nums[i]);item.add(nums[l]);item.add(nums[r]);</span><br><span class="line">                            result.add(item);</span><br><span class="line">                            l++;</span><br><span class="line">                            <span class="keyword">while</span> ( l &lt; r &amp;&amp; nums[l] == nums[l-<span class="number">1</span>] ) l++;</span><br><span class="line">                            r--;</span><br><span class="line">                            <span class="keyword">while</span> ( l &lt; r &amp;&amp; nums[r] == nums[r+<span class="number">1</span>] ) r--;</span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">while</span> ( i &lt; bound &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] ) i++;</span><br><span class="line">            &#125;</span><br><span class="line">            idx1++;</span><br><span class="line">            <span class="keyword">while</span> ( idx1 &lt; bound1 &amp;&amp; nums[idx1] == nums[idx1-<span class="number">1</span>] ) idx1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部包装了一个3Sum，但是其中一些中断的条件很重要，能够提升不少性能。</p>
<p>复杂度：n^3, 运行时间：28ms。</p>
<p><img src="/images/leetcode/4Sum.png" alt="image"></p>
<hr>
<p>代码2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> ( nums.length &lt; <span class="number">4</span> ) <span class="keyword">return</span> result;</span><br><span class="line">        Arrays.sort(nums); </span><br><span class="line">        <span class="keyword">int</span>[] ynums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> repeat = <span class="number">1</span>, idx = <span class="number">1</span>;</span><br><span class="line">        ynums[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( nums[i] == nums[i-<span class="number">1</span>] ) &#123;</span><br><span class="line">                repeat++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                repeat = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( repeat &lt; <span class="number">4</span> ) &#123;</span><br><span class="line">                ynums[idx++] = nums[i]; </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( repeat == <span class="number">4</span> &amp;&amp; nums[i]*<span class="number">4</span> == target ) &#123;</span><br><span class="line">                myAdd( result, nums[i], nums[i], nums[i], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = idx, ts_i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] two_sum = <span class="keyword">new</span> <span class="keyword">int</span>[m*(m-<span class="number">1</span>)/<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++ ) &#123;</span><br><span class="line">            repeat = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ( i &lt; m - <span class="number">1</span> &amp;&amp; ynums[i + <span class="number">1</span>] == ynums[i] ) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                repeat++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( repeat == <span class="number">2</span> ) &#123;</span><br><span class="line">                two_sum[ts_i][<span class="number">0</span>] = ynums[i] * <span class="number">2</span>;</span><br><span class="line">                two_sum[ts_i][<span class="number">1</span>] = i - <span class="number">1</span>;</span><br><span class="line">                two_sum[ts_i][<span class="number">2</span>] = i;</span><br><span class="line">                ts_i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( repeat == <span class="number">3</span> ) &#123;</span><br><span class="line">                two_sum[ts_i][<span class="number">0</span>] = ynums[i] * <span class="number">2</span>;</span><br><span class="line">                two_sum[ts_i][<span class="number">1</span>] = i - <span class="number">1</span>;</span><br><span class="line">                two_sum[ts_i][<span class="number">2</span>] = i - <span class="number">1</span>;</span><br><span class="line">                ts_i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m;  ) &#123;</span><br><span class="line">                two_sum[ts_i][<span class="number">0</span>] = ynums[i] + ynums[j];</span><br><span class="line">                two_sum[ts_i][<span class="number">1</span>] = i;</span><br><span class="line">                two_sum[ts_i][<span class="number">2</span>] = j;</span><br><span class="line">                ts_i++;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">while</span> ( j &lt; m &amp;&amp; ynums[j] == ynums[j-<span class="number">1</span>] ) &#123;</span><br><span class="line">                   j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(two_sum, <span class="number">0</span>, ts_i, <span class="keyword">new</span> MyCompare());</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = ts_i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( l &lt; r ) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = two_sum[l][<span class="number">0</span>] + two_sum[r][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> ( sum &lt; target ) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( sum &gt; target ) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ( two_sum[l][<span class="number">2</span>] &lt; two_sum[r][<span class="number">1</span>] ) &#123;</span><br><span class="line">                    myAdd( result, ynums[two_sum[l][<span class="number">1</span>]], ynums[two_sum[l][<span class="number">2</span>]], ynums[two_sum[r][<span class="number">1</span>]], ynums[two_sum[r][<span class="number">2</span>]]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> ll = l + <span class="number">1</span>, rr = r - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> ( ll &lt; r &amp;&amp; two_sum[ll][<span class="number">0</span>] == two_sum[ll-<span class="number">1</span>][<span class="number">0</span>] ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( two_sum[ll][<span class="number">2</span>] &lt; two_sum[r][<span class="number">1</span>] ) &#123;</span><br><span class="line">                        myAdd( result, ynums[two_sum[ll][<span class="number">1</span>]], ynums[two_sum[ll][<span class="number">2</span>]], ynums[two_sum[r][<span class="number">1</span>]], ynums[two_sum[r][<span class="number">2</span>]]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ll++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> ( ll &lt; rr &amp;&amp; two_sum[rr][<span class="number">0</span>] == two_sum[rr+<span class="number">1</span>][<span class="number">0</span>] ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( two_sum[rr][<span class="number">1</span>] &gt; two_sum[l][<span class="number">2</span>] ) &#123;</span><br><span class="line">                        myAdd( result, ynums[two_sum[l][<span class="number">1</span>]], ynums[two_sum[l][<span class="number">2</span>]], ynums[two_sum[rr][<span class="number">1</span>]], ynums[two_sum[rr][<span class="number">2</span>]]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    rr--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                l++; r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myAdd</span><span class="params">( List&lt;List&lt;Integer&gt;&gt; result, <span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> b1, <span class="keyword">int</span> b2)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        item.add(a1); item.add(a2);</span><br><span class="line">        item.add(b1); item.add(b2);</span><br><span class="line">        result.add(item); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class MyCompare implements Comparator&lt;int[]&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ( o1[<span class="number">0</span>] &gt; o2[<span class="number">0</span>] ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( o1[<span class="number">0</span>] &lt; o2[<span class="number">0</span>] ) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( o1[<span class="number">1</span>] &lt; o2[<span class="number">1</span>] ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( o1[<span class="number">1</span>] &gt; o2[<span class="number">1</span>] ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( o1[<span class="number">2</span>] &lt; o2[<span class="number">2</span>] ) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>贼复杂，想法到是很简单，就是先计算两两数的和，然后就变成了类似2Sum的东西，但是其中的多种重复情况，使得编写程序十分复杂。</p>
<p>并且代码还可以优化，但是懒得想了，就不该开始这个代码(；′⌒`)。</p>
<p>复杂度：n^2log(n)(个人简单估计是这样的，但是常数因子很大，而且占用空间很多)。</p>
<p>运行时间：85ms。</p>
<p><img src="/images/leetcode/4Sum_2.png" alt="image"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>Everflow 阅读报告</title>
    <url>/2017/08/18/2017-08-18-everflow/</url>
    <content><![CDATA[<h2 id="Everflow-阅读报告"><a href="#Everflow-阅读报告" class="headerlink" title="Everflow 阅读报告"></a>Everflow 阅读报告</h2><p>文献名：Packet-Level Telemetry in Large Datacenter Networks</p>
<p>（Zhu Y, Kang N, Cao J, et al. Packet-level telemetry in large datacenter networks[C]//ACM SIGCOMM Computer Communication Review. ACM, 2015, 45(4): 479-491.）</p>
<p>作者：Yibo Zhu、Nanxi Kang、Jiaxin Cao、Albert Greenberg、Guohan Lu、Ratul Mahajan、Dave Maltz、Lihua Yuan、Ming Zhang、Ben Y. Zhao、Haitao Zheng</p>
<p>关键字：Datacenter network; failure detection; probe</p>
<h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>在复杂网络中去排查故障是一件很困难的事，要做到及时的解决故障，需要做到：</p>
<ul>
<li>在大规模的网络流量中识别出受影响的报文。</li>
<li>穿过多个网络组件去追踪它们。</li>
<li>分析流量轨迹中的故障模式。</li>
<li>测试并确定潜在的故障原因。</li>
</ul>
<p>Everflow 就是一个大型网络中基于报文级别的遥测系统，使用商用交换机所具有的“match and mirror”功能来追踪特定的报文。它将抓取到的报文送到分析服务器，并且发出“guided probes”来测试并确定潜在的故障。
它的特点在于它是报文级别的，粒度细，并且随着数据中心实时运行，对当前的一小部分报文进行追踪，可以实时检测到故障。另外当操作员发现某些故障时，也可以对Everflow进行配置，注入探针报文去定位这些故障。</p>
<p>对于Silent packet drop、Silent blackhole、Inflated end-to-end latency、Loops from buggy middlebox routing、Load imbalance和Protocol bugs等一些问题，传统的工具是很难检测到故障或者很难定位到故障的，但是这些问题Everflow都可以发现，并且能够将这些问题定位到某个路由器或者某条链路。</p>
<p>另外，它所需占用的资源在数据中心尺度来看是很小的，基本可以不予考虑。</p>
<h2 id="Everflow架构："><a href="#Everflow架构：" class="headerlink" title="Everflow架构："></a>Everflow架构：</h2><p><img src="/images/paper/everflow_1.png" alt="image"></p>
<p>Everflow主要由四个部分组成：controller、analyzer、storage和reshuffler。在这之上，多个Everflow application与Controller进行交互，利用Everflow提供的信息来诊断网络故障。</p>
<h3 id="Reshuffler："><a href="#Reshuffler：" class="headerlink" title="Reshuffler："></a>Reshuffler：</h3><p>Reshuffler负责将追踪的报文进行镜像，然后送到Analyzer。其中主要的问题是数据中心的流量巨大，不可能追踪所有的报文，只能有选择的进行追踪。需要使用下面一些措施。</p>
<p><strong>在交换机上进行匹配和镜像。</strong>商用的数据中心交换机可以预定义匹配规则，
并对匹配报文执行确定的操作，且不改变原报文的转发行为。
Everflow利用这一点来减少追踪的负载，
用三种匹配规则来处理DCN（DataCenter Network）的通常故障。
<strong>第一</strong>，由于数据中心流的大小分布十分不均匀，
所以以TCP报文的SYN、FIN和RST部分来进行匹配，
随机在n个踪迹中选择一个踪迹进行追踪。
<strong>第二</strong>，某一些问题可能需要追踪特定应用的特定端口的报文，
或者两个服务器之间的报文，
所以这里在这样的报文中加入一个特殊的<strong>“debug bit”</strong>，
交换机将对这样的报文进行追踪。<strong>第三</strong>，对一些协议报文（例如BGP、PFC和RDMA），
它们在网络中是属于很小的一部分，但是又十分重要，
所以Everflow会追踪所有这些的协议报文。</p>
<p><strong>Switch-based reshuffler。</strong>我们需要一个低花费的策略来reshuffle这些追踪流量。为了实现这个策略，首先在HMux（hardware Mux）中定义一个VIP（virtual IP），配置所有交换机将踪迹报文转发到VIP，当一个踪迹报文到达HMux，HMux依据报文的五元组将报文重定向到一个DIP（direct IP，它就对应一个分析服务器）。这样就保证了同一五元组的报文只会被重定向到相同的DIP。</p>
<h3 id="Analyzers："><a href="#Analyzers：" class="headerlink" title="Analyzers："></a>Analyzers：</h3><p>分析器。由分布式服务器组组成，每台服务器处理一部分“tracing traffic”。
每一个分析器保持着两个状态：<strong>追踪报文</strong>和<strong>计数器</strong>。</p>
<p><strong>追踪报文。</strong>分析器保持着一个报文踪迹表，表中保存了同一个报文（由五元组和IPID定义）的镜像链。它保存原报文的一份全拷贝，一系列的逐跳信息，逐跳信息包括报文被镜像的交换机IP地址、时间戳、TTL、源MAC地址和DSCP/ECN。当在一秒以内不再有新的报文，就认为一条踪迹结束。</p>
<p>在一条结束的报文踪迹中，分析器会检查它是否有<strong>循环</strong>或<strong>丢包</strong>问题。当相同的设备在一条踪迹中出现多次时，就认为出现了循环。当一条踪迹的最后一跳与所期望的最后一跳不同时，就认为发生了丢包。</p>
<p>由于需要追踪的报文的数量十分巨大，为了减小存储压力，每一个分析器只会将 异常行为、设置了调试位（例guided probes）或者协议相关报文（例PFC和BGP）的踪迹信息写入存储单元。对剩下的踪迹，分析器会将它们以类型的区别聚合到计数列表，并每隔10秒写入存储单元。最后controller还会将每个分析器的计数合并到一起。</p>
<p><strong>链路负载计数器。</strong>对每条链路，分析器会计算出链路的总负载（报文数、比特数和flow数）。另外它还可以对指定前缀的流量或指定的内部流量来进行更细粒度的统计，这个操作可以通过controller来动态增减。</p>
<p><strong>延迟计数器。</strong>分析器通过“guided probes”来计算每一条链路的延迟。</p>
<p><strong>镜像报文丢包计数。</strong>镜像报文也有可能会发生丢包，如下图5所示，当踪迹包含S2却不包含S1时，明显表示从S1镜像出来的报文发生了丢失。在实际部署中镜像报文丢失率很低，通过将镜像报文避开拥塞链路就能很好的解决这个问题。</p>
<p><img src="/images/paper/everflow_2.png" alt="image"></p>
<h3 id="Storage："><a href="#Storage：" class="headerlink" title="Storage："></a>Storage：</h3><p>这里使用了SCOPE数据库，它是一个可扩展的分布式数据处理系统。数据用表的形式进行存储。这里将报文踪迹按行进行存储，每一行存储一条报文踪迹。</p>
<h3 id="Controller-APIs："><a href="#Controller-APIs：" class="headerlink" title="Controller APIs："></a>Controller APIs：</h3><p>Everflow applications通过一些API来与控制器进行交互，通过这些API，应用可以查询报文踪迹、添加细粒度的负载计数器、触发guided probes以及选定踪迹添加调试bit。</p>
<p>它有GetTrace()、GetCounter()、AddCounter()、RemoveCounter()、Probe()以及EnableDbg()、DisableDbg() 这样一些操作函数。</p>
<p><strong>guided probing。</strong>由于故障的发生可能有多种原因，被动的追踪报文可能不足以确定这些的原因，这时就需要重新注入报文来判断故障。这种能够在任意交换机上注入任意报文的能力，就叫做guided probing。</p>
<p><img src="/images/paper/everflow_3.png" alt="image"></p>
<p>如上图（a），虽然追踪到了这个丢包，但是我们不能确定这个丢包是随机的还是持续的，通过guided probing，我们将报文p的复制注入到S2（如图b），确定丢包是随机的还是持续的。更进一步，可以设置探针报文为不同的五元组，测试丢包是随机的，还是针对某个特定的五元组。</p>
<p><img src="/images/paper/everflow_4.png" alt="image"></p>
<p>如上图（a），当使用被动追踪中去测量链路延迟时（也就是正常的追踪），可能由于追踪报文的两次返回所经过的路径不同，造成测量不正确。guided probing不仅可以注入报文，还可以指定报文经过的路径，通过这一特点，设置探针报文经过S1 -&gt; S2 -&gt; S1，这样报文就会经过S1两次，这两次的时间间隔就是链路延迟的两倍。</p>
<h2 id="故障排查："><a href="#故障排查：" class="headerlink" title="故障排查："></a>故障排查：</h2><p><strong>Latency profiler。</strong>当两个服务器之间的延迟变得很高时，为了去查询问题的原因，首先，对两个服务器之间的TCP SYN报文的debug bit进行标志，追踪这些报文，就可以路径上所经过的网络设备。然后，注入guided probes去测量逐跳延迟。有了这些信息，就能快速定位到发生问题的网络设备。</p>
<p><strong>Packet drop debugger。</strong>发生丢包的原因可能有很多，例如拥塞、软件bug或者配置错误，这就需要调试器对发生丢包的踪迹进行检查。对于一个遭到丢弃的报文p，通过最后抓取到p的交换机Sn，可以推断出p所期望的下一跳。这样，调试器就会注入guided probes到Sn，确定丢包是否是持续的，确定丢包是否有固定模式（例如特定的五元组）。</p>
<p><strong>Loop debugger。</strong>循环在数据中心网络中并不常见，但是它一旦出现，就将消耗大量的资源。当一个循环被检测到时（踪迹上相同设备出现两次），首先调试器注入guided probes去测试循环是不是持续的，如果循环是持续的，它会将循环路径上的设备进行上报，于是操作员就可以禁用设备上的端口来打破循环。在这期间调试器会持续注入guided probes，直到循环消失。</p>
<p><strong>ECMP profiler。</strong>在数据中心网络中，交换机会用ECMP（等价路由）来切分流量到下一跳。但可能由于不好的哈希函数或者路由问题，会造成链路拥塞。对每一个交换机，ECMP profiler将会它的链路总负载。当检测到不均衡的负载划分时，它会启动更加细粒度的负载计数器来排查，检测这样的不均衡的负载划分是对所有的流还是特定前缀的流。这些信息可以帮助操作员快速的检测并定位故障。</p>
<p><strong>RoCEv2-based RDMA debugger。</strong>RoCEv2-based RDMA（Remote DirectMemoryAccess）是一个新兴协议，它对网络的延迟要求非常的高。在数据中心网络中，有时由于NIC的一些软件bug，使得RDMA达不到理想的性能，但是NIC是由第三方厂商所提供的，不能得到其中的代码，于是就需要用调试器来处理这个问题。调试器追踪关于RDMA的所有控制报文，这些信息不仅能够观察到RDMA流的实际行为，也能调试第三方的代码问题。</p>
<p>（文章中第七部分提到了一些这些问题在实际中的一些处理的例子）</p>
]]></content>
      <categories>
        <category>paper</category>
        <category>network</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客 for jekyll</title>
    <url>/2017/08/18/2017-08-18-my-first-blog/</url>
    <content><![CDATA[<h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p><a href="http://theme-next.iissnan.com/">主题说明书</a></p>
<p>写博客直接在_post文件夹里面写，直接新建md文件即可。</p>
<p>图片放入到<code>source/images</code>里面。</p>
<p>这里文件名格式是：时间+题目。</p>
<p>其中文件名中的空格用”-“来代替，不能用中文名，否则报错找不到路径。</p>
<p>写博客时，可以使用 <code>bundle exec jekyll serve --watch</code> 命令来运行jekyll。</p>
<p>然后打开 <code>127.0.0.1:4000</code> 来查看实时效果。</p>
<p>写完之后，使用github客户端进行push即可。</p>
<p>之后便可打开<a href="https://isadamu.github.io/">我的博客</a>
<code>https://isadamu.github.io/</code>
查看了。当然，可能刷新要几分钟左右。</p>
<h2 id="博客头部常用的关键字："><a href="#博客头部常用的关键字：" class="headerlink" title="博客头部常用的关键字："></a>博客头部常用的关键字：</h2><pre><code>---
title:        // 文章题目 
date:         // 文章日期
description:  // 对这篇文章的简单描述
categories:   // 对文章的分类，细分，多添加，ps:只能英文
tags:         // 文章的标签，广义，多添加，ps:只能英文
link:         // 对文章标题加上超链接
image:        // 相当于加上一个图片封面
photos:       // 多添加，感觉与上面类似？
type:         // 没看出来作用。。。
---
</code></pre><p>需要注意的是category、tag不能包含中文。</p>
<h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>不高亮代码就直接缩进四个空格，</p>
<pre><code>public static void main(String[] args) &#123;
    System.out.println(&quot;高亮前&quot;);
&#125;
</code></pre><p>或者，</p>
<pre><code>`\``
public static void main(String[] args) &#123;
    System.out.println(&quot;高亮前&quot;);
&#125;
`\``
</code></pre><p>高亮代码语法(主要去掉”\“)：</p>
<pre><code>`\``java
public static void main(String[] args) &#123;
    System.out.println(&quot;高亮后&quot;);
&#125;
`\``
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;高亮后&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 行间公式：</span><br><span class="line">$$Y&#x3D;W^&#123;T&#125;X+b$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">Y=W^{T}X+b</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">行内公式：$ Y&#x3D;W^&#123;T&#125;X+b $</span><br></pre></td></tr></table></figure>
<p>行内$ Y=W^{T}X+b $公式</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>插入图片，内链，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![image](\&#123;\&#123;site.url\&#125;\&#125;&#x2F;source&#x2F;images&#x2F;head&#x2F;head_bigfan.png)</span><br></pre></td></tr></table></figure>
<p>去掉<code>site.url</code>旁边的4个’\‘。</p>
<p><img src="/images/head/head_bigfan.png" alt="image"></p>
<p>当然这里也可以用外链，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![image](https:&#x2F;&#x2F;img3.doubanio.com&#x2F;view&#x2F;photo&#x2F;photo&#x2F;public&#x2F;p2022836553.webp)</span><br></pre></td></tr></table></figure>
<div align="center"><img src="https://img3.doubanio.com/view/photo/photo/public/p2022836553.webp"
width="400" height="400" title="今年的湖畔会很冷" /></div>

<p>插入图片大小的调整：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;site.url&#125;&#125;/source/images/head/head_bigfan.png&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">&quot;zoom:50%&quot;</span> <span class="attr">title</span>=<span class="string">&quot;大范&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div align="center"><img src="/images/head/head_bigfan.png"
style="zoom:50%" title="大范" /></div>

<p>也可以用，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;site.url&#125;&#125;/source/images/head/head_bigfan.png&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span> <span class="attr">title</span>=<span class="string">&quot;大范&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div align="center"><img src="/images/head/head_bigfan.png"
width="200" height="200" title="大范" /></div>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><a href="http://wowubuntu.com/markdown/#code">Markdown语法</a></p>
<p><a href="http://blog.csdn.net/ethmery/article/details/50670297">MathJax基本语法</a></p>
<p><a href="http://latex.codecogs.com/eqneditor/editor.php">在线公式编辑器，快速知道语法</a></p>
<p>如果想要换行，在一行的后面空两个空格就行，例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这一行后没有两个空格</span><br><span class="line">所以不能换行</span><br></pre></td></tr></table></figure>
<p>这一行后没有两个空格
所以不能换行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这一行后有两个空格  </span><br><span class="line">所以能换行</span><br></pre></td></tr></table></figure>
<p>这一行后有两个空格<br>所以能换行</p>
]]></content>
      <categories>
        <category>guide</category>
        <category>jekyll</category>
      </categories>
      <tags>
        <tag>guide</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1.Two Sum</title>
    <url>/2017/08/18/2017-08-18-two-sum/</url>
    <content><![CDATA[<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1 Two Sum"></a>1 Two Sum</h2><p>题目描述：Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>题目理解：输入一个数组和一个目标值，若数组中两个值之和等于目标值，返回它们的下标，每个数只能使用一次。</p>
<hr>
<p>代码1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; diffs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Integer i = <span class="keyword">null</span>, index = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (  ( index = diffs.get( nums[i] ) ) != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                diffs.put( target - nums[i] , i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] indexs = &#123;index,i&#125;;</span><br><span class="line">        <span class="keyword">return</span> indexs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重头开始遍历，查看当前数字是否在差值中，在其中就返回，否则计算差值，加入map。</p>
<p>复杂度：nlog(n)，运行时间10ms。</p>
<p><img src="/images/leetcode/Two_Sum_1.png" alt="images"></p>
<hr>
<p>代码2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] inums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++ ) &#123;</span><br><span class="line">            inums[i][<span class="number">0</span>] = nums[i];</span><br><span class="line">            inums[i][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(inums, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">( <span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2 )</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span>[] res = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = inums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( l &lt; r ) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = inums[l][<span class="number">0</span>] + inums[r][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> ( sum &lt; target ) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( sum &gt; target ) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[<span class="number">0</span>] = inums[l][<span class="number">1</span>]; res[<span class="number">1</span>] = inums[r][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将原始数据排序，然后进行左右逼近，得到结果。</p>
<p>复杂度nlog(n),运行时间12ms。</p>
<p><img src="/images/leetcode/Two_Sum.png" alt="images"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建jekyll博客的一些回顾。</title>
    <url>/2017/08/19/2017-08-19-build-blog-review/</url>
    <content><![CDATA[<p>其实简单回顾，这一切并没有多复杂…所需要的东西也不多。</p>
<hr>
<h2 id="环境以及工具"><a href="#环境以及工具" class="headerlink" title="环境以及工具"></a>环境以及工具</h2><p>运行环境：windows 10<br>博客部署位置：github<br>博客引擎：jekyll</p>
<p>需要下载安装的工具：</p>
<ul>
<li>ruby</li>
<li>github desktop</li>
</ul>
<hr>
<h2 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h2><p>从最开始梳理整个流程：</p>
<ol>
<li>拥有一个github账号。</li>
<li>在账户下建立 <code>用户名.github.io</code> 的repository。</li>
<li>决定使用jekyll。</li>
<li>寻找一个自己喜欢的jekyll模板。</li>
<li>fork或者git这个模板到本地。</li>
<li>本地安装jekyll。</li>
<li>按照模板的介绍，结合jekyll调整模板配置。</li>
<li>上传模板到<code>用户名.github.io</code>，结束。</li>
</ol>
<hr>
<h2 id="创建github账号"><a href="#创建github账号" class="headerlink" title="创建github账号"></a>创建github账号</h2><p><a href="https://github.com/">github</a></p>
<hr>
<h2 id="建立repository"><a href="#建立repository" class="headerlink" title="建立repository"></a>建立repository</h2><p>一定要建立名字叫做<code>用户名.github.io</code>的repository，
这样github就会在这个repository下面启动<a href="https://pages.github.com/">github page</a> 。</p>
<p>建好后：
<img src="/images/guide/build_blog_1.png" alt="image"></p>
<hr>
<h2 id="决定是否使用jekyll"><a href="#决定是否使用jekyll" class="headerlink" title="决定是否使用jekyll"></a>决定是否使用jekyll</h2><p>目前据自己研究，主要就是jekyll和hexo两种方式，
好像hexo更好用？</p>
<p>但是无所谓了，先用jekyll感受下。</p>
<hr>
<h2 id="寻找jekyll模板"><a href="#寻找jekyll模板" class="headerlink" title="寻找jekyll模板"></a>寻找jekyll模板</h2><p>首先，当然是参考知乎了:<a href="https://www.zhihu.com/question/20223939">有哪些简洁明快的 Jekyll 模板？</a></p>
<p>第二，主要还是去比较官方的找了</p>
<ul>
<li><a href="http://jekyllthemes.org/">jekyllthemes</a></li>
<li><a href="https://jekyllthemes.io/">jekyllthemes.io</a></li>
</ul>
<p>最后选择了<a href="http://jekyllthemes.org/themes/jekyll-theme-next/">NexT</a></p>
<p><img src="/images/guide/build_blog_2.png" alt="image"></p>
<p>主要是简洁，但是功能却一个不少。</p>
<p>另外，这是一个Hexo上的模板，作者Yitao Yao搬过来的，
今天看了看知乎才知道这是Hexo上最火的模板…大众审美。</p>
<hr>
<h2 id="下载这个模板到本地"><a href="#下载这个模板到本地" class="headerlink" title="下载这个模板到本地"></a>下载这个模板到本地</h2><p>首先去到模板的github上的地址，然后复制它的git地址。</p>
<p><img src="/images/guide/build_blog_3.png" alt="image"></p>
<p>然后用github客户端clone到本地。</p>
<p><img src="/images/guide/build_blog_4.png" alt="image"></p>
<p>这样模板就得到了，甚至上传模板到<code>用户名.github.io</code>，就已经可以了。
但是为了获得“修改配置以及写博客时可以本地预览效果，觉得好就上传，不好就不上传”的效果，
需要安装jekyll来进行本地预览。</p>
<hr>
<h2 id="安装jekyll"><a href="#安装jekyll" class="headerlink" title="安装jekyll"></a>安装jekyll</h2><p>jekyll一般用ruby来安装，所以首先安装<a href="https://rubyinstaller.org/downloads/">ruby</a> 。</p>
<p>下载下来后，一路按next就可以了。</p>
<p>打开命令行，输入 <code>ruby -v</code>,  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ruby -v</span><br><span class="line"></span><br><span class="line">ruby 2.4.1p111 (2017-03-22 revision 58053) [x64-mingw32]</span><br></pre></td></tr></table></figure>
<p>出现版本信息，那么ruby安装就成功了。</p>
<p>由于国内与国外网络之间的一些隔阂，这里需要换一下ruby的源，
否则待会安装jekyll可能很慢或者卡住。</p>
<p><a href="http://gems.ruby-china.org/">国内源</a> ，
以前国内源域名<code>http://ruby.taobao.org/</code> ，
但是现在改到<code>https://gems.ruby-china.org/</code> 了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gem sources --add https:&#x2F;&#x2F;gems.ruby-china.org&#x2F; --remove https:&#x2F;&#x2F;rubygems.org&#x2F;</span><br><span class="line">$ gem sources -l</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;gems.ruby-china.org</span><br><span class="line"># 确保只有 gems.ruby-china.org</span><br></pre></td></tr></table></figure>
<p>先用ruby安装Bundler，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gem install bundler</span><br><span class="line"></span><br><span class="line">Fetching: bundler-1.15.3.gem (100%)</span><br><span class="line">Successfully installed bundler-1.15.3</span><br><span class="line">Parsing documentation for bundler-1.15.3</span><br><span class="line">Installing ri documentation for bundler-1.15.3</span><br><span class="line">Done installing documentation for bundler after 6 seconds</span><br><span class="line">1 gem installed</span><br></pre></td></tr></table></figure>
<p>安装好Bundler之后，这时候就需要更改命令行位置到执行目录到模板文件夹。
这里可以先打开模板文件夹，按住<strong>shift</strong>键，在文件夹空白处<strong>右键</strong>，
就会有一个类似<strong>在此处打开CMD</strong>的选项。<br>然后执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bundle install</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Thank you for installing html-pipeline!</span><br><span class="line">You must bundle Filter gem dependencies.</span><br><span class="line">See html-pipeline README.md for more details.</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jch&#x2F;html-pipeline#dependencies</span><br></pre></td></tr></table></figure>
<p>注意这条命令实际上是去安装了文件夹下的Gemfile文件下的记录的文件，
更重要的是在文件里面有一条<code>source &#39;https://rubygems.org&#39;</code>，
这样它又把源换成了国外，将它注释掉，换成<code>source &#39;https://gems.ruby-china.org/&#39;</code> 。</p>
<p>这样，所需的所有环境就都搭好了，只要保证所有软件都是最新版本的，应该不会出现问题。</p>
<p>下一步就是同样在模板文件夹下，运行，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bundle exec jekyll serve --watch</span><br></pre></td></tr></table></figure>
<p>没有问题的话，本地服务器就运行起来了，</p>
<p><img src="/images/guide/build_blog_5.png" alt="image"></p>
<p>进入浏览器，打开网址 <code>localhost:4000</code>，就能预览到博客的效果了。
注意这里命令后面加了<code>--watch</code>，这使得你更改博客时，预览效果也会实时改变。</p>
<hr>
<h2 id="调整模板配置"><a href="#调整模板配置" class="headerlink" title="调整模板配置"></a>调整模板配置</h2><p>每个模板都会有它自己的配置说明，这里NexT有很完善的<a href="http://theme-next.iissnan.com/">NexT使用说明</a>
，毕竟用的人多。</p>
<p>这里配置遇到问题就是侧边栏只能在右边，可能是因为移植的问题，反正没太大影响，无所谓。</p>
<hr>
<h2 id="上传模板"><a href="#上传模板" class="headerlink" title="上传模板"></a>上传模板</h2><p>首先，使用github客户端clone下<code>用户名.github.io</code>这个repository，方法和上面一样，
当然，如果它没有文件不知道能不能clone，试试<code>https://github.com/用户名/用户名.github.io.git</code>
这个url来clone。</p>
<p>clone下来之后，复制模板文件夹下的所有文件到<code>用户名.github.io</code>文件夹下。</p>
<p>查看github客户端，它会检测到改动。这时先在本地commit一下这个改动，
在箭头处输入改动的标题，想更多描述也行。</p>
<p><img src="/images/guide/build_blog_6.png" alt="image"></p>
<p>然后在1处本地确定这次改动，在2处点击即可将本地的改动push到github上。</p>
<p><img src="/images/guide/build_blog_7.png" alt="image"></p>
<p>这样，在浏览器打开<code>用户名.github.io</code>这个地址，就可以看到自己的博客了！！！</p>
<hr>
<h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>写博客就在本地<code>用户名.github.io</code>这个文件夹下的<code>_posts</code>下面写Markdown。</p>
<p>想加图片就在<code>用户名.github.io</code>这个文件夹建立一个images文件夹，图片放到里面，
在Markdown里面用<code>&#123;去掉&#123;site.url&#125;&#125;/images/my.png</code>这个链接就行。</p>
<p>然后仍然可以在<code>用户名.github.io</code>这个文件夹下用<code>bundle exec jekyll serve --watch</code>命令，
来进行本地预览<code>localhost:4000</code>。</p>
<p>觉得可以之后，就用github客户端push就ok了。</p>
]]></content>
      <categories>
        <category>guide</category>
        <category>jekyll</category>
      </categories>
      <tags>
        <tag>guide</tag>
      </tags>
  </entry>
  <entry>
    <title>购买域名并绑定博客原地址</title>
    <url>/2017/08/20/2017-08-20-add-domain-name/</url>
    <content><![CDATA[<p>其实我也不知道为什么要买一个域名，对我自己来说没什么卵用，
但是这样很爽，虽然挺贵的…</p>
<hr>
<h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>这里我的域名是在<a href="https://dcc.godaddy.com/">godaddy</a> 上购买的，
就买一个<code>.com</code>的域名就行，另外还买了隐私保护，不管有没有什么大用，
反正已经买了。</p>
<p>这里我买了5年的，主要买的时候使用优惠码，直接搜索引擎搜索“godaddy 优惠码”就行，
隐私服务可买可不买，买了之后，购买信息就变了，</p>
<p><img src="/images/guide/add-domain-name_1.png" alt="image"></p>
<p>域名花费300￥，隐私保护200￥，一共5年，就当我自己买了个移动硬盘…</p>
<hr>
<h2 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h2><p>先操作github，在github的工程下面建一个CNAME文件，加入一行域名，我的<code>longrm.com</code>。
github会自动按这个域名来转。  </p>
<p><img src="/images/guide/add-domain-name_2.png" alt="image" title="CNAME"></p>
<p><img src="/images/guide/add-domain-name_3.png" alt="image" title="CNAME Content"></p>
<p>或者这里也可以不建这个文件，进入repository的setting里面，custom一下也行，</p>
<p><img src="/images/guide/add-domain-name_4.png" alt="image" title="setting"></p>
<p><img src="/images/guide/add-domain-name_5.png" alt="image" title="custom domain"></p>
<p>第二步就是去godaddy下面改域名的设置，参考：</p>
<ul>
<li><a href="http://andrewsturges.com/blog/jekyll/tutorial/2014/11/06/github-and-godaddy.html">Configuring a Godaddy domain name with github pages</a></li>
<li><a href="https://help.github.com/articles/setting-up-an-apex-domain/">Setting up an apex domain</a></li>
</ul>
<p>简单总结参考里面的内容，更改下图两条变成所示就行了:</p>
<ul>
<li>将<code>A</code>的值改成<code>192.30.252.153</code>。</li>
<li>将<code>CNAME</code>的<code>www</code>那一条改成<code>用户名.github.io</code>，这里我的就是<code>isadamu.github.io</code>。</li>
</ul>
<p><img src="/images/guide/add-domain-name_6.png" alt="image"></p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>浏览器输入买的域名，<code>longrm.com</code>，大功告成：</p>
<p><img src="/images/guide/add-domain-name_7.png" alt="image"></p>
]]></content>
      <categories>
        <category>guide</category>
      </categories>
      <tags>
        <tag>guide</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 71.Simplify Path</title>
    <url>/2017/08/21/2017-08-21-simplfiy-path/</url>
    <content><![CDATA[<h2 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71.Simplify Path"></a>71.Simplify Path</h2><p>题目：</p>
<blockquote>
<p>Given an absolute path for a file (Unix-style), simplify it.  </p>
<p>For example,<br>path = <code>&quot;/home/&quot;</code>, =&gt; <code>&quot;/home&quot;</code><br>path = <code>&quot;/a/./../../c/&quot;</code>, =&gt; <code>&quot;/c&quot;</code></p>
</blockquote>
<p>另外题目需要注意的是当出现<code>&quot;/../&quot;</code>时，返回<code>&quot;/&quot;</code>,<br>多个<code>&quot;/&quot;</code>看成一个就行。</p>
<p>理解：</p>
<p>输入一个路径，将路径简单化，也就是去掉其中的<code>&quot;..&quot;</code>,<code>&quot;.&quot;</code>
以及多余的<code>&quot;/&quot;</code>,另外路径的最后不要加上<code>&quot;/&quot;</code>。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        String[] strs = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        String[] res = <span class="keyword">new</span> String[strs.length];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( String str : strs ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( str.length() == <span class="number">0</span> || str.equals(<span class="string">&quot;.&quot;</span>) ) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( str.equals(<span class="string">&quot;..&quot;</span>) ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( idx != <span class="number">0</span> ) &#123;</span><br><span class="line">                    idx--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[idx++] = str;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( idx == <span class="number">0</span> ) </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        StringBuilder res_str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx; i++ ) &#123;</span><br><span class="line">            res_str.append(<span class="string">&quot;/&quot;</span>).append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res_str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：O(n)，运行时间7ms。</p>
<p><img src="/images/leetcode/simplify-path_1.png" alt="image"></p>
<p>这里有一个值得注意的地方，最开始，我是这样写的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strs = path.split(<span class="string">&quot;/+&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>之后改成了，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strs = path.split(<span class="string">&quot;/&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>瞬间从15ms击败25%，变成了击败95%。所以<code>split</code>的多字符匹配还是要慢得多。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素贝叶斯+垃圾邮件分类器</title>
    <url>/2017/08/21/2017-08-21-spam-classifier/</url>
    <content><![CDATA[<hr>
<h2 id="Naive-Bayes-朴素贝叶斯"><a href="#Naive-Bayes-朴素贝叶斯" class="headerlink" title="Naive Bayes 朴素贝叶斯"></a>Naive Bayes 朴素贝叶斯</h2><p>关于吴恩达的cs229课程的一份笔记，关于朴素贝叶斯分类器在垃圾邮件分类上的应用。</p>
<hr>
<h2 id="spam-classifier-垃圾邮件分类器"><a href="#spam-classifier-垃圾邮件分类器" class="headerlink" title="spam classifier 垃圾邮件分类器"></a>spam classifier 垃圾邮件分类器</h2><p>样本: 过去时间收到的所有邮件，共$m$封。</p>
<p>步骤：</p>
<p>1.首先建立词典$X$，词典中共有$n$个词。</p>
<p>2.通过样本估计概率，</p>
<script type="math/tex; mode=display">
P(X_i = 1|y = 1)=\Phi_{i|y=1}</script><p>其中$X_i \in {0,1}$，表示词典中的第$i$个词是否出现，$X_i = 1$表示出现。</p>
<script type="math/tex; mode=display">
P(X_i = 1|y = 0)=\Phi_{i|y=0}</script><p>上面的$y \in {0,1}$，并且$y=1$表示邮件为<strong>垃圾邮件</strong>。令</p>
<script type="math/tex; mode=display">
P(y=1)=\Phi_y</script><p>然后利用极大似然法估计概率值。</p>
<p>3.通过上面得到 $P(X|y)$ 与 $P(y)$的概率，
对于新的输入$X$，
就可以用$P(y|X)$就可判断$y$。</p>
<hr>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>这里考虑词的出现次数，对上面的分类器进行改进。</p>
<p>这个模型称为：<strong>Multinomial Event Model</strong>。</p>
<p>步骤：</p>
<p>1.建立词典，词典的词的总数为$V$。</p>
<p>2.对于一封邮件，将其转化为向量<script type="math/tex">X</script>，<script type="math/tex">X_i</script>的表示第<script type="math/tex">i</script>个词在词典中的位置。
例如，邮件开头为<code>A NIPS ...</code>，其中<code>A</code>在词典的第<strong>1</strong>个，
<code>NIPS</code>在词典的<strong>35000</strong>个，则<script type="math/tex">X_1 = 1, \  X_2 = 35000</script>。</p>
<p>3.通过样本估计概率，</p>
<script type="math/tex; mode=display">
P(X_j = k | y = 1)= \Phi_{k|y=1}</script><p>其中$k \in {0,1,…,n}$，对$X_j=k$表示邮件中的第$j$个词在词典中的位置为$k$。</p>
<script type="math/tex; mode=display">
P(X_j = k | y = 0)= \Phi_{k|y=0}</script><p>同样的，上面$y \in {0,1}$，对于$y=1$，它就表示邮件为垃圾邮件。令：</p>
<script type="math/tex; mode=display">
P(y = 1)= \Phi_y</script><p>同样的，利用极大似然法估计概率值。</p>
<p>4.通过上面得到$P(X|y)$与$P(y)$的概率，
对于新的输入$X$，
就可以用$P(y | X)$来判断$y$。</p>
]]></content>
      <categories>
        <category>cs229</category>
      </categories>
      <tags>
        <tag>mechine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Coursera neural-networks-deep-learning 笔记</title>
    <url>/2017/08/22/2017-08-22-Andrew-Ng-DeepLearning_1/</url>
    <content><![CDATA[<p><a href="https://www.coursera.org/learn/neural-networks-deep-learning">课程主页</a></p>
<p>学完了吴恩达在Coursera上新开的课程的第一部分<code>neural networks deep learning</code>，
是时候对课程进行一下总结了。</p>
<hr>
<h2 id="每周内容小回顾"><a href="#每周内容小回顾" class="headerlink" title="每周内容小回顾"></a>每周内容小回顾</h2><p>先对第一个专项课程所讲的内容进行简单的梳理，后面捡重点单独拿出来进行记录。</p>
<h3 id="week-1"><a href="#week-1" class="headerlink" title="week 1"></a>week 1</h3><p>第一周视频时间很短，主要就是介绍了神经网络的发展以及它的一些作用，
然后讲了课程的相关内容，如何讨论啊，作业形式啊什么的。</p>
<h3 id="week-2"><a href="#week-2" class="headerlink" title="week 2"></a>week 2</h3><p>第二周的课程首先引入了<strong>Logistic Regression</strong>，然后讲了如何对<strong>Logistic</strong>模型进行训练，
这样就引入了代价函数，梯度下降等等一些机器学习中的一些概念。</p>
<p>另外，后半部分又顺带引入了计算过程的向量化，所以就讲了与作业有关的<strong>Jupyter、numpy</strong>的相关操作。</p>
<h3 id="week-3"><a href="#week-3" class="headerlink" title="week 3"></a>week 3</h3><p>第三周主要讲了一个二层的神经网络，当然是先讲了它的前向传播，然后讲了如何向量化计算，
这里主要是为了讲清楚神经网络的层次结构。</p>
<p>然后讲了神经网络中的激活函数，最后给出了反向传播，加上权值的随机初始化。</p>
<h3 id="week-4"><a href="#week-4" class="headerlink" title="week 4"></a>week 4</h3><p>第四周开始更深层次的神经网络，然后讲了前向和反向传播，并且强调了神经网络每一层的
矩阵维度问题，在程序中要注意维度的正确性。</p>
<p>最后讲了参数设置问题。<code>Parameters</code>：通过网络学习得来的参数。
<code>Hyperparameters</code>：在训练前就要设置，需要多次重复训练来手动调整。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>讲了构建一个多层的前向神经网络所需要的基本的知识。</p>
<hr>
<h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><p><a href="http://longrm.com/2017/08/22/2017-08-22-logistic-regression/">Logistic Regression总结</a></p>
<hr>
<h2 id="初级-Deep-Neural-Networks"><a href="#初级-Deep-Neural-Networks" class="headerlink" title="初级 Deep Neural Networks"></a>初级 Deep Neural Networks</h2><p><a href="http://longrm.com/2017/08/22/2017-08-22-dnn/">Deep Neural Networks 总结一</a></p>
<hr>
<h2 id="课程的一些问题"><a href="#课程的一些问题" class="headerlink" title="课程的一些问题"></a>课程的一些问题</h2><p>好像没有ppt，笔记写起来很痛苦啊。</p>
]]></content>
      <categories>
        <category>coursera</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>mechine learning</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>DNN 笔记一</title>
    <url>/2017/08/22/2017-08-22-dnn/</url>
    <content><![CDATA[<p>关于第一个专项课程的笔记。</p>
<p>这里先简单的定义为DNN就是层数很多的神经网络。</p>
<hr>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>神经网络的激活函数一般有以下四种：</p>
<p><img src="/images/coursera/nndl-note_2.png" alt="image" title="各种激活函数"></p>
<p>它们的方程写为：</p>
<script type="math/tex; mode=display">
sigmoid = \frac{1}{1+e^{-Z}}</script><script type="math/tex; mode=display">
tanh = \frac{e^x-e^{-x}}{e^x+e^{-x}}</script><script type="math/tex; mode=display">
Relu = max(0,Z)</script><script type="math/tex; mode=display">
Leaky Relu = max(0.01Z,Z)</script><p>从图中可以看出，对于<strong>sigmoid</strong>函数，它的输出大于1，这对于神经网络来说是不利的。
<strong>tanh</strong>就能对<strong>sigmoid</strong>函数进行改进，使得输出值的范围在-1到1之间。</p>
<p>但是，对于<strong>sigmoid</strong>和<strong>tanh</strong>来说，当输出值<strong>Z</strong>过大或者过小时，
当我们在求取梯度的时候，这个地方的梯度值就几乎为0，这样就使得在网络层数较多时，
梯度值在某一层就会变为十分接近0，影响到梯度的反向传播。</p>
<p>所以，一般情况下，使用<strong>Relu</strong>或<strong>Leaky Relu</strong>来作为神经网络的激活函数，
它不仅能改善梯度的反向传播，还可以加快训练速度，因为作为函数，它的计算算是非常简单。</p>
<p>对它们进行求导，看它们的导函数长什么样：</p>
<p>对于$g(z) = \frac {1}{1+e^{-z}}$，它的导函数为：</p>
<script type="math/tex; mode=display">
\frac{d}{dz}g(z) = g(z)(1 - g(z))</script><p>对于$g(z) = tanh(z)$，</p>
<script type="math/tex; mode=display">
\frac{d}{dz}g(z) = 1 - g(z)^2</script><p>对于$g(z) = Rule(z) = max(0,z)$,</p>
<script type="math/tex; mode=display">
\frac{d}{dz}g(z) =
\begin{cases}
0 \ \ \ \ \ ,\mbox{if } z < 0 \\
1 \ \ \ \ \ ,\mbox{if } z > 0
\end{cases}</script><p>最后对于$g(z) = LeakyRelu(z) = max(0.01z, z)$ ，</p>
<script type="math/tex; mode=display">
\frac{d}{dz}g(z) =
\begin{cases}
0.01 \ \ \ ,\mbox{if } z < 0 \\
1 \ \ \ \ \ \ \ \ ,\mbox{if } z > 0
\end{cases}</script><p>看得出上面的导数其实都很简单，这也有利于快速的计算。</p>
<hr>
<h2 id="两层神经网络"><a href="#两层神经网络" class="headerlink" title="两层神经网络"></a>两层神经网络</h2><p>在week_3的作业中，需要构建一个两层的神经网络，这里将它拿出来先分析一下。</p>
<p><img src="/images/coursera/nndl-note_3.png" alt="image" title="two-layer-net"></p>
<p>注意到这里的激活函数是<strong>tanh</strong>加上<strong>sigmoid</strong>，最后一层使用<strong>sigmoid</strong>的原因，
主要是为了输出一个0~1的值，就可以把它看成概率来处理。（由图中可以看出其中的上标
$[i]$就代表了层数）</p>
<p><strong>参数初始化</strong></p>
<p>这里需要初始化的参数有：</p>
<ul>
<li>学习速率$\alpha$。</li>
<li>链接权值$w^{[i]}$。</li>
<li>偏置$b^{[i]}$。</li>
</ul>
<p>对于学习速率$\alpha$，一般将其定义为一个确定的值即可，可能在0.01~1之间，
视情况而定，需要不断调整来获得它较优的取值。</p>
<p>对于偏置$b^{[i]}$，直接将它初始化为0就可以了。</p>
<p>对于权值$w^{[i]}$，这里就不能将它们初始化0，或者可以说不能将它们初始化为一个相同的值，
因为如果它们的初始值相同，它们之间的更新将不会有差异，这样它们会一直取到相同的值，
显然不行。
（如果使用drop-out策略，初始化为相同的值应该也无所谓）</p>
<p>对于权值的初始化，它的好坏对网络的训练也是会有很大影响的，后面再谈。</p>
<p>这里直接随机初始化就行，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w = np.random.randn(dx,dy) * <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">b = np.zeros((dx,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>这里权值$w$先以标准正态来随机取值，然后乘以0.01，防止权值过大造成计算出的数值过大。
偏置$b$直接初始化为0即可。</p>
<p><strong>前向传播</strong></p>
<p>对于一个输入$x^{(i)}$，它的<strong>前向传播</strong>过程如下：</p>
<script type="math/tex; mode=display">z^{[1] (i)} =  W^{[1]} x^{(i)} + b^{[1] (i)}</script><script type="math/tex; mode=display">a^{[1] (i)} = \tanh(z^{[1] (i)})</script><script type="math/tex; mode=display">z^{[2] (i)} = W^{[2]} a^{[1] (i)} + b^{[2] (i)}</script><script type="math/tex; mode=display">\hat{y}^{(i)} = a^{[2] (i)} = \sigma(z^{ [2] (i)})</script><script type="math/tex; mode=display">
y^{(i)}_{prediction} =
\begin{cases}
1 \ \ \ \ \ \mbox{if } a^{[2](i)} > 0.5 \\
0 \ \ \ \ \ \mbox{otherwise }
\end{cases}</script><p>这里的输出是一个$a^{[2]}$，它是$z^{[2]}$通过<strong>sigmoid</strong>函数求出来的，
输出的值可以看出一个概率值，所以这里使用一个交叉熵函数来估计最后的损失。</p>
<script type="math/tex; mode=display">
J = - \frac{1}{m} \sum_{i=0}^{m}
(y^{(i)}log(a^{[2](i)}) + (1 - y^{(i)})log(1 - a^{[2](i)}))</script><p><strong>反向传播求其梯度：</strong></p>
<p>最重要的，就是函数的反向传播过程了，这也是最难的地方，
但实际上它就是一个求取梯度的过程，但是由于函数嵌套太多，
所以容易引起困扰。</p>
<p>这里先忽略前面的系数，就当输入只有一个样本，所以去掉所有的上标$(i)$。</p>
<p>直接看一个最难的，结合上面的图与公式进行推导，</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial w^{[1]}} =
\frac{\partial J}{\partial a^{[2]}}
\frac{\partial a^{[2]}}{\partial z^{[2]}}
\frac{\partial z^{[2]}}{\partial a^{[1]}}
\frac{\partial a^{[1]}}{\partial z^{[1]}}
\frac{\partial z^{[1]}}{\partial w^{[1]}}</script><p>上面就是链式法则，显然要求$w^{[1]}$的偏导，首先要将前面的偏导数全部求出来，
一个一个的写出来。</p>
<p>首先对$a^{[2]}$进行求导，它是在上面的交叉熵函数里面，</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial a^{[2]}} =
\frac{1 - y}{1 - a^{[2]}} -
\frac{y}{a^{[2]}}</script><p>再对$z^{[2]}$进行求导，它通过了一个<strong>sigmoid</strong>函数，</p>
<script type="math/tex; mode=display">
\frac{\partial a^{[2]}}{\partial z^{[2]}} =
\frac{\partial}{\partial z^{[2]}}(\frac {1}{1+e^{-z^{[2]}}})
= a^{[2]}(1 - a^{[2]})</script><p>继续对$a^{[1]}$进行求导，它通过了一个线性运算，</p>
<script type="math/tex; mode=display">
\frac{\partial z^{[2]}}{\partial a^{[1]}} =
\frac{\partial }{\partial a^{[1]}} (w^{[2]}a^{[1]} + b^{[2]})
= w^{[2]}</script><p>接着对$z^{[1]}$进行求导，这里通过了一个<strong>tanh</strong>运算，</p>
<script type="math/tex; mode=display">
\frac{\partial a^{[1]}}{\partial z^{[1]}} =
\frac{\partial}{\partial z^{[1]}}
(\frac{e^{z^{[1]}} - e^{-z^{[1]}}}{e^{z^{[1]}} + e^{-z^{[1]}}}) =
1 - (a^{[1]})^2</script><p>最后对$w^{[1]}$进行求导，这也是同样的一个线性运算，</p>
<script type="math/tex; mode=display">
\frac{\partial z^{[1]}}{\partial w^{[1]}} =
\frac{\partial}{\partial w^{[1]}}(w^{[1]}x + b^{[1]}) =
x</script><p>对于偏执$b^{[1]}, b^{[2]}$，它们的导数同理，可以写为，</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial b^{[2]}} =
\frac{\partial J}{\partial a^{[2]}}
\frac{\partial a^{[2]}}{\partial z^{[2]}}
\frac{\partial z^{[2]}}{\partial b^{[2]}}</script><script type="math/tex; mode=display">
\frac{\partial J}{\partial b^{[1]}} =
\frac{\partial J}{\partial a^{[2]}}
\frac{\partial a^{[2]}}{\partial z^{[2]}}
\frac{\partial z^{[2]}}{\partial a^{[1]}}
\frac{\partial a^{[1]}}{\partial z^{[1]}}
\frac{\partial z^{[1]}}{\partial b^{[1]}}</script><p>其中，</p>
<script type="math/tex; mode=display">
\frac{\partial z^{[2]}}{\partial b^{[2]}} = 1</script><script type="math/tex; mode=display">
\frac{\partial z^{[1]}}{\partial b^{[1]}} = 1</script><hr>
<p>综合上面的所有式子，可以将各个参数的导数写为，</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial a^{[2]}} =
\frac{1 - y}{1 - a^{[2]}} +
\frac{y}{a^{[2]}}</script><script type="math/tex; mode=display">
\frac{\partial J}{\partial z^{[2]}} =
\frac{\partial J}{\partial a^{[2]}}
\frac{\partial a^{[2]}}{\partial z^{[2]}} =
\frac{\partial J}{\partial a^{[2]}}
a^{[2]}(1 - a^{[2]}) =
a^{[2]} - y</script><script type="math/tex; mode=display">
\frac{\partial J}{\partial w^{[2]}} =
\frac{\partial J}{\partial z^{[2]}}
\frac{\partial z^{[2]}}{\partial w^{[2]}} =
\frac{\partial J}{\partial z^{[2]}}
a^{[1]} =
(a^{[2]} - y)a^{[1]}</script><script type="math/tex; mode=display">
\frac{\partial J}{\partial b^{[2]}} =
\frac{\partial J}{\partial z^{[2]}}
\frac{\partial z^{[2]}}{\partial b^{[2]}} =
\frac{\partial J}{\partial z^{[2]}} =
a^{[2]} - y</script><script type="math/tex; mode=display">
\frac{\partial J}{\partial a^{[1]}} =
\frac{\partial J}{\partial z^{[2]}}
\frac{\partial z^{[2]}}{\partial a^{[1]}} =
\frac{\partial J}{\partial z^{[2]}}
w^{[2]} =
(a^{[2]} - y)w^{[2]}</script><script type="math/tex; mode=display">
\frac{\partial J}{\partial z^{[1]}} =
\frac{\partial J}{\partial a^{[1]}}
\frac{\partial a^{[1]}}{\partial z^{[1]}} =
\frac{\partial J}{\partial a^{[1]}}
(1 - (a^{[1]})^2)</script><script type="math/tex; mode=display">
\frac{\partial J}{\partial w^{[1]}} =
\frac{\partial J}{\partial z^{[1]}}
\frac{\partial z^{[1]}}{\partial w^{[1]}} =
\frac{\partial J}{\partial z^{[1]}}
x</script><script type="math/tex; mode=display">
\frac{\partial J}{\partial b^{[1]}} =
\frac{\partial J}{\partial z^{[1]}}
\frac{\partial z^{[1]}}{\partial b^{[1]}} =
\frac{\partial J}{\partial z^{[1]}}</script><hr>
<p>所以在计算正向传播时，需要将中间计算得到的各个$a^{[i]}$的值保存下来，
因为在反向传播时，会用到它们。</p>
<p>在反向传播的计算中，一层一层从后向前计算梯度，
就可以利用链式法则计算出各个参数的梯度了。</p>
<p><strong>参数更新：</strong></p>
<p>这里先不引入高级的参数更新方式，就正常的更新，</p>
<script type="math/tex; mode=display">
w^{[2]} = w^{[2]} -
\alpha \frac{\partial J}{\partial w^{[2]}}</script><script type="math/tex; mode=display">
b^{[2]} = b^{[2]} -
\alpha \frac{\partial J}{\partial b^{[2]}}</script><script type="math/tex; mode=display">
w^{[1]} = w^{[1]} -
\alpha \frac{\partial J}{\partial w^{[1]}}</script><script type="math/tex; mode=display">
b^{[1]} = b^{[1]} -
\alpha \frac{\partial J}{\partial b^{[1]}}</script><hr>
<h2 id="更多层的神经网络"><a href="#更多层的神经网络" class="headerlink" title="更多层的神经网络"></a>更多层的神经网络</h2><p>简单的理解，深度神经网络就是层数比较多的神经网络，
所以基本的操作可以说和上面的两层神经网络是一样的，</p>
<p>下面按照编程题过一遍整个流程，首先是网络结构图，</p>
<p><img src="/images/coursera/nndl-note_4.png" alt="image"></p>
<p>图中就是一个深度神经网络的结构，它中间神经元的激活函数是<strong>ReLU</strong>，
最后一层是由<strong>sigmoid</strong>神经元组成，这一般适用于进行多分类。</p>
<p>由图中，可以看出整个神经网络的一个训练步骤：</p>
<ol>
<li>初始化各层的权值$W$和$b$。</li>
<li>输入样本，进行前向传播，先进过一系列的<strong>ReLU</strong>激活函数，
最后再通过一个<strong>sigmoid</strong>，得到最后得输出。</li>
<li>对于得到的输出，计算它与样本的标签值的交叉熵，得到当前的损失。</li>
<li>将损失反向传播。</li>
<li>更新各个参数，继续从第2步开始。</li>
</ol>
<p>注意在前向传播的过程中，要存下每一层的输出，因为在反向传播时需要用到它们。</p>
<p><strong>各层参数的维度：</strong></p>
<p>明白各层参数的维度，对于理解神经网络的代码很重要，这里写出它们的矩阵维度。</p>
<p>首先，假设一个输入样本是一个<strong>12288</strong>长度的行向量，它是由一幅<strong>64*64*3</strong>的图片展开而成的，
同时假设输入共有<strong>209</strong>个样本。</p>
<p>同时需要假设如下的一些东西：</p>
<ul>
<li>网络一共有$L$层。</li>
<li>样本数$m = 209$。</li>
<li>样本维度$n = 12288$。</li>
<li>第$i$层的神经元数量有$n^{[i]}$个。</li>
<li>最后一层就是输出层，按上面的定义，它神经元的个数就是$n^{[L]}$个。</li>
</ul>
<p>从输入开始，假设每个样本是一个列向量，那么输入就是一行输入样本，</p>
<script type="math/tex; mode=display">
X =
\begin{bmatrix}
x^{[1]} & x^{[2]} & ... & x^{[m-1]} & x^{[m]}
\end{bmatrix}</script><p>其中$x^{[i]}$就是一个样本，它是一个列向量，</p>
<script type="math/tex; mode=display">
x^{[i]} =
\begin{bmatrix}
x_1^{[i]}     \\
x_2^{[i]}     \\
...           \\
x_{n-1}^{[i]} \\
x_n^{[i]}
\end{bmatrix}</script><p>所以输入$X$的维度是，$X \in R^{n \times m}$。</p>
<p>为了方便线性运算，也就是之间$WX + b$来计算，这里把每个神经元定义为一个行向量，
并且它的长度等于它上一层的神经元数。</p>
<script type="math/tex; mode=display">
W^{[i](j)} =
\begin{bmatrix}
w_{1}^{[i](j)} & w_{2}^{[i](j)} & ... & w_{n^{[i-1]}-1}^{[i](j)} & w_{n^{[i-1]}}^{[i](j)}
\end{bmatrix}</script><p>其中$W^{[i](j)}$就表示第$i$层的第$j$个神经元。那么对于$W^{[i]}$，它就等于，</p>
<script type="math/tex; mode=display">
W^{[i]} =
\begin{bmatrix}
W_1^{[i]}     \\
W_2^{[i]}     \\
...           \\
W_{n^{[i]}-1}^{[i]} \\
W_{n^{[i]}}^{[i]}
\end{bmatrix}</script><p>所以第$i$层的神经元的权值矩阵$W^{[i]}$的维度为，$W^{[i]} \in R^{n^{[i]} \times n^{[i-1]}}$，另外，</p>
<script type="math/tex; mode=display">
z^{[i]} = W^{[i]}a^{[i-1]} + b  \in R^{n^{[i]} \times m}</script><script type="math/tex; mode=display">
a^{[i]} = g(z^{[i]}) \in R^{n^{[i]} \times m}</script><hr>
<p>将它们的维度总结如下，当然它们所对应的导数和它们的维度一致，</p>
<script type="math/tex; mode=display">
X \in R^{n \times m}</script><script type="math/tex; mode=display">
z^{[i]} \in R^{n^{[i]} \times m}</script><script type="math/tex; mode=display">
a^{[i]} \in R^{n^{[i]} \times m}</script><script type="math/tex; mode=display">
W^{[i]} \in R^{n^{[i]} \times n^{[i-1]}}</script><script type="math/tex; mode=display">
b^{[i]} \in R^{n^{[i]} \times 1}</script><hr>
<p><strong>前向传播：</strong></p>
<p>只需要注意保存中间变量。</p>
<p><strong>反向传播：</strong></p>
<p><img src="/images/coursera/nndl-note_5.png" alt="image"></p>
<p>结合对两层神经网络的描述，其实反向传播的计算也很简单，
就从后向前计算导数就好了。</p>
<p><strong>Hyperparameter：</strong></p>
<p>超参数，就是一些需要在训练前就确定好的参数，并且可以认为一旦训练开始，
就不能再改变它们的值了，在神经网络中，超参数控制着$W$和$b$的最终取值，
可以认为它们决定了网络的最终性能。</p>
<p>例如下面的一些参数，</p>
<ul>
<li>学习速率$\alpha$。</li>
<li>迭代次数$t$。</li>
<li>网络层数$L$。</li>
<li>某一层的神经元数$n^{[1]},n^{[2]},…$</li>
<li>激活函数的选择。</li>
</ul>
<p>对于这样一些的参数的选择，通常情况都得按着经验来，现在的很多研究也都是围绕着如何调参来展开的。</p>
<p>一般情况只能一个一个的去试，看哪一组参数最合适，所以这是一个很耗时间的过程。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一个专项的课程，主要还是在于引入深度神经网络，讲了最为重要的前向传播和反向传播，
理解好前向与反向传播，对于神经网络的学习至关重要。</p>
]]></content>
      <categories>
        <category>coursera</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>mechine learning</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>jekyll博客顶端背景修改</title>
    <url>/2017/08/22/2017-08-22-head-color/</url>
    <content><![CDATA[<p>由于NexT是Hexo上的主题，搬运到jekyll上面之后，目录结构完全不一样，所以网上的参考基本没什么用。</p>
<hr>
<h2 id="修改head颜色"><a href="#修改head颜色" class="headerlink" title="修改head颜色"></a>修改head颜色</h2><p>在<code>_sass/_schemes/Mist/_header.scss</code>下面修改，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.header &#123; background: $whitesmoke; &#125;</span><br></pre></td></tr></table></figure>
<p>为，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.header &#123; background: #FFC78E; &#125;</span><br></pre></td></tr></table></figure>
<p>然后就变成下面的颜色，</p>
<p><img src="/images/guide/head-color_1.png" alt="image" title="改为了橘黄色"></p>
]]></content>
      <categories>
        <category>guide</category>
        <category>jekyll</category>
      </categories>
      <tags>
        <tag>guide</tag>
      </tags>
  </entry>
  <entry>
    <title>Logistic Regression 简单总结</title>
    <url>/2017/08/22/2017-08-22-logistic-regression/</url>
    <content><![CDATA[<hr>
<h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><p>把它看成只有一个神经元的神经网络，激活函数就是<code>sigmoid</code>函数。</p>
<hr>
<h2 id="模型："><a href="#模型：" class="headerlink" title="模型："></a>模型：</h2><script type="math/tex; mode=display">
\hat y = \sigma (W^T x + b)</script><p>其中，</p>
<script type="math/tex; mode=display">
\sigma(Z) = \frac{1}{1+e^{-Z}}</script><hr>
<h2 id="代价函数："><a href="#代价函数：" class="headerlink" title="代价函数："></a>代价函数：</h2><script type="math/tex; mode=display">
J(W,b) = \frac{1}{m} \sum_{i=1}^m L(\hat y^{(i)},y^{(i)} )
= - \frac{1}{m} \sum_{i=1}^m y^{(i)}log \ \hat y^{(i)}
+ (1-y^{(i)})log(1 - \hat y^{(i)})</script><p>视频中好像没有具体说这个损失函数的一个推导，这里自己简单推一推。</p>
<p>首先对于$\sigma(Z)$这个函数，它其实就是经常说到的<strong>sigmoid</strong>函数，
它的函数图像如下：</p>
<div align="center"><img src="/images/coursera/nndl-note_1.png"
style="zoom:50%" title="sigmoid函数" /></div>

<p>可以看出sigmoid函数的值域范围是0~1，所以通常把它当成一个概率来看待，
那么，可以写出<code>y</code>的概率表达式为：</p>
<script type="math/tex; mode=display">
P(y) = (\hat y)^y (1 - \hat y)^{1-y}</script><p>其中$\hat y$就是预测$y$为1的概率，区分两种情况，
上面的式子分开写就是下面的式子，合并在一起有利于公式化：</p>
<script type="math/tex; mode=display">
P(y) =
\begin{cases}
\hat y \ \ \ \ \ \ \ \ \ \ ,y = 1 \\
1 - \hat y \ \ \ ,y = 0
\end{cases}</script><p>所以我们采用<strong>极大似然法</strong>来进行对$W$的求解，似然函数就可以写为：</p>
<script type="math/tex; mode=display">
\prod_{i=1}^m (\hat y^{(i)})^{y^{(i)}}(1 - \hat y^{(i)})^{1 - y^{(i)}}</script><p>对数似然写为：</p>
<script type="math/tex; mode=display">
L(\hat y) = \sum_{i=1}^m y^{(i)}log \ \hat y^{(i)}
+ (1-y^{(i)})log(1 - \hat y^{(i)})</script><p>加上$- \frac{1}{m}$就得到了上面的代价函数，同时也从最大化变成了最小化。</p>
<hr>
<h2 id="梯度："><a href="#梯度：" class="headerlink" title="梯度："></a>梯度：</h2><p>首先需要对代价函数进行求导，下面进行推导，令：</p>
<script type="math/tex; mode=display">
Z^{(i)} = W^Tx^{(i)} + b \\
\alpha^{(i)}=\sigma (W^Tx^{(i)} + b)</script><p>单独看一个样本<script type="math/tex">(x^{(i)},y^{(i)})</script>，它的代价函数为，</p>
<script type="math/tex; mode=display">
J^{(i)} = y^{(i)}log(\alpha^{(i)})+ (1-y^{(i)})log(1 - \alpha^{(i)})</script><p>对其中一个<script type="math/tex">W_i</script>进行求导,这里先忽略上标<script type="math/tex">(i)</script>：</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial W_i}=
\frac{y}{a} \frac{\partial \alpha}{\partial W_i} -
\frac{1-y}{1-\alpha}\frac{\partial \alpha}{\partial W_i}
= ( \frac{y}{a} - \frac{1-y}{1-\alpha} )\frac{\partial \alpha}{\partial W_i}</script><p>然后其中的$\frac{\partial \alpha}{\partial W_i}$继续计算：</p>
<script type="math/tex; mode=display">
\frac{\partial \alpha}{\partial W_i}=
\frac{e^{-Z}}{(1+e^{-Z})^2} \frac{\partial Z}{\partial W_i}
= \frac {1}{1+e^{-Z}}\frac{e^{-Z} + 1 - 1}{1+e^{-Z}} \frac{\partial Z}{\partial W_i}
= \alpha(1 - \alpha)\frac{\partial Z}{\partial W_i}</script><p>继续对$\frac{\partial Z}{\partial W_i}$进行计算：</p>
<script type="math/tex; mode=display">
\frac{\partial Z}{\partial W_i} = x_i</script><p>将上面的合起来，写为：</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial W_i} =
( \frac{y}{a} - \frac{1-y}{1-\alpha} )\alpha(1 - \alpha)x_i =
(y - \alpha)x_i</script><p>注意到代价函数为：</p>
<script type="math/tex; mode=display">
J(W,b) =
- \frac{1}{m} \sum_{i=1}^m y^{(i)}log(\alpha^{(i)})
+ (1-y^{(i)})log(1 - \alpha^{(i)})</script><p>所以考虑到向量化处理，同时加上前面的因子$-\frac{1}{m}$，<strong>最终可以写为</strong>：</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac {\partial J}{\partial W} = \frac{1}{m}X(A - Y)^T \\
\frac {\partial J}{\partial b} = \frac{1}{m} \sum_{i=1}^m(\alpha^{(i)} - y^{(i)})
\end{cases}</script><p>其中，</p>
<script type="math/tex; mode=display">
A = [\alpha^{(1)},\alpha^{(2)},...,\alpha^{(m-1)},\alpha^{(m)}] \\

X = [x^{(1)},x^{(2)},...,x^{(m-1)},x^{(m)}] \\

Y = [y^{(1)},y^{(2)},...,y^{(m-1)},y^{(m)}]</script><hr>
<h2 id="参数更新"><a href="#参数更新" class="headerlink" title="参数更新"></a>参数更新</h2><p>权值的更新就按照梯度下降的原则更新就行，</p>
<script type="math/tex; mode=display">
\begin{cases}
W = W - \alpha \frac {\partial J}{\partial W} \\
b = b - \alpha \frac {\partial J}{\partial b}
\end{cases}</script><p>这里的$\alpha$代表学习因子。</p>
<hr>
<h2 id="存疑"><a href="#存疑" class="headerlink" title="存疑"></a>存疑</h2><p><strong>如果直接使用最小二乘损失函数呢？</strong></p>
]]></content>
      <categories>
        <category>coursera</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>mechine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用next主题建站全过程</title>
    <url>/2017/08/23/2017-08-23-build-hexo/</url>
    <content><![CDATA[<hr>
<h2 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h2><p>之前搭好了<code>github + jekyll</code>的个人博客，
<a href="http://longrm.com/2017/08/19/2017-08-19-build-blog-review/">搭建jekyll博客的一些回顾</a>，
写了几天，并没有什么问题，写得还挺开心的。</p>
<p>昨天发现我写在笔记里面的公式会造成本地搜索功能无法使用，整了好久也没能发现问题，
不能忍了，决定把博客搬到<code>github + hexo</code>，毕竟使用的主题<strong>next</strong>就是<strong>Hexo</strong>上搬过来的。</p>
<p><strong>jekyll</strong>的优点在于它是和github官方结合的，所以只需要按照一定的文件结构建立好仓库，
github自己会将它生成变成网站。但是<strong>Hexo</strong>是本地建立成网站，github不对它进行加工。
所以用jekyll的好处就是你直接传markdown文件就能变成博客上的一篇文章，也就是本地可以不需要任何环境，
Hexo必须在本地建立好所需的环境，每次改动都需要本地来重新生成整个网站。但就是因为<strong>jekyll</strong>的主题丑，
问题有点多，所以试一试<strong>Hexo</strong>。</p>
<p>本来以为很简单，现在我觉得建立<code>Hexo</code>比<code>jekyll</code>麻烦多了，弄了一天，总算是弄好了，
这里一定要做个总结，坑太多了。</p>
<hr>
<h2 id="window-10-github-git-node-js-Hexo-各部分的功能"><a href="#window-10-github-git-node-js-Hexo-各部分的功能" class="headerlink" title="window 10 + github + git + node.js + Hexo 各部分的功能"></a>window 10 + github + git + node.js + Hexo 各部分的功能</h2><p>首先，我在github上的用户名叫做<strong>isadamu</strong>。</p>
<p><strong>github:</strong> 托管整个博客，按照仓库<code>https://github.com/isadamu/isadamu.github.io</code>里面的文件，
在域名<code>用户名.github.io</code>下面发布到网络，
也就是可以<code>用户名.github.io</code>这个域名来访问到仓库里的网站。</p>
<p><strong>git:</strong> 用于管理仓库，随时来获取仓库里面的文件或者更新仓库里面的文件。</p>
<p><strong>node.js:</strong> Hexo运行时需要的环境，同时可以直接使用它来安装hexo。</p>
<p><strong>Hexo:</strong> 专门的一个建立博客的工具，将本地的文件转化成对应的html文件，建立起网站所需的所有文件结构，
然后结合<strong>git</strong>，将这些文件传到仓库。</p>
<hr>
<h2 id="建立github的仓库"><a href="#建立github的仓库" class="headerlink" title="建立github的仓库"></a>建立github的仓库</h2><p>首先要有一个github账号，<a href="https://github.com/">github官网</a>。</p>
<p>然后建立一个叫做<code>用户名.github.io</code>的仓库，这样的一个仓库，
github会在它上面启动<a href="https://pages.github.com/">github pages</a>的功能，
总之，有这样一个功能，我们就能在这个仓库里面建立静态网站了，
也就是可以建立自己的博客，good。</p>
<p><img src="/images/guide/build-hexo_1.png" alt="image"></p>
<p><img src="/images/guide/build-hexo_2.png" alt="image"></p>
<hr>
<h2 id="安装配置git"><a href="#安装配置git" class="headerlink" title="安装配置git"></a>安装配置git</h2><p>先下载一个git安装包，<a href="https://git-scm.com/">git</a></p>
<p>安装时就有一个安装路径选一下，别的不用管。</p>
<p>配置一下git的全局变量，不然每次要用git自带的命令行。
将安装路径里面bin文件夹的目录加到全局变量<code>D:\develop\Git\bin</code>。</p>
<p>配置好后，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br><span class="line"></span><br><span class="line">git version 2.14.1.windows.1</span><br></pre></td></tr></table></figure>
<p>出现版本信息表示配置完成，然后就要配置一下ssh key，
用来与github建立起连接，免得以后频繁输入密码。</p>
<p>先配置一下git的用户名和邮箱，改成github账号的用户名和邮箱，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;isadamu&quot;</span><br><span class="line">$ git config --global user.email &quot;myemail@qq.com&quot; </span><br></pre></td></tr></table></figure>
<p>然后输入<code>git config --list</code>可以看到配置成功，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">credential.helper&#x3D;manager</span><br><span class="line">user.name&#x3D;isadamu</span><br><span class="line">user.email&#x3D;myemail@qq.com</span><br><span class="line">push.default&#x3D;simple</span><br><span class="line">credential.helper&#x3D;wincred</span><br></pre></td></tr></table></figure>
<p>然后开始生成<strong>ssh-key</strong>，这里需要打开git-bash.exe来输入命令，
它就在git的安装目录下面，输入命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure>
<p>然后三连回车，意思就是用这个key连接时不需要密码，这时秘钥就生成在
<code>C:\Users\你的用户名\.ssh\id_rsa.pub</code>文件里面，复制文件里面的所有内容，
打开github设置，粘贴，确定。</p>
<p><img src="/images/guide/build-hexo_3.png" alt="image"></p>
<p><img src="/images/guide/build-hexo_4.png" alt="image"></p>
<p>然后输入，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>出现，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure>
<p>输入<code>yes</code>，回车后出现，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi isadamu! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>这就表示链接已经建立成功了。</p>
<hr>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>首先，<a href="https://nodejs.org/en/">下载node.js</a></p>
<p>安装同样可以选择一下安装路径，其它不用管。</p>
<p>测试是否安装成功，输入<code>node -v</code>与<code>npm -v</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br><span class="line"></span><br><span class="line">v6.11.2</span><br><span class="line"></span><br><span class="line">$ npm -v</span><br><span class="line"></span><br><span class="line">3.10.10</span><br></pre></td></tr></table></figure>
<p>出现版本号说明安装成功。</p>
<hr>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在命令行里直接输入下面命令开始安装，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<p>但是所有这类命令的通病，不换源可能很慢，在命令后面加上<a href="https://npm.taobao.org/">淘宝源</a>，
<code>--registry=https://registry.npm.taobao.org</code></p>
<p>也就是输入命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>命令运行完毕之后，输入，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo -v</span><br><span class="line"></span><br><span class="line">hexo-cli: 1.0.3</span><br><span class="line">...</span><br><span class="line">ares: 1.10.1-DEV</span><br><span class="line">...</span><br><span class="line">openssl: 1.0.2l</span><br></pre></td></tr></table></figure>
<p>出现版本号就表示<strong>Hexo</strong>安装成功。</p>
<hr>
<h2 id="初始化博客并发布"><a href="#初始化博客并发布" class="headerlink" title="初始化博客并发布"></a>初始化博客并发布</h2><p>首先，需要建立一个博客文件夹，这个文件夹以后就是博客的本地所在了。
例如选择<code>F:\nut\git\blog</code>文件夹（文件夹名字无所谓）。</p>
<p>在打开文件夹，在空白处<code>Shift + 鼠标右键</code>，打开命令行，</p>
<p><img src="/images/guide/build-hexo_5.png" alt="image"></p>
<p>输入，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>
<p>这个命令会生成一系列文件，这就是一个博客了，它使用了默认的主题<code>landscape</code>，
它在当前目录下的<code>themes</code>文件夹下面。</p>
<p><img src="/images/guide/build-hexo_6.png" alt="image"></p>
<p>接着需要输入，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>它会安装一下Hexo所需的依赖，接着输入，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<p>这个命令就是按照当前的文件，生成网站的文件结构，接着再输入，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<p>这样本地服务器就启动起来了，在浏览器输入<code>localhost:4000</code>就可以看到这个默认模板的样子了，</p>
<p><img src="/images/guide/build-hexo_7.png" alt="image"></p>
<p>这样博客就启动成功，另外也可以使用<code>hexo s --debug</code>来启动本地服务器，
这样可以在cmd显示当前的调试信息。</p>
<p>现在就差把博客传送到github上了，打开目录下面的<code>_config.yml</code>文件，在文件中找到
<code>deploy</code>字段，进行配置，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:isadamu&#x2F;isadamu.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>这样，Hexo就能够知道该把文件部署到哪里了，但是现在还少一个插件，在命令行里面输入，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>安装好这个插件之后，就可以传到github上去了，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>完成之后，可能要等几分钟，浏览器进入<code>用户名.github.io</code>，出现博客就说明成功了。</p>
<hr>
<h2 id="选择Next主题"><a href="#选择Next主题" class="headerlink" title="选择Next主题"></a>选择Next主题</h2><p>注意到<strong>Hexo</strong>现在它使用的默认主题<code>landscape</code>，那么当然可以自己选择喜欢的模板了。</p>
<p><a href="https://hexo.io/themes/">官方主题库</a></p>
<p>当然也可到处搜索一下，知乎<a href="https://www.zhihu.com/question/24422335">有哪些好看的 Hexo 主题？</a>.</p>
<p>这里选择了Next模板，毕竟就是因为它才换到<strong>Hexo</strong>上面来。</p>
<p>到<code>themes</code>文件夹下，clone主题，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next.git</span><br></pre></td></tr></table></figure>
<p>这样就将它clone了下来，注意它clone下来的文件夹名字叫做<code>hexo-theme-next</code>，
这里将它改名为<code>next</code>，因为在配置主题选择字段时，主题名字与主题的文件夹名字对应。</p>
<p><img src="/images/guide/build-hexo_8.png" alt="image"></p>
<hr>
<h2 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h2><p>直接先参考官方的说明文档，<a href="http://theme-next.iissnan.com/">NexT说明文档</a>。</p>
<p>这里首先需要注意的是<strong>配置文件</strong>有<strong>两个</strong>，一个是<strong>Hexo</strong>的配置文件，
另外一个是主题自己的配置文件，配置时一定要注意。</p>
<p><img src="/images/guide/build-hexo_9.png" alt="image"></p>
<p><img src="/images/guide/build-hexo_10.png" alt="image"></p>
<p>第二是关于<strong>标签</strong>和<strong>分类</strong>页面的添加，一定要注意参考官方说明文档所说，
例如添加<strong>标签</strong>，先在博客主目录执行，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>它会在<code>source</code>文件夹下面建立一个<code>tags</code>文件夹，里面会有一个<code>index.md</code>文件，
在这文件里面安照参考文档改就行了，不然就会出现404。</p>
<p>另外添加公益404页面需要在主题的<code>source</code>文件夹下建一个<code>404.html</code>，在里面写上</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/plain&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.qq.com/404/search_children.js&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">homePageUrl</span>=<span class="string">&quot;/&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">homePageName</span>=<span class="string">&quot;回到我的主页&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://qzone.qq.com/gy/404/data.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://qzone.qq.com/gy/404/page.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就可以了。</p>
<p>另外<code>CNAME</code>文件（绑定域名）放在主目录的<code>source</code>文件下面就行。</p>
<p>注意如果在配置文件里面配置了两个相同的字段，会报错，在配置字段时可以先用搜索，
来确定目前没有这个字段。</p>
<p>最重要的公式问题与回车换行问题，愣是整了几个小时，总结如下，</p>
<p><a href="http://longrm.com/2017/08/23/2017-08-23-hexo-mathjax/">Hexo中mathjax公式与回车换行问题</a></p>
<hr>
<h2 id="Next主题背景修改"><a href="#Next主题背景修改" class="headerlink" title="Next主题背景修改"></a>Next主题背景修改</h2><p>要修改Next的主题背景，一个是<code>next/source/css/_custom/custom.styl</code>文件，
在里面加入，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123; </span><br><span class="line">  background: #FFFFFF;</span><br><span class="line">  background-attachment: fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中background就是博客的背景字段，可以使用上面的方式使用纯色，第二个字段使得背景不随页面滑动而滑动，
背景也可以使用图片，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background:url(&#x2F;images&#x2F;backGround.jpg )</span><br></pre></td></tr></table></figure>
<p>这样就可以引入想要添加的背景图片。</p>
<p>我使用的是<code>Mist</code>，在<code>next/source/css/_schemes/Mist</code>文件夹下面，同样的方式可以修改各个地方。</p>
<p>这里还加入了动态线条，打开<code>next/layout/_layout.swig</code>文件，
在 <code>&lt; /body&gt;</code>之前添加代码，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;canvas-nest.js&#x2F;1.0.0&#x2F;canvas-nest.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>配置主题的配置文件里面的字段，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure>
<p>完成。可以参考这个文件的<a href="https://github.com/hustcc/canvas-nest.js">官方文档</a></p>
<hr>
<h2 id="部署所需注意的问题"><a href="#部署所需注意的问题" class="headerlink" title="部署所需注意的问题"></a>部署所需注意的问题</h2><p>部署之前，先停止本地的Hexo服务器。然后，先执行，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<p>先清除一下，这样免得待会上传和本地预览的不一样，然后，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line"></span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>等待部署完成就行，如果<code>hexo d</code>执行有问题，就换用git-bash来执行。</p>
<hr>
<h2 id="不同设备的更新问题"><a href="#不同设备的更新问题" class="headerlink" title="不同设备的更新问题"></a>不同设备的更新问题</h2><p>如果在另外一台设备上也要写博客，需要安装配置好<code>git + node.js + hexo</code>，配置方法和上面一样，
然后就可以同样的操作了，hexo安装好本体就行，不需要别的操作。</p>
<hr>
<h2 id="插入网易云音乐的外链到主题中"><a href="#插入网易云音乐的外链到主题中" class="headerlink" title="插入网易云音乐的外链到主题中"></a>插入网易云音乐的外链到主题中</h2><p>先上效果图，</p>
<p><img src="/images/guide/build-hexo_11.png" alt="image"></p>
<p>需要将网易云音乐的外链插入到<code>next/layout/_macro/sidebar.swig</code>里面，</p>
<p><img src="/images/guide/build-hexo_12.png" alt="image"></p>
<p>注意插入到图中的位置，也就是<strong>Blogroll</strong>下面。按道理可以将这个插入到主题的各种地方，只要看得明白主题的布局…</p>
]]></content>
      <categories>
        <category>guide</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>guide</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo中mathjax公式与回车换行问题</title>
    <url>/2017/08/23/2017-08-23-hexo-mathjax/</url>
    <content><![CDATA[<hr>
<h2 id="初始问题"><a href="#初始问题" class="headerlink" title="初始问题"></a>初始问题</h2><p>页面公式一部分能够渲染，另外一部分不能渲染，变成斜体。</p>
<p>这个问题显然是致命的，不解决基本没得救。</p>
<p>搜索了一下，发现这是因为Markdown与公式之间的不友好性，导致它会把公式中的<code>&#39;_&#39;</code>字符看出是斜体的语法，
导致公式渲染成了斜体。</p>
<p>另外这个问题与Next主题完全没有关系，就是Hexo它自己的问题。</p>
<p>Hexo默认的Markdown渲染引擎是marked，就是这个引擎的锅。</p>
<hr>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>我看到的解决方法第一个是使用<code>rawblock</code>保护代码块，我还不知道它是什么，
反正意思是我所以得文档都得改，不可能。</p>
<p>第二个方法是将引擎换成<code>pandoc</code>，它也是一个Markdown引擎，
但是试了一下不知道卡哪了，反正不成功。</p>
<p>看到的第三个解决办法是修改marked引擎的渲染规则，试了一下，照样产生混乱的公式。</p>
<p><strong>最终的解决方式</strong>，换成<code>kramed</code>引擎！！！去看看官网怎么说的<a href="https://www.npmjs.com/package/kramed">kramed</a>，
其中开头就是，</p>
<blockquote>
<p>marked hasn’t been evolving as much as it could be lately and due to our needs with GitBook,
we need features such as robust mathjax support and 
want to strive closer to the rising kramdown standard.</p>
</blockquote>
<p>它加强了对<code>mathjax</code>的支持，执行如下命令来安装它，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm uninstall hexo-renderer-marked --save</span><br><span class="line">$ npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>第一条命令卸载掉<code>marked</code>渲染引擎，第二条命令装上<code>kramed</code>渲染引擎。</p>
<p>果断的解决了问题。</p>
<hr>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>突然发现Markdown规则变成了<code>回车</code>换行，显然不能忍，这样根本没法排版，
这个问题和公式问题一样难以接受。</p>
<p>继续搜索，踩了无数坑终于明白了，对于<code>marked</code>引擎，要实现<code>空格+空格+回车</code>换行，
只要在<code>_config.yml</code>文件里面添加下面字段，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">marked:</span><br><span class="line">  gfm: true</span><br><span class="line">  breaks: false</span><br></pre></td></tr></table></figure>
<p>因为这里渲染引擎换成了<code>kramed</code>，所以上面的字段当然不管用了，但是，
只要原样修改就好，改成下面，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kramed:</span><br><span class="line">  gfm: true</span><br><span class="line">  breaks: false</span><br></pre></td></tr></table></figure>
<p>总于解决了这个让我差点弃坑的两个严重的问题，o(<em>￣▽￣</em>)o</p>
]]></content>
      <categories>
        <category>guide</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>guide</tag>
      </tags>
  </entry>
  <entry>
    <title>写博客的注意事项</title>
    <url>/2017/08/23/2017-08-23-my-write-blog-guide/</url>
    <content><![CDATA[<hr>
<h2 id="引导页面"><a href="#引导页面" class="headerlink" title="引导页面"></a>引导页面</h2><p><a href="http://theme-next.iissnan.com/">NexT主题说明</a></p>
<p><a href="http://wowubuntu.com/markdown/#code">Markdown语法</a></p>
<p><a href="http://blog.csdn.net/ethmery/article/details/50670297">MathJax基本语法</a></p>
<p><a href="http://latex.codecogs.com/eqneditor/editor.php">在线公式编辑器，快速知道语法</a></p>
<hr>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>可以使用<code>hexo new &quot;博客名&quot;</code>命令，它会在<code>source/_posts</code>文件夹下面创建了一个新的md文件，
会自带一点内容，例，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;wakaka&quot;</span><br><span class="line"></span><br><span class="line">INFO  Created: I:\nut\git\blog\source\_posts\wakaka.md</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: wakaka</span><br><span class="line">date: 2017-08-23 23:50:45</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>创建好之后，就可以接着往下写。当然可以自己在<code>source/_posts</code>文件夹下创建md文件，
这样文件名与title就可以不一样，随便写，至于时间信息，在中文输入法中拼<code>sj</code>就可以。</p>
<hr>
<h2 id="文件头部"><a href="#文件头部" class="headerlink" title="文件头部"></a>文件头部</h2><p><a href="https://hexo.io/zh-cn/docs/front-matter.html#分类和标签">官方头部说明</a></p>
<p>这篇文章的头部如下，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 写博客的注意事项</span><br><span class="line">date: 2017-08-23 23:42:49</span><br><span class="line">categories:</span><br><span class="line"> - guide</span><br><span class="line"> - hexo</span><br><span class="line">tags:</span><br><span class="line"> - guide</span><br><span class="line">description: 写一篇博客需要注意的问题，作为以后写博客的参考。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这里<code>hexo</code>这个分类，在页面上会显示为<code>guide</code>类的一个子项，</p>
<div align="center"><img src="/images/guide/write-blog_1.png"
style="zoom:60%" title="子分类" /></div>

<p>如果要写公式，因为在配置文件里面设置了<code>per_page = true</code>，
所以需要在头部加上<code>mathjax</code>标签，这样可以加快不用公式页面的渲染速度。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure></h2><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片放在<code>source/images</code>文件夹下就行，直接相对路径引用，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![image](&#x2F;images&#x2F;head&#x2F;head_bigfan.png)</span><br></pre></td></tr></table></figure>
<p><img src="/images/head/head_bigfan.png" alt="image"></p>
<p>插入图片大小的调整，并且居中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/head/head_bigfan.png&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">&quot;zoom:50%&quot;</span> <span class="attr">title</span>=<span class="string">&quot;大范&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div align="center"><img src="/images/head/head_bigfan.png"
style="zoom:50%" title="大范" /></div>

<p>也可以用，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/head/head_bigfan.png&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span> <span class="attr">title</span>=<span class="string">&quot;大范&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div align="center"><img src="/images/head/head_bigfan.png"
width="200" height="200" title="大范" /></div>

<hr>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>行内用<code>\$...\$</code>，行间用<code>\$\$...\$\$</code>，注意去掉前面的所有斜杠<code>&quot;\&quot;</code>，</p>
<p>由于公式的一些问题，一定要正确的使用格式，不然会可能会出问题。</p>
<hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>hexo会自动安装Markdown语法中标题的<code>#</code>，<code>##</code>，<code>###</code>，<code>####</code>来生成目录。</p>
<hr>
<h2 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h2><p>和引用图片一样的操作，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">![image](/images/head/wzx.gif)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/head/wzx.gif&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">&quot;zoom:150%&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div align="center"><img src="/images/head/wzx.gif"
style="zoom:150%"/></div>

<hr>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>支持的网站直接可以复制到链接，</p>
<p>例，b站视频：</p>
<p><img src="/images/guide/write-blog_2.png" alt="image"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=64658793&amp;bvid=BV144411d7S4&amp;cid=112251175&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<iframe src="//player.bilibili.com/player.html?aid=64658793&bvid=BV144411d7S4&cid=112251175&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<hr>
<h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><p>例，网易云音乐，进入网页版，获取链接：</p>
<p><img src="/images/guide/write-blog_3.png" alt="image"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginheight</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> </span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">&quot;//music.163.com/outchain/player?type=2&amp;id=33894145&amp;auto=0&amp;height=66&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意链接中有一个<code>auto</code>属性，0表示不自动播放，1表示自动播放。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1430995&auto=0&height=66"></iframe>



<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p><a href="http://longrm.com/2017/12/08/2017-12-08-html-color/">HTML颜色表</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#FF0000&#x27;</span>&gt;</span>这是红色！！！<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#FFD306&#x27;</span>&gt;</span>这是黄色！！！<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#0072E3&#x27;</span>&gt;</span>这是蓝色！！！<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span> </span><br></pre></td></tr></table></figure>
<p><font color='#FF0000'>这是红色！！！</font><br/></p>
<p><font color='#FFD306'>这是黄色！！！</font><br/></p>
<p><font color='#0072E3'>这是蓝色！！！</font><br/> </p>
]]></content>
      <categories>
        <category>guide</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>guide</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络的数据集划分、正则化、Dropout、输入标准化以及梯度检查等等</title>
    <url>/2017/08/25/2017-08-25-dnn_2/</url>
    <content><![CDATA[<hr>
<h2 id="数据集的拆分"><a href="#数据集的拆分" class="headerlink" title="数据集的拆分"></a>数据集的拆分</h2><p>在一个数据集上去应用机器学习算法时，你可能可以选择不同的算法，同样的，
相同的算法也可以有不同的参数，例如神经网络中的网络层数，神经元个数等等。
这个时候当然就得一个一个算法去试，一个一个参数去调，来选出所认为的表现最好的模型。
这时就会一个问题，如何去评判哪一个模型在这里最好？</p>
<p>通常情况（默认这里是监督学习），首先需要拿一部分数据出来训练模型，然后在训练完毕后，
让训练好的模型去预测另一部分数据，用这部分数据来评判这个模型的性能，
这样就能选出最合适的模型。</p>
<p>但是这里得到模型准确率是不能作为模型的真实准确率的，因为这里相当于用同一份数据去在一堆模型中选出最好的模型，
这样就可能是因为这个模型刚好符合这部分数据而已，所以需要用“新”的数据来测试这个模型的准确率。</p>
<p><strong>综上，数据的划分为<code>训练集 + 交叉验证集 + 测试集</code>，视频中的原英文是<code>Training Set + Development Set/Hold-out Cross Validation Set + Test Set</code>。</strong></p>
<p><strong>这三部分的划分比例一般为<code>70% + 20% + 10%</code>，但是这个比例并不是一定的，只要能实现各个部分的功能就行，例如有一百万的样本，也许一万个样本对于交叉验证集来说已经足够了。</strong></p>
<hr>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>正则化可以说是神经网络必不可少的一个部分，因为神经网络的拟合能力十分强大，所以它的<strong>过拟合</strong>能力也是十分的强大。
事实上，神经网络中很多的技巧都是为了去减少过拟合，正则化是其中最基础的一个。</p>
<script type="math/tex; mode=display">
J(w^{[1]},b^{[1]},...,w^{[L]},b^{[L]}) = \frac{1}{m} \sum_{i=1}^m L(\hat y^{(i)}, y^{(i)}) +
\frac{\lambda}{2m} \sum_{l = 1}^L ||w^{[l]}||_F^2</script><p>上面的公式就是加了正则化的代价函数，也就是多了一项权重的2-范数，这样就会将权重的取值大小考虑到代价函数里面。</p>
<p>由于优化目标是最小化代价函数，那么正则化项的存在就会迫使权重的取值变小，权重的取值不再那么自由，
它就会选择一个折中，不再过分的变化某些权重来迎合训练数据，达到减轻过拟合的目的。</p>
<p>另外这里多了一个参数$\lambda$，这个参数就控制着正则化的强度，也就多了一个训练时需要调整的超参数。</p>
<p>加上正则化项对于反向传播的求导也没有什么影响，在之间的基础上加上正则化项的导数就行，</p>
<script type="math/tex; mode=display">
dw^{[l]} = (from \ backprop) + \frac{\lambda}{m}w^{[l]}</script><p>对于偏置项$b^{[l]}$来说，可以对它正则化，也可以不正则化，不重要。这里具体的原因还不知道，感觉它取值其实是受到权重影响的，
在对权重加上偏置之后，它加不加偏置就变得不重要了。</p>
<p><strong>注：</strong>正则化又叫<code>weight decay</code>。</p>
<hr>
<h2 id="Drop-Out"><a href="#Drop-Out" class="headerlink" title="Drop Out"></a>Drop Out</h2><p>Drop-out是一个很神奇的东西，它同样可以减小神经网络过拟合，提高模型的泛化能力。</p>
<p>它的操作就是给予每个神经元一定的几率使它会被“丢弃”掉，如下图，</p>
<p><img src="/images/coursera/re-drop_1.png" alt="image"></p>
<p>图中以<code>50%</code>的几率使得一些隐藏层的神经元抑制，也就是不往后传播。</p>
<p>直观意义上来说，由于每次都会有不同的神经元被抑制，所以模型不能只依靠某些神经元，这里如果第一层也使用Drop-out，
那么就意味着输入的一些属性也会被抑制掉，
这就迫使每一个神经元都得有作用，或者不能依赖样本的某一个属性，而且它们的功能上也要有冗余。于是模型就不会过分的去拟合当前数据，
也就达到了减小过拟合的目的。（输出层当然不能加Drop-out）</p>
<p><strong>注意：</strong></p>
<p>加入Drop-out后的梯度运算就和<strong>ReLU</strong>函数类似，被抑制的神经元就不再反向传播，
所以抑制矩阵也需要在前向传播中缓存下来，因为在反向传播时将会用到它。</p>
<p>另外使得每一层的期望输出不会变小，对于没有被“drop-out”的神经元的输出，将它除以<strong>drop-out的概率</strong>，
例如作业中的代码，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D1 = np.random.rand(A1.shape[<span class="number">0</span>], A1.shape[<span class="number">1</span>])  <span class="comment"># drop-out矩阵</span></span><br><span class="line">D1 = ( D1 &lt; keep_prob )                        <span class="comment"># 变为0，1</span></span><br><span class="line">A1 = A1 * D1                                   <span class="comment"># drop-out</span></span><br><span class="line">A1 = A1 / keep_prob                            <span class="comment"># 除以概率</span></span><br></pre></td></tr></table></figure>
<p>因为这里乘上了系数$\frac{1}{keep-prob}$，那么在反向传播求导时，这个系数同样的存在，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dA1 = dA1 * D1          </span><br><span class="line">dA1 = dA1 / keep_prob</span><br></pre></td></tr></table></figure>
<p><strong>另外</strong>，在对测试样本进行分类时，关闭Drop-out，也不再乘系数$\frac{1}{keep-prob}$。</p>
<hr>
<h2 id="其它的一些防止过拟合的方式"><a href="#其它的一些防止过拟合的方式" class="headerlink" title="其它的一些防止过拟合的方式"></a>其它的一些防止过拟合的方式</h2><p><strong>Data Augmentation:</strong></p>
<p>不知道如何翻译，总之思想很简单，就是将现有的数据集中的样本进行一下处理，得到一些变化后的样本，
将这些变化后的样本也加入训练集，这样也能够提升模型的泛化性能，减轻过拟合。</p>
<p>如下图的图片分类问题，</p>
<p><img src="/images/coursera/re-drop_2.png" alt="image"></p>
<p>其中左边是原始的图片，将图片安装当前分类的性质，可以进行对称，旋转，噪声等操作，这样就能在原样本上得到新的一些样本，
并且这些样本也是在实际中真实会遇到的一些情况。</p>
<p><strong>Early Stopping</strong></p>
<p>直接看图，</p>
<p><img src="/images/coursera/re-drop_3.png" alt="image"></p>
<p>图中的蓝色线就是训练集在模型中的误差，它随着训练逐渐减小。紫色线是<code>dev set</code>在模型中的误差，它随着模型的训练也是逐渐减小，
但是当迭代到一定次数的时候，模型就开始过拟合了，于是它的误差就会逐渐增高。</p>
<p>所以<code>Early Stopping</code>的意思就是去提前结束训练，争取不让模型过拟合，所以在训练过程中可以去画这个曲线，提早停止训练。</p>
<hr>
<h2 id="输入标准化"><a href="#输入标准化" class="headerlink" title="输入标准化"></a>输入标准化</h2><p><code>Normalizing Input</code>，输入标准化是在数据预处理中非常重要的一步，由于原始数据每个属性的取值范围不一样，
如果不做处理的话，可能在进行梯度下降时会遇到一些困难，例如，</p>
<script type="math/tex; mode=display">
x_1 \in \{1-100\}</script><script type="math/tex; mode=display">
x_2 \in \{1-10000\}</script><p>这时，两个属性之间的差距就会变得很大，如下图，</p>
<p><img src="/images/coursera/re-drop_4.png" alt="image"></p>
<p>它的样本分布就与左边的图类似，比较狭长。</p>
<p>中间的图是零均值化后的分布。</p>
<p>最右边的图是再进行方差归一化的分布。</p>
<p>公式如下：</p>
<script type="math/tex; mode=display">
\mu = \frac{1}{m} \sum_{i = 1}^m x^{(i)}</script><script type="math/tex; mode=display">
\sigma ^2 = \frac{1}{m} \sum_{i = 1}^m (x^{(i)})^2</script><script type="math/tex; mode=display">
x := x - \mu</script><script type="math/tex; mode=display">
x /= \sigma ^2</script><p>这里的$x^{(i)}$就是一个样本，它是一个向量，但是这里的操作都是<strong>element-wise</strong>的。
<strong>需要注意的是，这里是先进行零均值化，然后再对零均值化后的样本进行方差归一化，所以方差里面省去了均值0。</strong></p>
<p>下面是输入标准化之前和之后的代价函数的取值空间对比：</p>
<p><img src="/images/coursera/re-drop_5.png" alt="image"></p>
<p>显然在输入标准化之后，能更好的进行优化。</p>
<p><strong>注意：</strong></p>
<p>直接对整个训练集进行标准化，所以能够得到整个训练集的均值和方差，那么在<strong>test</strong>阶段，
输入的样本同样的按照这个均值和方差去标准化就行。</p>
<hr>
<h2 id="Vanishing-exploding-gradients"><a href="#Vanishing-exploding-gradients" class="headerlink" title="Vanishing/exploding gradients"></a>Vanishing/exploding gradients</h2><p>梯度消失和梯度爆炸是深度神经网络中会遇到的问题，假设一个深度神经网络，如下图：</p>
<p><img src="/images/coursera/re-drop_6.png" alt="image"></p>
<p>假设这个网络的激活函数是一个线性激活函数，并且没有偏置，</p>
<script type="math/tex; mode=display">
z^{[l]} = w^{[l]}z{[l-1]}</script><p>那么$\hat y$就可以写为，</p>
<script type="math/tex; mode=display">
\hat y = w^{[L]}w^{[L-1]}...w^{[2]}w^{[1]}x</script><p>假设中间每一层的神经元权值都相同，</p>
<script type="math/tex; mode=display">
\hat y = w^{[L]}(w^{[1]})^{(L-1)}x</script><p>那么当$w^{[1]}$取下列值得时候</p>
<script type="math/tex; mode=display">
w^{[1]} =
\begin{bmatrix}
0.5 & 0 \\
0   & 0.5
\end{bmatrix}
\ \ \ \ or \ \ \ \
w^{[1]} =
\begin{bmatrix}
1.5 & 0 \\
0   & 1.5
\end{bmatrix}</script><p>在经历$(w^{[1]})^{(L-1)}$之后，显然值要不会非常小，要不就会非常大。
这样，要不就是数据太大，直接计算错误，要不就是数据太小，一次迭代和没有迭代一样，
这就是问题所在。</p>
<p>（所以和梯度有什么直接关系，为何要叫做梯度消失、梯度爆炸？？？）</p>
<hr>
<h2 id="权重的初始化"><a href="#权重的初始化" class="headerlink" title="权重的初始化"></a>权重的初始化</h2><p>为了减轻上面的梯度爆炸或者梯度消失的问题，在权重初始化时，可以施加一定的规则。</p>
<p>先看一个神经元中$z$的计算，</p>
<script type="math/tex; mode=display">
z = w_1x_1 + w_2x_2 + ... + w_nx_n</script><p>为了让$z$既不会太大也不会太小，那么让$w$的均值为0，方差为$\frac{1}{n}$，会有一定的帮助。</p>
<p>对于<strong>ReLU</strong>激活函数，</p>
<script type="math/tex; mode=display">
w^{[l]} = np.random.randn(shape)*np.sqrt(\frac{2}{n^{[l-1]}})</script><p>这里分子变为了2（为1叫做<code>Xavier Initialization</code>，为2时叫做<code>He Initialization</code>），暂时只知道这是一个经验值。</p>
<p>对于<strong>tanh</strong>激活函数，分子不用变成2，</p>
<script type="math/tex; mode=display">
w^{[l]} = np.random.randn(shape)*np.sqrt(\frac{1}{n^{[l-1]}})</script><p>另外这里的也可以选择为，</p>
<script type="math/tex; mode=display">
\sqrt{\frac{2}{n^{[l-1]}+ n^{[l]}}}</script><p>最后，初始化只是给了一个起始点而已，它并不是一个完美的方法。</p>
<hr>
<h2 id="梯度检查"><a href="#梯度检查" class="headerlink" title="梯度检查"></a>梯度检查</h2><p>在实现神经网络的过程中，可能不注意就写出了一个<strong>bug</strong>，有时候可能发现不了，那么这时候最好先用梯度检查来看代码是否存在问题，
当不存在问题时，再关闭梯度检查。</p>
<p>对于导数，可以利用导数的定义来进行计算，</p>
<div align="center"><img src="/images/coursera/re-drop_7.png"
style="zoom:100%" /></div>

<p>这样，取一个很小的$\epsilon$，就能使用下面公式去近似到$f(\theta)$在点$\theta$的导数。</p>
<script type="math/tex; mode=display">
{f}'(\theta) = \frac{f(\theta + \epsilon) - f(\theta - \epsilon)}{2 \epsilon}</script><p><strong>implementation:</strong></p>
<p>在实现梯度检查时，首先将所有的参数$W^{[1]},b^{[1]},…,W^{[L]},b^{[L]}$合并成一个超长的向量$\theta$，
同样的，也将反向传播得到的各个梯度$dW^{[1]},db^{[1]},…,dW^{[L]},db^{[L]}$合并成一个向量$d\theta$。</p>
<p>因为所有参数的导数都是由代价函数$J$求导得来的，那么在求他们梯度的近似的时候，当然要从代价函数入手，</p>
<script type="math/tex; mode=display">
d\theta_{approxi}^{[i]} =
\frac
{J(\theta_1,\theta_2,...,\theta_i + \epsilon,...) - J(\theta_1,\theta_2,...,\theta_i - \epsilon,...)}
{2\epsilon}</script><p>求出所有参数的近似梯度，将它们与反向传播得到的梯度相比较，</p>
<script type="math/tex; mode=display">
check \ \ \
\frac{||d\theta_{approxi} - d\theta||_2}{||d\theta_{approxi}||_2 + ||d\theta||_2}</script><p>从经验直觉上，当这个比值在$10^{-7}$往下时，就可以认为这里的梯度计算没有问题；
当在$10^{-5}$左右时，就可能会有问题了；当在$10^{-3}$往上时，几乎可以认为一定有问题。</p>
<p>注意事项：</p>
<ul>
<li>Don’t use in training - only to debug.（梯度检查是一件很费时间的事情，每改一个参数就得计算一次前向传播）</li>
<li>If algorithm fails grad check, look at components to try to identify bug.（定位问题所在）</li>
<li>Remember regularization.</li>
<li>Doesn’t work with dropout.（会变得不好计算，先关闭dropout，检查完毕再开启）</li>
<li>Run at random initialization; perhaps again after some training.</li>
</ul>
]]></content>
      <categories>
        <category>coursera</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>mechine learning</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Coursera Improving Deep Neural Networks 笔记</title>
    <url>/2017/08/25/2017-08-25-dnn/</url>
    <content><![CDATA[<p>第二个专项课程的完整题目是</p>
<blockquote>
<p>Improving Deep Neural Networks:
Hyperparameter tuning, Regularization and Optimization.</p>
</blockquote>
<p>通过标题就可以看出课程的主要内容就是在第一个课程的基础上，
对深度神经网络进行加固。</p>
<p>一共三周的课程，每周课程题目分别为：</p>
<ul>
<li>Practical aspects of Deep Learning</li>
<li>Optimization algorithms</li>
<li>Hyperparameter tuning, Batch Normalization and Programming Frameworks</li>
</ul>
<p>第一周讲了划分数据集、正则化、权值初始化以及梯度检查。</p>
<p>第二周讲了<strong>mini-batch</strong>以及<strong>RMSprop</strong>等参数更新方法。</p>
<p>第三周讲了超参数的选择、标准化以及TensorFlow。</p>
<hr>
<h2 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h2><p><a href="http://longrm.com/2017/08/25/2017-08-25-dnn_2/">神经网络的数据集划分、正则化、Dropout、输入标准化以及梯度检查</a></p>
<hr>
<h2 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h2><p><a href="http://longrm.com/2017/08/29/2017-08-29-dnn_3/">Mini-batch 和 权重更新策略</a></p>
<hr>
<h2 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h2><p><a href="http://longrm.com/2017/08/29/2017-08-29-dnn_4/">Hyperparameter tuning, Batch Norm and TensorFlow</a></p>
]]></content>
      <categories>
        <category>coursera</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>mechine learning</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Mini-batch 和 权重更新策略</title>
    <url>/2017/08/29/2017-08-29-dnn_3/</url>
    <content><![CDATA[<hr>
<h2 id="Mini-batch"><a href="#Mini-batch" class="headerlink" title="Mini-batch"></a>Mini-batch</h2><p>在训练时，对样本的输入有三种策略，</p>
<ol>
<li>一次输入一个样本，<code>Stochastic gradient descent</code>。</li>
<li>一次输入多个样本，<code>Mini-batch gradient descent</code>。</li>
<li>一次输入所有样本，<code>Batch gradient descent</code>。</li>
</ol>
<p>对于一次输入所有样本，也就是<code>Batch gradient descent</code>，那么每次梯度下降都会向着全局最优/局部最优去前进，
这样的缺点就是计算更新很慢，因为一次更新都需要计算整个训练集，在训练集非常大的时候甚至是不可能的。
另外，这样更新是很难跳出局部最优的，虽然局部最优也不差，但是总是有差的局部最优。</p>
<p>对于一次输入一个样本，也就是<code>Stochastic gradient descent</code>，那就是向另外一个极端去前进，每次梯度下降都会向着这一个样本的全局最优去前进，
虽然这样计算块，更新快，但是随机性也太大了。</p>
<p>对于一次输入多个样本，也就是<code>Mini-batch gradient descent</code>，这就是一个折中的解决方案，
每次计算不会太复杂，也能降低一点随机性。</p>
<p>在<code>Mini-batch</code>大小的选择中，一般选取2的<strong>幂次</strong>的大小，这与CPU/GPU的计算位数相关，所以一般情况，
选取<strong>64、128、256、512</strong>。</p>
<hr>
<h2 id="权重更新"><a href="#权重更新" class="headerlink" title="权重更新"></a>权重更新</h2><p>在梯度下降的基础上，对更新策略更新一下改动，不再是单纯的减去梯度，而是用带有平均的一种思想去更新。</p>
<p><strong>Exponentially weighted averages:</strong></p>
<p>如下图是一个气温随日期变换的坐标图，其中蓝色的点就是某一天的气温，这里总共有一年的数据，</p>
<p><img src="/images/coursera/mini-advance_1.png" alt="image"></p>
<p>其中红色和绿色的线是根据下面的公式画出来的，</p>
<script type="math/tex; mode=display">
v_t = \beta v_{t-1} + (1 - \beta)\theta_t</script><p>其中$\theta_t$表示的就是第$t$天的气温，当$\beta = 0.9$时，画出的就是红色的线，
当$\beta = 0.98$时，画出的就是绿色的线。上面的式子就相当于是在给气温做平均。</p>
<p>大概平均的天数为：</p>
<script type="math/tex; mode=display">
days \approx \frac{1}{1 - \beta}</script><p>于是红色的线大概是10天的平均，绿色的线大概是50天的平均，所以绿色的线看起来会有一点偏右。</p>
<p>计算时，就一步一步运算就行了，</p>
<script type="math/tex; mode=display">
v_\theta = 0</script><script type="math/tex; mode=display">
v_\theta := \beta v + (1 - \beta)\theta_1</script><script type="math/tex; mode=display">
v_\theta := \beta v + (1 - \beta)\theta_2</script><script type="math/tex; mode=display">
...</script><p>但是，在实际操作中，按照上面的式子得到的绿色的线其实应该在紫色的线的位置上，这是因为初始值为0的原因，</p>
<p><img src="/images/coursera/mini-advance_2.png" alt="image"></p>
<p>所以，这里需要加入<code>Bias correction</code>，</p>
<script type="math/tex; mode=display">
v_t = \frac{v_t}{1 - \beta^t}</script><p>这里的$\beta^t$是$\beta$的$t$次幂，刚开始的时候分子会很小，然后逐渐变大，事实上，第一轮迭代，$v_1$就等于$\theta_1$。
这样，就能矫正这个初始值太低的问题。</p>
<p><strong>Momentum:</strong></p>
<p>属于权重更新的初级魔法：</p>
<script type="math/tex; mode=display">
V_{dw} = \beta V_{dw} + (1 - \beta)dw</script><script type="math/tex; mode=display">
V_{db} = \beta V_{db} + (1 - \beta)db</script><script type="math/tex; mode=display">
w := w - \alpha V_{dw}</script><script type="math/tex; mode=display">
b := b - \alpha V_{db}</script><p>通常取$\beta = 0.9$，而且这里不需要矫正。也可以去掉$(1 - \beta)$，变为，</p>
<script type="math/tex; mode=display">
V_{dw} = \beta V_{dw} + dw</script><script type="math/tex; mode=display">
V_{db} = \beta V_{db} + db</script><p>这样相当于参数调整基本交给$\alpha$来做。</p>
<p><strong>RMSprop:</strong></p>
<p>属于权重更新的中级魔法：</p>
<script type="math/tex; mode=display">
S_{dw} = \beta S_{dw} + (1 - \beta)dw^2</script><script type="math/tex; mode=display">
S_{db} = \beta S_{db} + (1 - \beta)db^2</script><script type="math/tex; mode=display">
w := w - \alpha \frac{dw}{\sqrt{S_{dw}}}</script><script type="math/tex; mode=display">
b := b - \alpha \frac{db}{\sqrt{S_{db}}}</script><p>这里的$dw^2$就是$dw$的平方，当然也是<strong>element-wise</strong>的。这里的$\beta$通常取0.999，而且也不用矫正。</p>
<p>为了防止出现分母为0的错误，通常要在分母上加上一个很小的数$\epsilon$，</p>
<script type="math/tex; mode=display">
w := w - \alpha \frac{dw}{\sqrt{S_{dw}} + \epsilon}</script><script type="math/tex; mode=display">
b := b - \alpha \frac{db}{\sqrt{S_{db}} + \epsilon}</script><p><strong>Adam:</strong></p>
<p>属于权重更新的高级魔法，它将<strong>Momentum</strong>与<strong>RMSprop</strong>相结合：</p>
<script type="math/tex; mode=display">
Init:V_{dw} = 0, S_{dw} = 0, V_{db} = 0, S_{db} = 0</script><script type="math/tex; mode=display">
V_{dw} = \beta_1 V_{dw} + (1 - \beta_1) dw</script><script type="math/tex; mode=display">
V_{db} = \beta_1 V_{db} + (1 - \beta_1) db</script><script type="math/tex; mode=display">
S_{dw} = \beta_2 S_{dw} + (1 - \beta_2) dw^2</script><script type="math/tex; mode=display">
S_{db} = \beta_2 S_{db} + (1 - \beta_2) db^2</script><p>显然这里的$V_{dw}$属于<strong>Momentum</strong>，</p>
<p>这里的$S_{dw}$属于<strong>RMSprop</strong>，</p>
<p>另外这里还要用到矫正：</p>
<script type="math/tex; mode=display">
V_{dw}^{corrected} = \frac{V_{dw}}{(1 - \beta_1^t)}</script><script type="math/tex; mode=display">
V_{db}^{corrected} = \frac{V_{db}}{(1 - \beta_1^t)}</script><script type="math/tex; mode=display">
S_{dw}^{corrected} = \frac{S_{dw}}{(1 - \beta_2^t)}</script><script type="math/tex; mode=display">
S_{db}^{corrected} = \frac{S_{db}}{(1 - \beta_2^t)}</script><p>将它们结合起来，权重的更新策略就如下：</p>
<script type="math/tex; mode=display">
w := w - \alpha \frac{V_{dw}^{corrected}}{\sqrt{S_{dw}^{corrected}} + \epsilon}</script><script type="math/tex; mode=display">
b := b - \alpha \frac{V_{db}^{corrected}}{\sqrt{S_{db}^{corrected}} + \epsilon}</script><p>通常将参数设置为$\beta_1 = 0.9,\beta_2 = 0.999,\epsilon = 10^{-8}$，一般情况不需要去调整它们的取值，默认的就足够了。</p>
<p>（它名字的全称其实是<code>Adaptive moment estimation</code>，所以其实和<code>Adam</code>没有半毛钱关系…）</p>
<hr>
<h2 id="Learning-rate-decay"><a href="#Learning-rate-decay" class="headerlink" title="Learning rate decay"></a>Learning rate decay</h2><p>在权值更新的过程中逐渐减小学习速率，能够使模型收敛到更好的解，</p>
<p><img src="/images/coursera/mini-advance_3.png" alt="image"></p>
<p>其中蓝色的线是没有减小学习速率的，它最后会在最优解附近一个较宽的范围徘徊，
另外绿色的线就是逐渐减小学习速率的，它会收敛到一个较窄的范围。</p>
<p>需要<strong>注意</strong>的是，这里逐渐减小学习速率的<strong>单位</strong>是<code>epoch</code>，一个<code>epoch</code>就是过一遍数据。</p>
<p><img src="/images/coursera/mini-advance_6.png" alt="image" title="epoch"></p>
<p>首选的策略是：</p>
<script type="math/tex; mode=display">
\alpha = \frac{1}{1 + decayRate * epochNum} \alpha_0</script><p>其它的一些策略：</p>
<script type="math/tex; mode=display">
\alpha = 0.95^{epochNum} \alpha_0</script><script type="math/tex; mode=display">
\alpha = \frac{k}{\sqrt{epochNum}} \alpha_0</script><p>或者，</p>
<script type="math/tex; mode=display">
\alpha = \frac{k}{\sqrt{t}} \alpha_0</script><p>这里的$t$就是总的迭代次数了，上面的$k$是一个固定的常量。</p>
<p>以上的这些decay的方法其实都可以，选一个用就好。</p>
<hr>
<h2 id="关于局部最优"><a href="#关于局部最优" class="headerlink" title="关于局部最优"></a>关于局部最优</h2><p>通常对于局部最优的印象是这样的，</p>
<p><img src="/images/coursera/mini-advance_4.png" alt="image"></p>
<p>就会觉得很容易陷入局部最优，但是实际上在高维空间中，这样的直觉是不准确的，
它更像是下面的马鞍面，</p>
<p><img src="/images/coursera/mini-advance_5.png" alt="image"></p>
<p>那么在遇到一个梯度为0的点的时候，实际上更可能是马鞍面中间的那个点，
模型因为各种措施，它也并不会卡在这个点上。</p>
<p>因为这样的原因，神经网络几乎不可能卡在一个很差的局部最优点上，通常都能收敛到一个较好的局部最优点，距离全局最优也差不了多远。</p>
]]></content>
      <categories>
        <category>coursera</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>mechine learning</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Hyperparameter tuning, Batch Norm and TensorFlow</title>
    <url>/2017/08/29/2017-08-29-dnn_4/</url>
    <content><![CDATA[<hr>
<h2 id="Hyperparameter-tuning"><a href="#Hyperparameter-tuning" class="headerlink" title="Hyperparameter tuning"></a>Hyperparameter tuning</h2><p>调参是训练神经网络中十分重要的一项技能，很有可能为了训练出一个好的模型，一大半的时间需要花费在调参上面。</p>
<p>首先调参时要分清楚哪些是重要参数，也就是对结果影响较大的参数，着重去调整它们，例如下列的参数：</p>
<ul>
<li>$\alpha$</li>
<li>$\lambda$</li>
<li>$\beta_1,\beta_2,\epsilon$</li>
<li>$layers$</li>
<li>$hidden \ units$</li>
<li>$learning \ rate \ decay$</li>
<li>$mini \ batch \ size$</li>
</ul>
<p>显然，其中比较重要的参数是$\alpha,\lambda,layers,learning \ rate \ decay$，所以在调参的时候着重去调整它们，
剩下的参数随意一点，可调可不调，看着具体的问题来选择。</p>
<p>通常会认为调参是下面这种形式：</p>
<p><img src="/images/coursera/HBT_1.png" alt="image"></p>
<p>这种形式就是先选好固定的距离，然后进行搜索，这样并没有太大问题，但就上图来说，如果参数一重要，参数二不重要，
这样就会浪费一些搜索机会，比如先固定了参数一，参数二变化五次，这五次模型的性能并不会有什么变化。</p>
<p>所以，可以进行随机选点：</p>
<p><img src="/images/coursera/HBT_2.png" alt="image"></p>
<p>这样就不会太浪费选点的机会。</p>
<p>另外可以第一轮先在一个较大的范围去选点，然后再缩小到一个小一点的范围进行更加精确的搜索。</p>
<p><strong>随机选点：</strong></p>
<p>随机选点可不是<code>random</code>就可以了，有时还需要考虑一下尺度问题，</p>
<p>首先，假如是一个<code>50 ~ 100</code>范围内的随机，那么随机选就可以了，没什么问题，</p>
<p><img src="/images/coursera/HBT_3.png" alt="image"></p>
<p>但是如果是一个<code>0.0001 ~ 1</code>的范围，那么随机就会显得很蠢，</p>
<p><img src="/images/coursera/HBT_4.png" alt="image"></p>
<p>那么90%的概率点会选在<code>0.1 ~ 1</code>的区间里面，显然不行。如下图所示，才是这里的”均匀”。</p>
<p><img src="/images/coursera/HBT_5.png" alt="image"></p>
<p>为了产生这种效果，就把它变成一个对数坐标，在<strong>python</strong>中就像下面这样来写就行了，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = -<span class="number">4</span> * np.random.rand() <span class="comment"># -4 ~ 0</span></span><br><span class="line">a = <span class="number">10</span>**r                 <span class="comment"># 10^-4 ~ 10^0</span></span><br></pre></td></tr></table></figure>
<p>相当于变成对数坐标，在对数坐标上面进行随机，然后再返回来。</p>
<p>如果是一个<code>0.9 ~ 0.999</code>的范围，先按上面的方式随机一个<code>0.1 ~ 0.001</code>的范围，再用<strong>1</strong>来<strong>减</strong>就行了。</p>
<p>另外例如范围<code>0.9000 ~ 0.9005</code>与<code>0.999 ~ 0.9995</code>，看起来它们之间没有什么不同，但是实际上，后一个范围它很接近<strong>1</strong>，
这个变化在机器学习中是会有<strong>质变</strong>的，所以第二个范围在进行搜索时，需要更加的细致。</p>
<p>另外视频中还给提供了在模型训练时间很长的时候（几天以上），两种调参方式的有趣的名字：</p>
<ul>
<li><strong>Pandas：</strong>一次一胎，也就是同时只训练一个模型，然后你看着代价变化曲线，每天调一调参。（计算资源较少）</li>
<li><strong>Caviar：</strong>一次n胎，同时训练n个模型，几天后选择其中那个最好的。（计算资源很多）</li>
</ul>
<hr>
<h2 id="Batch-Norm"><a href="#Batch-Norm" class="headerlink" title="Batch Norm"></a>Batch Norm</h2><p>就像前面将输入进行标准化一样，可以在神经网络中任意一层去应用类似的标准化方法，这样的标准化对于<strong>梯度爆炸和梯度消失</strong>问题的缓解都很有好处。</p>
<p>如下图，</p>
<p><img src="/images/coursera/HBT_6.png" alt="image"></p>
<p><code>Batch norm</code>一般是在$z^{[i]}$上进行，也就是在激活函数之前进行，</p>
<script type="math/tex; mode=display">
\mu^{[l]} = \frac{1}{n^{[l]}} \sum_{i = 1}^{n^{[l]}} z^{[l]}_i</script><script type="math/tex; mode=display">
(\sigma^{[l]})^2 = \frac{1}{n^{[l]}} \sum_{i = 1}^{n^{[l]}} (z^{[l]}_i - \mu^{[l]})^2</script><script type="math/tex; mode=display">
z^{[l]}_{norm} = \frac{z^{[l]} - \mu^{[l]}}{\sqrt{(\sigma^{[l]})^2 + \epsilon}}</script><script type="math/tex; mode=display">
\tilde{z}^{[l]}_{norm} = \delta z^{[l]}_{norm} + \beta</script><p>这里的$\epsilon$就是防止出现除以零的错误，另外，这里不直接使用标准化后的$z^{[l]}_{norm}$，
而是加入了两个参数$\delta,\beta$，这两个参数不是定死的，它是随着更新而更新的，加这两个参数的原因，
是为了让模型可以在标准化的基础上进行一下小变动，甚至可以返回标准化之前的数值，例如，</p>
<script type="math/tex; mode=display">
\delta = \sqrt{(\sigma^{[l]})^2 + \epsilon}</script><script type="math/tex; mode=display">
\beta = \mu</script><p>那么带进去计算就会发现，数值又返回原始的状态了。</p>
<p>在这里，使用了<code>Batch norm</code>的层就多了两个参数$\delta,\beta$，在反向传播时，同样要去计算这两个参数的梯度，然后更新。
同样的也可以使用<strong>Adam</strong>方法来更新这两个参数。</p>
<p>另外需要注意的是，</p>
<script type="math/tex; mode=display">
z^{[l]} = w^{[l]}a^{[l-1]} + b^{[l]}</script><p>那么在对$z^{[l]}$进行<code>batch norm</code>的时候，$b^{[l]}$就会显得很多余，因为它会被零均值化掉，
所以在施加了<code>batch norm</code>的神经层中，就不再需要$b^{[l]}$这个参数。</p>
<p><strong>为什么<code>Batch norm</code>会起到作用？</strong></p>
<p>吴恩达在这里给了一些直觉来使得它<code>make sense</code>，例如下面训练一个简单的神经元，</p>
<p><img src="/images/coursera/HBT_7.png" alt="image"></p>
<p>训练的数据如下图左边，测试时变为了下图右边，</p>
<p><img src="/images/coursera/HBT_8.png" alt="image"></p>
<p>显然由于数据的分布发生了变化，模型的准确率就会下降，不可能指望左边真的能够学习到那条绿色的判决线。</p>
<p>同样的道理，在多层的神经网络中，可以认为某一层的输入就有一个疯狂变化的分布，</p>
<p><img src="/images/coursera/HBT_9.png" alt="image"></p>
<p>那么，这时受到分布变化的影响，这一层就很难去学习到一个比较好的参数。当加上<code>Batch norm</code>时，
就能<strong>限制</strong>一下这个分布的变化，<strong>减轻</strong>影响。</p>
<p><strong>测试样本怎么办？</strong></p>
<p>当训练时，使用的都是<strong>mini-batch</strong>，自然可以计算出它们的均值、方差，但是如果在测试时，一次只有一个样本通过，
那么怎么<code>Batch norm</code>呢？</p>
<p>通常情况下，追踪训练中的每一个<strong>mini-batch</strong>在该层上得到的均值与方差，使用<code>exponentially weighted</code>的方法来估计它们的均值，</p>
<script type="math/tex; mode=display">
\mu_{all}^{[l]} = \beta \mu_{all}^{[l]} + (1 - \beta) \mu^{\{i\}[l]}</script><p>这里的$i$代表第$i$个<code>mini-batch</code>。</p>
<p>注意这样求出来的总的均值、方差只是在<strong>test</strong>阶段使用，并不用在训练过程中。</p>
<p><strong>梯度怎么求？</strong></p>
<p>这个现在先避开，感觉上就不好算，按吴恩达的说法，通常不会去手写这个的，让学习框架来就好。</p>
<hr>
<h2 id="Softmax-Regression"><a href="#Softmax-Regression" class="headerlink" title="Softmax Regression"></a>Softmax Regression</h2><p><a href="http://longrm.com/2017/08/30/2017-08-30-softmax/">Softmax Regression 总结</a></p>
<hr>
<h2 id="深度学习框架"><a href="#深度学习框架" class="headerlink" title="深度学习框架"></a>深度学习框架</h2><p>不知道视频是什么时间做的，总之上面列出了很多深度学习的框架，但就现在这个时间点来说，<strong>TensorFlow</strong>肯定是主流的，
当然，课程里面用的也是<strong>TensorFlow</strong>。</p>
<p>当神经网络的结构变得复杂的时候，手写代码就真的会比较辛苦，还容易出现<strong>bug</strong>，这个时候，就需要框架来帮忙了。</p>
<p><a href="http://longrm.com/2017/09/02/2017-09-02-tensorflow/">TensorFlow笔记一</a></p>
]]></content>
      <categories>
        <category>coursera</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>mechine learning</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Softmax Regression 总结</title>
    <url>/2017/08/30/2017-08-30-softmax/</url>
    <content><![CDATA[<hr>
<h2 id="Softmax-Regression"><a href="#Softmax-Regression" class="headerlink" title="Softmax Regression"></a>Softmax Regression</h2><p>使用神经网络进行多分类任务时，通常在最后一层会使用一个<code>softmax</code>层，个人感觉它与<strong>sigmoid</strong>函数类似，都是将结果转变成一个类似概率的东西，
这样会更加有利于计算当前损失，提升模型学习的效果。</p>
<p>首先对于一个输入$a^{[L-1]}$，先线性运算，</p>
<script type="math/tex; mode=display">
z^{[L]} = w^{[L]}a^{[L-1]} + b^{[L]}</script><p>前面的操作每一层都一样，但是激活函数就不一样了，</p>
<script type="math/tex; mode=display">
t = e^{(z^{[L]})}</script><script type="math/tex; mode=display">
a^{[L]} = \frac{e^{(z^{[L]})}}{\sum_{i=1}^{n^{[L]}} t_i}</script><p>首先将输出转成$t$，这样能够保证所有数值不为负，然而以它们在总和中所占的比例，作为它们当前的概率，
也就是$a^{[L]_i}$就是分类为第$i$个分类的概率。</p>
<p>举例，对于一个$z^{[L]}$取值如下，</p>
<script type="math/tex; mode=display">
z^{[L]} =
\begin{bmatrix}
5 \\
2 \\
-1 \\
3
\end{bmatrix}</script><p>求$t$为，</p>
<script type="math/tex; mode=display">
t =
\begin{bmatrix}
e^5 \\
e^2 \\
e^{-1} \\
e^3
\end{bmatrix}</script><p>那么$a^{[L]}$为，</p>
<script type="math/tex; mode=display">
a^{[L]} = \frac{t}{\sum_{i=1}^{n^{[L]}} t_i} =
\begin{bmatrix}
e^5 / (e^5 + e^2 + e^{-1} + e^3) \\
e^2 / (e^5 + e^2 + e^{-1} + e^3) \\
e^{-1} / (e^5 + e^2 + e^{-1} + e^3) \\
e^3 / (e^5 + e^2 + e^{-1} + e^3)
\end{bmatrix}
=
\begin{bmatrix}
0.842 \\
0.042 \\
0.002 \\
0.114
\end{bmatrix}</script><p>这里的到的$a^{[L]}$就可以看作一个概率值。</p>
<hr>
<h2 id="Loss-function："><a href="#Loss-function：" class="headerlink" title="Loss_function："></a>Loss_function：</h2><p>由于<code>softmax</code>可以看成是<code>Logistic Regression</code>的推广，那么这里对损失函数的计算也对照<code>Logistic Regression</code>来推。</p>
<p><code>Logistic Regression</code>的代价函数，这里把上面的$a^{[L]}$写为$\hat y$：</p>
<script type="math/tex; mode=display">
J(W,b) = \frac{1}{m} \sum_{i=1}^m L(\hat y^{(i)},y^{(i)} )
= - \frac{1}{m} \sum_{i=1}^m y^{(i)}log \ \hat y^{(i)}
+ (1-y^{(i)})log(1 - \hat y^{(i)})</script><p>首先，考虑单个样本，那么在<code>Logistic Regression</code>中单个样本的概率函数就是，</p>
<script type="math/tex; mode=display">
P(y) = (\hat y)^y (1 - \hat y)^{1-y}</script><p>同样的，在<code>softmax</code>中单个样本的概率函数以同样的形式可以写为，</p>
<script type="math/tex; mode=display">
P(y) = \prod_{i = 1}^{n^{[L]}} (\hat y_i)^{y_i}</script><p>进行对数似然，</p>
<script type="math/tex; mode=display">
L(P(y)) = \sum_{i = 1}^{n^{[L]}} y_i log(\hat y_i)</script><p>改为最小化似然函数，加上一个负号，</p>
<script type="math/tex; mode=display">
L(P(y)) = -\sum_{i = 1}^{n^{[L]}} y_i log(\hat y_i)</script><p>那么现在就可以考虑<strong>多样本</strong>输入的情况，直接在前面加上一个求和就行，</p>
<script type="math/tex; mode=display">
L(P(y)) = -\sum_{i = 1}^{m}\sum_{j = 1}^{n^{[L]}} y_j^{(i)} log(\hat y_j^{(i)})</script><hr>
<h2 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h2><p>代价函数就是上面的负对数似然，同样先考虑单样本，</p>
<script type="math/tex; mode=display">
J(w,b) = -\sum_{j = 1}^{n^{[L]}} y_j log(\hat y_j)</script><p>将$\hat y_j$换一下，忽略上标，</p>
<script type="math/tex; mode=display">
J(w,b) = -\sum_{j = 1}^{n} y_j log(\frac{e^{z_j}}{\sum_{i=1}^{n} e^{z_i}})</script><script type="math/tex; mode=display">
= -\sum_{j = 1}^{n} y_j (log(e^{z_j}) - log(\sum_{i=1}^{n} e^{z_i}))</script><script type="math/tex; mode=display">
= -\sum_{j = 1}^{n} y_j log(e^{z_j}) + \sum_{j = 1}^{n} y_j log(\sum_{i=1}^{n} e^{z_i})</script><script type="math/tex; mode=display">
= -\sum_{j = 1}^{n} y_j z_j + log(\sum_{j=1}^{n} e^{z_j})</script><p>先求一个$z_i$的导数，</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial z_i} =
- y_i + \frac{e^{z_i}}{\sum_{j=1}^{n} e^{z_j}} =
\hat y_i - y_i</script><p>所以，对于一个样本的导数就可以写为，</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial z} =
\hat y - y</script><p>当然，多个样本的形式也和上面一模一样，所以反向传播时，其实计算是十分简单的。</p>
<p><strong>注:</strong></p>
<p>在cs231n课程里面，提到这里还有一个地方需要注意，因为中间会去求<strong>e</strong>的幂次，
这很容易会造成<strong>上溢</strong>，所以通常对这个地方要做一个额外的处理，</p>
<script type="math/tex; mode=display">
\frac{e^z}{\sum_{j=1}^{n} e^{z_j}} =
\frac{Ce^z}{C\sum_{j=1}^{n} e^{z_j}} =
\frac{e^{z+logC}}{\sum_{j=1}^n e^{z_j + logC}}</script><p>这里的$C$，一般取值为，</p>
<script type="math/tex; mode=display">
logC = -\max_j z_j</script><p><strong>那么为什么要叫做<code>softmax</code>呢？</strong></p>
<p>它其实对应的是<code>hard max</code>，<code>hard max</code>的操作就是直接将$z^{[L]}$按照取值大小，
直接硬转为0、1，所以这里取了一个<code>soft</code>…</p>
<script type="math/tex; mode=display">
z^{[L]} =
\begin{bmatrix}
5 \\
2 \\
-1 \\
3
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
1 \\
0 \\
0 \\
0
\end{bmatrix}</script>]]></content>
      <categories>
        <category>coursera</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>mechine learning</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 5 Longest Palindromic Substring</title>
    <url>/2017/09/01/2017-09-01-longest-palindromic-substring/</url>
    <content><![CDATA[<hr>
<p>Description:</p>
<blockquote>
<p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>
</blockquote>
<p>Example:</p>
<blockquote>
<p>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.</p>
</blockquote>
<hr>
<p>想法，最简单的，就是以每个字母为中心，向两边扩散，这样的复杂度就是O(n^2)。</p>
<p>那么下面就是第一份代码，就是简单的向两边扩充。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">char</span>[] s_split = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> p, q;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s_split.length ; i++) &#123;</span><br><span class="line">            p = i - <span class="number">1</span>;</span><br><span class="line">            q = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ( p &gt;= <span class="number">0</span> &amp;&amp; q &lt; s_split.length ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( s_split[p] == (s_split[q]) ) &#123;</span><br><span class="line">                    p--;</span><br><span class="line">                    q++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( ( q - p - <span class="number">1</span> ) &gt; ( index2 - index1 + <span class="number">1</span> ) ) &#123;</span><br><span class="line">                index1 = p + <span class="number">1</span>;</span><br><span class="line">                index2 = q - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> ( i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s_split[i] == s_split[i-<span class="number">1</span>] ) &#123;</span><br><span class="line">                p = i - <span class="number">2</span>;</span><br><span class="line">                q = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> ( p &gt;= <span class="number">0</span> &amp;&amp; q &lt; s_split.length ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( s_split[p] == s_split[q] ) &#123;</span><br><span class="line">                        p--;</span><br><span class="line">                        q++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( ( q - p - <span class="number">1</span> ) &gt; ( index2 - index1 + <span class="number">1</span> ) ) &#123;</span><br><span class="line">                index1 = p + <span class="number">1</span>;</span><br><span class="line">                index2 = q - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ( <span class="keyword">new</span> String(s_split, index1, index2 - index1 + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/leetcode/5_1.png" alt="image"></p>
<p>击败38.60%，从图上就可以看出来，很垃圾。</p>
<hr>
<p>时隔不知道多少个月，重新回来发现这么垃圾，索性修改了一下，现在的想法就比较复杂了。</p>
<p>首先，对于一个回文串，它的构成是例如<code>abcdcba</code>的形式，当去掉两边的<code>a</code>时，它依旧是一个回文串<code>bcdcb</code>。</p>
<p>那么如果想要降低复杂度，那么循环到一个字符时，一定要用到之前的信息，这样就能降低复杂度。</p>
<p>通过这种信息论的想法，加上上面回文串的特点，下面是新的算法思路：</p>
<ul>
<li>循环一遍字符串。</li>
<li>以前一个字符所在的回文串，看<strong>以当前字符串为右边界</strong>能否去扩张这些字符串。</li>
<li>查看当前字符与前两个字符能否组成回文串，查看能否与前一个字符组成回文串。</li>
<li>保存下当前字符所在的回文串。</li>
<li>当前回文串的长度是否超过之前保存的最长，是则保存。</li>
</ul>
<p>例如字符串<code>sabckcbaga</code>，假如现在循环到了后一个<code>b</code>，也就是现在前面的字符串是<code>sabckcb</code>，那么前一个字符就是<code>c</code>，
它所在的一个回文串就是<code>ckc</code>，那么现在就尝试用<code>b</code>去扩充它，发现<code>bckcb</code>，可以扩充，所以最长支付串保存为<code>bckcb</code>，
当前所在回文串保存<code>bckcb</code>。再查看<code>kcb</code>是否回文串，不是，查看<code>cb</code>是否回文串，也不是。
那么当前回文串就是<code>bckcb</code>。</p>
<p>循环到下一个字符是<code>a</code>，尝试用<code>a</code>扩充<code>bckcb</code>，扩充成功，当前字符串保存<code>abckcba</code>，最长长度更新，
查看<code>cba</code>不是回文串，查看<code>ba</code>不是回文串。当前回文串<code>abckcba</code>。</p>
<p>再循环到<code>g</code>，尝试扩充<code>abckcba</code>失败，<code>bag</code>、<code>ag</code>也不是回文串，当前回文串没有。</p>
<p>循环到<code>a</code>，上一个回文串没有，查看<code>aga</code>是回文串，<code>ga</code>不是回文串。当前回文串<code>aga</code>。</p>
<p><strong>再例如</strong>字符串<code>abababa</code>。</p>
<p>循环到第二个<code>b</code>，它不能扩充前一个回文串<code>aba</code>，<code>bab</code>是回文串，<code>ab</code>不是。当前回文串<code>bab</code>。</p>
<p>循环到<code>a</code>，它能扩充<code>bab</code>，为<code>ababa</code>，同时<code>aba</code>也是回文串，<code>ba</code>不是。当前回文串<code>ababa</code>、<code>aba</code>。</p>
<p>循环到<code>b</code>，它不能扩充<code>ababa</code>，它能扩充<code>aba</code>为<code>babab</code>，同时<code>bab</code>是回文串，<code>ab</code>不是。当前回文串<code>babab</code>、<code>bab</code>。</p>
<p>…</p>
<p><strong>代码里面还考虑了重复</strong>，例如<code>aaaaaa</code>，按照上面的操作到第5个<code>a</code>时，它的当前回文串会有<code>aaaaa</code>、<code>aaaa</code>、<code>aaa</code>、<code>aa</code>，这样很不好，
实时上，这里只需要<code>aaaaa</code>，在存一个是否连续的标志位。</p>
<p>例如循环到最后一个<code>a</code>，它上一个回文串为<code>aaaaa</code>，同时连续标志位为<strong>true</strong>，首先它不能扩充<code>aaaaa</code>，当连续标志位为<strong>true</strong>时，
看它能否右扩充<code>aaaaa</code>，也就是<code>aaaaa</code> + <code>a</code>是否为为回文串，这里显然<code>aaaaaa</code>是回文串。同时由于连续标志位为<strong>true</strong>，这里不再需要查看<code>aaa</code>和<code>aa</code>是否为回文串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max_len = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> p_idx = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> t_idx = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLen</span><span class="params">( <span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> len )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( max_len &lt; len ) &#123;</span><br><span class="line">            max_len = len;</span><br><span class="line">            begin = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( i - <span class="number">1</span> &gt;= <span class="number">0</span> )</span><br><span class="line">            a[t_idx++] = i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> succ_idx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[ss.length];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ss.length; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p_idx ; j++ )</span><br><span class="line">                <span class="keyword">if</span> ( ss[p[j]] == ss[i] ) </span><br><span class="line">                    addLen(p, p[j], i - p[j] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ( succ_idx != -<span class="number">1</span> ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( ss[succ_idx] == ss[i] )</span><br><span class="line">                    addLen(p, succ_idx, i - succ_idx + <span class="number">1</span> );</span><br><span class="line">                <span class="keyword">else</span> succ_idx = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( i - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; ss[i - <span class="number">2</span>] == ss[i] )</span><br><span class="line">                    addLen(p, i - <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span> ( i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ss[i - <span class="number">1</span>] == ss[i] ) &#123;</span><br><span class="line">                    succ_idx = i - <span class="number">1</span>;</span><br><span class="line">                    addLen(p, i - <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p_idx = t_idx;</span><br><span class="line">            t_idx = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ( <span class="keyword">new</span> String(ss, begin, max_len));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>期望复杂度O(n)？反正最差复杂度O(n^2)。</p>
<p><img src="/images/leetcode/5_2.png" alt="image"></p>
<p>击败84.26%，我觉得还行。我甚至觉得如果用例再多一些，可以击败更多的人！！！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow 笔记一</title>
    <url>/2017/09/02/2017-09-02-tensorflow/</url>
    <content><![CDATA[<p>一个十分简单的TensorFlow笔记。</p>
<hr>
<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>python里面直接按照module来导入就行，</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></table></figure></h2><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.constant(<span class="number">1</span>, name=<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.constant(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>它也可以是矩阵，</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = tf.constant(np.random.randn(<span class="number">3</span>,<span class="number">1</span>), name = <span class="string">&quot;X&quot;</span>)</span><br></pre></td></tr></table></figure></h2><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>例如，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_hat = tf.constant(<span class="number">36</span>, name=<span class="string">&#x27;y_hat&#x27;</span>)</span><br><span class="line">y = tf.constant(<span class="number">39</span>, name=<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">loss = tf.Variable((y - y_hat)**<span class="number">2</span>, name=<span class="string">&#x27;loss&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到变量是由一些常量进行一些运算后得到的。</p>
<p>当然直接写也是可以的，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss = (y - y_hat)**<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>TensorFlow对基本运算进行了重写，它会自动识别出这里的运算步骤的。</p>
<hr>
<h2 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init = tf.global_variables_initializer()</span><br></pre></td></tr></table></figure>
<p>还不明白它的作用。</p>
<hr>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = tf.placeholder(tf.int64, name = <span class="string">&#x27;x&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>占位符可以看成一个变量，它可以重复的赋值，赋值时要使用<code>feed_dict&#123;&#125;</code>，</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sess.run(<span class="number">2</span> * x, feed_dict = &#123;x: <span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure></h2><h2 id="会话（session）"><a href="#会话（session）" class="headerlink" title="会话（session）"></a>会话（session）</h2><p>TensorFlow的运行需要建立一个会话任务，然后通过它来运行，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">    session.run(init)</span><br><span class="line">    print(session.run(loss))</span><br></pre></td></tr></table></figure>
<p>要通过<code>session</code>才能将计算<code>run()</code>起来，这里也可以使用下面的方式，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line">print(sess.run(loss))</span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure>
<p>目前看来，上面结构的好处就是可以自动进行<code>close()</code>。</p>
<hr>
<h2 id="十分简单的程序"><a href="#十分简单的程序" class="headerlink" title="十分简单的程序"></a>十分简单的程序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf   <span class="comment"># 导包</span></span><br><span class="line"></span><br><span class="line">a = tf.constant(<span class="number">2</span>, name=<span class="string">&#x27;a&#x27;</span>)  <span class="comment"># 常量</span></span><br><span class="line"></span><br><span class="line">b = tf.constant(<span class="number">3</span>, name=<span class="string">&#x27;b&#x27;</span>)  <span class="comment"># 常量</span></span><br><span class="line"></span><br><span class="line">c = a * b + b                 <span class="comment"># 变量</span></span><br><span class="line"></span><br><span class="line">d = tf.placeholder(tf.int32, name = <span class="string">&#x27;d&#x27;</span>) <span class="comment"># 占位符</span></span><br><span class="line"></span><br><span class="line">f = d + c                                <span class="comment"># 变量</span></span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer() <span class="comment"># 初始化器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:                    <span class="comment"># 建立会话</span></span><br><span class="line">    session.run(init)                            <span class="comment"># 执行初始化</span></span><br><span class="line">    print(session.run(f, feed_dict = &#123;d: <span class="number">100</span>&#125;))  <span class="comment"># 运行变量f</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>109</p>
</blockquote>
<p>甚至怀疑应该把<code>variable</code>看成为一个运算式子，所以才会去<code>run()</code>这么一个式子。</p>
]]></content>
      <categories>
        <category>coursera</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>mechine learning</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 10 Regular Expression Matching</title>
    <url>/2017/09/05/2017-09-05-leetcode_10/</url>
    <content><![CDATA[<p>Description:</p>
<blockquote>
<p>‘.’ Matches any single character.<br>‘*‘ Matches zero or more of the preceding element.  </p>
<p>The matching should cover the entire input string (not partial).  </p>
<p>The function prototype should be:<br>bool isMatch(const char *s, const char *p)  </p>
<p>Some examples:<br>isMatch(“aa”,”a”) → false<br>isMatch(“aa”,”aa”) → true<br>isMatch(“aaa”,”aa”) → false<br>isMatch(“aa”, “a*“) → true<br>isMatch(“aa”, “.*“) → true<br>isMatch(“ab”, “.*“) → true<br>isMatch(“aab”, “c*a*b”) → true  </p>
</blockquote>
<hr>
<p><strong>题目理解：</strong>给两个字符串，用第二个字符串去匹配第一个字符串，意思就是第一个字符串中的字符不转义，
只有第二个字符串才需要转义。</p>
<p>需要注意的是，一个字符后面如果跟上<code>*</code>，那么这个字符一定要转义，也就是例如<code>a*</code>与<code>a*</code>不能匹配，因为第一个<code>a*</code>不转义，
第二个<code>a*</code>转义，所以第一个<code>a*</code>中的<code>*</code>将匹配不上。</p>
<p><strong>思路：</strong>几个月之前，显然不知道动态规划，就直接递归，非常二。当然也能击败一半人…</p>
<p>刚看了动态规划，这个问题典型的动态规划问题，使用自顶向下的策略，速度得到提升。</p>
<hr>
<p><strong>代码一：直接递归版本</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s_array = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] p_array = p.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> si = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (  pi &lt; p_array.length ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( pi + <span class="number">1</span> != p_array.length &amp;&amp; p_array[ pi + <span class="number">1</span> ] == <span class="string">&#x27;*&#x27;</span> ) &#123;</span><br><span class="line">                <span class="keyword">int</span> si_back = s_array.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> pi_back = p_array.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> ( pi_back &gt; pi + <span class="number">1</span> &amp;&amp; si_back &gt;= si ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( p_array[pi_back] == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> ( p_array[pi_back] != s_array[si_back] &amp;&amp; p_array[pi_back] != <span class="string">&#x27;.&#x27;</span> ) </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    pi_back--;</span><br><span class="line">                    si_back--;</span><br><span class="line">                &#125;</span><br><span class="line">                pi_back++;</span><br><span class="line">                si_back++;</span><br><span class="line">                String p_sub = p.substring( pi + <span class="number">2</span> , pi_back );</span><br><span class="line">                <span class="keyword">if</span> ( p_array[pi] == <span class="string">&#x27;.&#x27;</span> ) &#123;</span><br><span class="line">                    <span class="keyword">while</span> ( si &lt;= si_back ) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( isMatch( s.substring( si , si_back ) , p_sub ) )</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        si++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> ( si &lt; si_back &amp;&amp; s_array[si] == p_array[pi] ) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( isMatch( s.substring( si , si_back ) , p_sub ) )</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        si++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> isMatch( s.substring( si , si_back ) , p_sub );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( p_array[pi] == <span class="string">&#x27;.&#x27;</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( si == s_array.length ) </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    pi++;</span><br><span class="line">                    si++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( si == s_array.length || s_array[si] != p_array[pi] ) </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    pi++;</span><br><span class="line">                    si++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> si == s_array.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：指数级别。<br>运行时间：33ms。<br>击败：44.25%。</p>
<p><img src="/images/leetcode/10_1.png" alt="image"></p>
<hr>
<p><strong>代码二：动态规划（自顶向下）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] pp = p.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[][] matchs = <span class="keyword">new</span> <span class="keyword">char</span>[ss.length + <span class="number">1</span>][pp.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ss.length; i++ )</span><br><span class="line">            matchs[i][pp.length] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        matchs[ss.length][pp.length] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> myMatch( matchs, ss, pp, <span class="number">0</span>, <span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">myMatch</span><span class="params">( <span class="keyword">char</span>[][] matchs, <span class="keyword">char</span>[] s, <span class="keyword">char</span>[] p, <span class="keyword">int</span> si, <span class="keyword">int</span> pi )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( matchs[si][pi] == <span class="string">&#x27;1&#x27;</span> || matchs[si][pi] == <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">            <span class="keyword">return</span> matchs[si][pi];</span><br><span class="line">        <span class="keyword">if</span> ( pi + <span class="number">1</span> &lt; p.length &amp;&amp; p[pi + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> ) &#123;</span><br><span class="line">            matchs[si][pi] = myMatch( matchs, s, p, si, pi + <span class="number">2</span> );</span><br><span class="line">            <span class="keyword">if</span> ( matchs[si][pi] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> matchs[si][pi];</span><br><span class="line">            <span class="keyword">if</span> ( p[pi] == <span class="string">&#x27;.&#x27;</span> ) &#123;</span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">int</span> i = si + <span class="number">1</span>; i &lt;= s.length; i++ ) &#123;</span><br><span class="line">                    matchs[si][pi] = myMatch( matchs, s, p, i, pi + <span class="number">2</span> );</span><br><span class="line">                    <span class="keyword">if</span> ( matchs[si][pi] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">                        <span class="keyword">return</span> matchs[si][pi];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = si;</span><br><span class="line">                <span class="keyword">while</span> ( i &lt; s.length &amp;&amp; s[i] == p[pi] ) &#123;</span><br><span class="line">                    matchs[si][pi] = myMatch( matchs, s, p, i + <span class="number">1</span>, pi + <span class="number">2</span> );</span><br><span class="line">                    <span class="keyword">if</span> ( matchs[si][pi] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">                        <span class="keyword">return</span> matchs[si][pi];</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( p[pi] == <span class="string">&#x27;.&#x27;</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( si == s.length )</span><br><span class="line">                matchs[si][pi] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                matchs[si][pi] = myMatch( matchs, s, p, si + <span class="number">1</span>, pi + <span class="number">1</span> );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ( si == s.length || s[si] != p[pi] )</span><br><span class="line">                matchs[si][pi] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                matchs[si][pi] = myMatch( matchs, s, p, si + <span class="number">1</span>, pi + <span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matchs[si][pi];</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：O(n^2)???<br>运行时间：25ms。<br>击败：99.48%</p>
<p><img src="/images/leetcode/10_2.png" alt="image"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction to ML Strategy</title>
    <url>/2017/09/06/2017-09-06-coursera-ml-strategy/</url>
    <content><![CDATA[<h2 id="Deep-Learning第三个子课程《Introduction-to-ML-Strategy》笔记。"><a href="#Deep-Learning第三个子课程《Introduction-to-ML-Strategy》笔记。" class="headerlink" title="Deep_Learning第三个子课程《Introduction to ML Strategy》笔记。"></a>Deep_Learning第三个子课程《Introduction to ML Strategy》笔记。</h2><p>这一子课程一共分了2周的课程，没有讲实质的算法，讲的是在实际中如果去解决一个机器学习问题，
或者说是在实现算法过程中，该如何一步一步去提升算法，它又应该基于一个怎么样的策略。</p>
<p>实话说，这一部分听着比较无聊，一是因为自己没有这样的一个经历，不能感同身受，二是这一部分主要是一个<code>intuition</code>上的东西，
比较的玄，三是这一部分确实有一点无聊。</p>
<p>由于以上原因，这一部分笔记先简单记一下，待到之后或许会重新来看一遍视频。</p>
<h2 id="正交化"><a href="#正交化" class="headerlink" title="正交化"></a>正交化</h2><p>意思是参数的正交化，也就是尽量使得要调整的参数正交化，这样参数调整起来才不会互相影响。（暂时并不能太理解具体的操作）</p>
<h2 id="模型的目标"><a href="#模型的目标" class="headerlink" title="模型的目标"></a>模型的目标</h2><p>对于整个机器学习系统来说，提高算法精度是肯定的，但是还可能需要考虑到很多其它的问题，例如计算速度、内存占用、假真率啊等等。</p>
<p>有的目标是越小/大越好，有的是只要满足就行，这就叫做<code>Optimizing metric and Satisficing</code>。</p>
<p>另外要注意到<code>train set</code>与<code>dev set</code>以及<code>test set</code>它们之间的分布关系，如果分布区别很大，或者说训练的目标就不是我们本来的目标的话（不同的分布导致不同的目标），
显然算法的表现将不会很好。</p>
<h2 id="Avoidable-bias-and-variance"><a href="#Avoidable-bias-and-variance" class="headerlink" title="Avoidable bias and variance"></a>Avoidable bias and variance</h2><p>首先对于一个机器学习问题，它存在着一个精度的上限，叫做<code>Bayes Error</code>，它从数学上证明了这个问题它的一个精度上限，没有任何算法或者人能超过它。</p>
<p>第二在这么一个问题上，可能有一个人类的精度上限<code>human-level performance</code>，代表着直接让人来做的误差。</p>
<p>然后在<code>train set</code>上的误差就是<code>training error</code>，<code>dev set</code>上的误差就把它叫做<code>dev error</code>。</p>
<p><strong>那么</strong>，对于<code>Bayes Error</code>，没法直接知道，所以通常使用<code>human-level performance</code>来表示我们算法想要达到的一个精度目标，
所以<code>training error</code>与<code>human-level performance</code>之间的差值就叫做<code>avoidable bias</code>，也就是算法还差多少拟合能力。
<code>training error</code>与<code>dev set</code>之间的差值就叫做<code>variance</code>，表示模型的泛化能力。</p>
<p>这两个精度差就可以指示我们，当前的模型问题出在哪个地方。</p>
<h2 id="后一周"><a href="#后一周" class="headerlink" title="后一周"></a>后一周</h2><p>不好总结，需要时可以再去看一遍…</p>
]]></content>
      <categories>
        <category>coursera</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>mechine learning</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 44 Wildcard Matching</title>
    <url>/2017/09/06/2017-09-06-leetcode_44/</url>
    <content><![CDATA[<blockquote>
<p>Implement wildcard pattern matching with support for ‘?’ and ‘*‘.  </p>
<p>‘?’ Matches any single character.<br>‘*‘ Matches any sequence of characters (including the empty sequence).  </p>
<p>The matching should cover the entire input string (not partial).  </p>
<p>The function prototype should be:<br>bool isMatch(const char *s, const char *p)  </p>
<p>Some examples:<br>isMatch(“aa”,”a”) → false<br>isMatch(“aa”,”aa”) → true<br>isMatch(“aaa”,”aa”) → false<br>isMatch(“aa”, “*“) → true<br>isMatch(“aa”, “a*“) → true<br>isMatch(“ab”, “?*“) → true<br>isMatch(“aab”, “c*a*b”) → false  </p>
</blockquote>
<p>题目理解：</p>
<p>经典的字符串匹配问题。</p>
<p>首先想到的方法，顺着走，但是第一次写得非常复杂，这里忽略不计（但是速度还可以）。</p>
<p>今天所想的方法，动态规划，自顶向下，或者自底向上。</p>
<p>看了别人的顺着走的算法，原来思路也是很简单的。</p>
<p><strong>所以不是看到这种问题就想着动态规划，也许顺着想就能简单解决。</strong></p>
<p><strong>另外，这道题的java运行时间十分不稳定，重复提交可以差30ms。</strong></p>
<hr>
<p>代码一：</p>
<p>自顶向下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray(), pp = p.toCharArray();</span><br><span class="line">        <span class="comment">// 为了先合并连续的&#x27;*&#x27;</span></span><br><span class="line">        <span class="keyword">char</span>[] ppp = <span class="keyword">new</span> <span class="keyword">char</span>[pp.length];</span><br><span class="line">        <span class="keyword">int</span> ppp_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> last_not_star = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pp.length; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( pp[i] == <span class="string">&#x27;*&#x27;</span> ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( last_not_star )</span><br><span class="line">                    ppp[ppp_idx++] = pp[i];</span><br><span class="line">                last_not_star = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last_not_star = <span class="keyword">true</span>;</span><br><span class="line">                ppp[ppp_idx++] = pp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] pppp = <span class="keyword">new</span> <span class="keyword">char</span>[ppp_idx];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ppp_idx; i++ )</span><br><span class="line">            pppp[i] = ppp[i];</span><br><span class="line">        pp = pppp;</span><br><span class="line">        <span class="keyword">char</span>[][] matchs = <span class="keyword">new</span> <span class="keyword">char</span>[ss.length + <span class="number">1</span>][pp.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ss.length; i++ )</span><br><span class="line">            matchs[i][pp.length] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        matchs[ss.length][pp.length] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> myMatch( ss, pp, <span class="number">0</span>, <span class="number">0</span>, matchs) == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">myMatch</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">char</span>[] b, <span class="keyword">int</span> ai, <span class="keyword">int</span> bi, <span class="keyword">char</span>[][] matchs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( matchs[ai][bi] != <span class="string">&#x27;\0&#x27;</span> ) </span><br><span class="line">            <span class="keyword">return</span> matchs[ai][bi];</span><br><span class="line">        <span class="keyword">if</span> ( ai == a.length ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( b[bi] == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">                matchs[ai][bi] = myMatch(a, b, ai, bi + <span class="number">1</span>, matchs);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                matchs[ai][bi] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> matchs[ai][bi];</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> ( b[bi] == <span class="string">&#x27;?&#x27;</span> ) &#123;</span><br><span class="line">            matchs[ai][bi] = myMatch(a, b, ai + <span class="number">1</span>, bi + <span class="number">1</span>, matchs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( b[bi] == <span class="string">&#x27;*&#x27;</span> ) &#123;</span><br><span class="line">            matchs[ai][bi] = myMatch(a, b, ai, bi + <span class="number">1</span>, matchs);</span><br><span class="line">            <span class="keyword">if</span> ( matchs[ai][bi] != <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">                matchs[ai][bi] = myMatch(a, b, ai + <span class="number">1</span>, bi, matchs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ( a[ai] == b[bi] )</span><br><span class="line">                matchs[ai][bi] = myMatch(a, b, ai + <span class="number">1</span>, bi + <span class="number">1</span>, matchs);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                matchs[ai][bi] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matchs[ai][bi];</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：O(mn)？？？<br>运行时间：大约100ms。<br>击败：大约16.73%</p>
<p><img src="/images/leetcode/44_1.png" alt="image"></p>
<hr>
<p>代码二：</p>
<p>自底向上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray(), pp = p.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> m = ss.length, n = pp.length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] matchs = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++ )</span><br><span class="line">            matchs[i][<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; pp[i] == <span class="string">&#x27;*&#x27;</span>; i++ )</span><br><span class="line">            matchs[<span class="number">0</span>][i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        matchs[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++ ) &#123;</span><br><span class="line">                <span class="keyword">int</span> ii = i - <span class="number">1</span>, jj = j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ( pp[jj] == <span class="string">&#x27;?&#x27;</span> )</span><br><span class="line">                    matchs[i][j] = matchs[ii][jj];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( pp[jj] == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">                    matchs[i][j] = matchs[ii][j] || matchs[i][jj];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( matchs[ii][jj] ) </span><br><span class="line">                        matchs[i][j] = (ss[ii] == pp[jj]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matchs[m][n];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：O(mn)。<br>运行时间：大约75ms。<br>击败：大约50%</p>
<p><img src="/images/leetcode/44_2.png" alt="image"></p>
<hr>
<p>代码三：</p>
<p>顺序扫描。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray(), pp = p.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> m = ss.length, n = pp.length, i = <span class="number">0</span>, j = <span class="number">0</span>, star_idx = -<span class="number">1</span>, match = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i &lt; m ) &#123;</span><br><span class="line">            <span class="keyword">if</span>  ( j &lt; n &amp;&amp; pp[j] == <span class="string">&#x27;*&#x27;</span> ) &#123;</span><br><span class="line">                match = i;</span><br><span class="line">                star_idx = j;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( j &lt; n &amp;&amp; ( pp[j] == <span class="string">&#x27;?&#x27;</span> || pp[j] == ss[i] ) ) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( star_idx != -<span class="number">1</span> ) &#123;</span><br><span class="line">                i = match++;</span><br><span class="line">                j = star_idx + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( j &lt; n &amp;&amp; pp[j] == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">return</span> j == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：应该介于O(mn)到O(m + n)之间。<br>运行时间： 大约60ms。<br>击败：大约80%</p>
<p><img src="/images/leetcode/44_3.png" alt="image"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 72 Edit Distance</title>
    <url>/2017/09/06/2017-09-06-leetcode_72/</url>
    <content><![CDATA[<p>Description:</p>
<blockquote>
<p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)  </p>
<p>You have the following 3 operations permitted on a word:<br>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
</blockquote>
<p>题目理解，就是求将第一个字符串转化到第二个字符串所需要的最少步数，可以使用插入、删除、替换，三种策略。</p>
<p>这其实就是算法导论第15章，动态规划的思考题15-5，但是这道题会更加简单，
因为书上还有旋转操作。反正就是说这道题如果不使用动态规划，那么一定是过不了的。</p>
<p>思路一：先写一个递归算法，将它转化为自顶向上的动态规划。</p>
<p>思路二：自底向上。</p>
<hr>
<p>代码一：</p>
<p>先考虑递归的情况，也就是取两个字符串的头字符$a_0$和$b_0$比较，然后按照：</p>
<ul>
<li>$a_0$和$b_0$匹配，向下递归$a_1$和$b_1$。</li>
<li>$a_0$和$b_0$不匹配，<ul>
<li>使用<code>replace</code>，也就是将$a_0$替换为$b_0$，向下递归$a_1$和$b_1$。</li>
<li>使用<code>Insert</code>，也就是在$a_0$前面插入$b_0$，向下递归$a_0$和$b_1$。</li>
<li>使用<code>Delete</code>，也就是删除$a_0$，向下递归$a_1$和$b_0$。</li>
</ul>
</li>
</ul>
<p>上面的递归就可以求出少的操作次数，但是这样的递归将是<strong>指数复杂度</strong>的，所以更改其变为动态规划，减少子问题的重复计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] a = word1.toCharArray(), b = word2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> m = a.length, n = b.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dis = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">            Arrays.fill(dis[i], -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++ )</span><br><span class="line">            dis[i][n] = m - i;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++ )</span><br><span class="line">            dis[m][j] = n - j;</span><br><span class="line">        <span class="keyword">return</span> myDis( a, b, <span class="number">0</span>, <span class="number">0</span>, dis );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">myDis</span><span class="params">( <span class="keyword">char</span>[] a, <span class="keyword">char</span>[] b, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] dis )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( dis[i][j] != -<span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> dis[i][j];</span><br><span class="line">        <span class="keyword">if</span> ( a[i] == b[j] ) &#123;</span><br><span class="line">            dis[i][j] = myDis( a, b, i + <span class="number">1</span>, j + <span class="number">1</span>, dis );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> dis1 = myDis( a, b, i, j + <span class="number">1</span>, dis );</span><br><span class="line">            <span class="keyword">int</span> dis2 = myDis( a, b, i + <span class="number">1</span>, j, dis );</span><br><span class="line">            <span class="keyword">int</span> dis3 = myDis( a, b, i + <span class="number">1</span>, j + <span class="number">1</span>, dis );</span><br><span class="line">            <span class="keyword">int</span> min = dis1 &lt; dis2 ? dis1 : dis2;</span><br><span class="line">            min = min &lt; dis3 ? min : dis3;</span><br><span class="line">            dis[i][j] = min + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度O(mn)。<br>运行时间8ms。<br>击败97.43%</p>
<p><img src="/images/leetcode/72_1.png" alt="image"></p>
<hr>
<p>代码二：</p>
<p>自底向上。</p>
<p>对照P223，定理15的定义法，先清晰一下思路。</p>
<p>令$a=(a_1,a_2,…,a_m)$和$b=(b_1,b_2,…,b_n)$两个序列，将第一个序列转化到第二个，那么：</p>
<ul>
<li>如果$a_m == b_n$，则次数等于$(a(m-1),b(n-1))$。</li>
<li>如果$a_m \neq b_n$，则次数等于$(a(m-1),b(n-1))$与$(a(m),b(n-1))$与$(a(m-1),b(n))$的最小值加一。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] a = word1.toCharArray(), b = word2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> m = a.length, n = b.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dis = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++ )</span><br><span class="line">            dis[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++ )</span><br><span class="line">            dis[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>] ) &#123;</span><br><span class="line">                    dis[i][j] = dis[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( dis[i-<span class="number">1</span>][j] &gt; dis[i][j-<span class="number">1</span>] ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( dis[i][j-<span class="number">1</span>] &gt; dis[i-<span class="number">1</span>][j-<span class="number">1</span>] )</span><br><span class="line">                        dis[i][j] = dis[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dis[i][j] = dis[i][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( dis[i-<span class="number">1</span>][j] &gt; dis[i-<span class="number">1</span>][j-<span class="number">1</span>] )</span><br><span class="line">                        dis[i][j] = dis[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dis[i][j] = dis[i-<span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[m][n];</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度O(mn)。<br>运行时间10ms。<br>击败92.12%</p>
<p><img src="/images/leetcode/72_2.png" alt="image"></p>
<p><strong>注：</strong></p>
<p><strong>自顶向上比自底向上快？？？想了一下，应该是因为在自顶向下的过程中，并不需要去将所有的子问题都计算出来。</strong></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>Using Python to Access Web Data 笔记</title>
    <url>/2017/09/08/2017-09-08-using-python-to-access-web-data/</url>
    <content><![CDATA[<p><strong>前两个子课程的笔记就不记了，因为非常的基础。</strong></p>
<hr>
<h2 id="Regular-Expressions"><a href="#Regular-Expressions" class="headerlink" title="Regular Expressions"></a>Regular Expressions</h2><p>正则表达式之前就没好好学，这里正好可以学一下。</p>
<p>首先<strong>python</strong>中的正则表达式和<strong>java</strong>中基本一致，也可以说所有编程语言中的正则表达式其实都是差不多的，还可以说正则表达式是一个独立的特征，这些语言都要支持这个特征。所有学习的是哪一门语言的正则表达式并不关键。</p>
<p>首先，官方文档<a href="https://docs.python.org/3/howto/regex.html">Regular Expression HOWTO</a>。</p>
<p>课程资料中所列：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>character</th>
<th>mean</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>Matches the beginning of a line</td>
</tr>
<tr>
<td>$</td>
<td>Matches the end of the line</td>
</tr>
<tr>
<td>.</td>
<td>Matches any character</td>
</tr>
<tr>
<td>\s</td>
<td>Matches whitespace</td>
</tr>
<tr>
<td>\S</td>
<td>Matches any non-whitespace character</td>
</tr>
<tr>
<td>*</td>
<td>Repeats a character zero or more times</td>
</tr>
<tr>
<td><code>*?</code></td>
<td>Repeats a character zero or more times (non-greedy)</td>
</tr>
<tr>
<td>+</td>
<td>Repeats a character one or more times</td>
</tr>
<tr>
<td>+?</td>
<td>Repeats a character one or more times (non-greedy)</td>
</tr>
<tr>
<td>[aeiou]</td>
<td>Matches a single character in the listed set</td>
</tr>
<tr>
<td><sup><a href="#fn_XYZ" id="reffn_XYZ">XYZ</a></sup></td>
<td>Matches a single character not in the listed set</td>
</tr>
<tr>
<td>[a-z0-9]</td>
<td>The set of characters can include a range</td>
</tr>
<tr>
<td>(</td>
<td>Indicates where string extraction is to start</td>
</tr>
<tr>
<td>)</td>
<td>Indicates where string extraction is to end</td>
</tr>
</tbody>
</table>
</div>
<p>使用正则表达式需要导包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure>
<p>函数以及语法直接看官方文档吧,<a href="https://docs.python.org/3/library/re.html#module-re">Regular expression operations</a></p>
<p>直接上题：</p>
<p><strong>题目：extract all the numbers in the file and compute the sum of the numbers</strong></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>) <span class="comment"># 测试文件</span></span><br><span class="line">one_line = file.read()  <span class="comment"># 把文件读成一行</span></span><br><span class="line">nums = re.findall(<span class="string">&#x27;[^0-9]*([0-9]+)[^0-9]*&#x27;</span>, one_line) <span class="comment"># 取出所有整数</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">len</span>(nums))</span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    total += <span class="built_in">int</span>(num)</span><br><span class="line">    print(<span class="string">&#x27;$&#x27;</span>,num)</span><br><span class="line"></span><br><span class="line">print(total)</span><br></pre></td></tr></table></figure>
<p>这里的正则表达式为<code>[^0-9]*([0-9]+)[^0-9]*</code>，也就是中间数字，前后存在除了数字之外的任意字符。</p>
<p>虽然上面的逻辑十分简单并且正确，但是最开始我并不是这样写的，我最开始想的是<code>[^0-9]([0-9]+)[^0-9]</code>，
数字前后一定存在一个非数字字符，<strong>but对于例子：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Why should you learn to write programs? 7746</span><br><span class="line">12 1929 8827</span><br><span class="line">Writing programs (or programming) is a very creative</span><br><span class="line">7 and rewarding activity.  You can write programs for</span><br><span class="line">many reasons, ranging from making your living to solving</span><br><span class="line">8837 a difficult data analysis problem to having fun to helping 128</span><br><span class="line">someone else solve a problem.  This book assumes that</span><br><span class="line">everyone needs to know how to program ...</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<blockquote>
<p>5<br>$ 7746<br>$ 1929<br>$ 7<br>$ 8837<br>$ 128<br>18647  </p>
</blockquote>
<p>正常输出应该为：</p>
<blockquote>
<p>7<br>$ 7746<br>$ 12<br>$ 1929<br>$ 8827<br>$ 7<br>$ 8837<br>$ 128<br>27486  </p>
</blockquote>
<p>那么这里就少了12以及8827。难道这里是因为在匹配7746的时候，匹配的是<code>7746\n</code>，所以到了匹配12的时候，前面的<code>\n</code>被匹配了，所以它不能再使用。同样的，匹配1929时，它匹配的是<code>1929</code>，导致后面8827前面没有字符能够匹配了？</p>
<p>可能在<code>findall()</code>的时候就是使用的字符不再使用吧…</p>
<p>未完待续…</p>
<hr>
<h2 id="Networks-and-Sockets"><a href="#Networks-and-Sockets" class="headerlink" title="Networks and Sockets"></a>Networks and Sockets</h2><p>感觉我自己是个假的学网络的，对于网络的了解还是太窄太片面了，<strong>以后恶补一下。</strong></p>
<p>在python里面使用<strong>socket</strong>十分的简单，</p>
<p>下面的代码就能访问课程提供的一个网页，并且将这个html文件给打印出来，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">mysock.connect((<span class="string">&#x27;data.pr4e.org&#x27;</span>, <span class="number">80</span>))</span><br><span class="line">cmd = <span class="string">&#x27;GET http://data.pr4e.org/intro-short.txt HTTP/1.0\r\n\r\n&#x27;</span>.encode()</span><br><span class="line">mysock.send(cmd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = mysock.recv(<span class="number">512</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(data) &lt; <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(data.decode())</span><br><span class="line"></span><br><span class="line">mysock.close()</span><br></pre></td></tr></table></figure>
<p>这里直接使用域名就能进行连接（之前学习socket都是用的ip，毕竟局域网，然而现在学的都<strong>退回</strong>去了），
80端口就是web端口，然后可以直接加上文件来进行访问，这后面的<code>HTTP/1.0\r\n\r\n</code>现在还不能明白。
<code>encode()</code>和<code>decode()</code>到底进行了什么操作也还不能明白。</p>
<p>另外注意这里的域名协议是<code>http</code>，它和<code>https</code>好像是有一些区别的。</p>
<hr>
<h2 id="Programs-that-Surf-the-Web"><a href="#Programs-that-Surf-the-Web" class="headerlink" title="Programs that Surf the Web"></a>Programs that Surf the Web</h2><p>这一节主要讲了一下python与网络中的一些编码。</p>
<p>首先解释了为什么在上面的socket中，要在发出request之前进行<code>encode()</code>，在接收信息后要先进行<code>decode()</code>。
<strong>第一</strong>，现在网络编码绝大多数都是<code>UTF-8</code>，甚至可以默认一定是它，毕竟<code>UTF-8</code>包含了所有的常用语言文字。
<strong>第二</strong>，在python内部，所有的字符都是<code>unicode</code>编码，那么问题就来了，<code>unicode</code>与<code>UTF-8</code>并不能直接通用，所有在字符出入的时候就要加上<code>encode()</code>与<code>decode()</code>。</p>
<p>关于<code>UTF-8</code>与<code>unicode</code>。
首先快速参考一下知乎<a href="https://www.zhihu.com/question/23374078">Unicode 和 UTF-8 有何区别?</a></p>
<p><strong>首先</strong>，<code>unicode</code>是为了解决之前编码只考虑英文字符的问题而出现的，因为以前的<code>ascii</code>码只使用一个字节来表示字符，所以它最多也只能表示<strong>256</strong>个字符，
如果只使用英文是够用的，但是事实是世界要发展，所以出现各种字符，那么它就不够用了。于是就出现了许多的编码方式，例如中国就出了<code>GBK</code>编码。
但是这是不适于国家与国家之间的交流的，于是<code>ISO</code>就指定了<code>unicode</code>这个编码标准。</p>
<p><code>unicode</code>现在通常是使用两个字节来表示一个字符，但是其实它可以被看成一个字符集，它将所有字符都定义了一个唯一的<strong>ID</strong>，这样网络就能有一个统一的字符表，不再出现之前的需要相互转化的问题。</p>
<p>那么新的问题就是直接使用<code>unicode</code>来表示字符时，它有时候会浪费空间，在编码表中靠前的字符，例如英文字符，它前一字节就是<code>0000</code>，后一字节才是它真正的序号。
<strong>于是</strong>，在网络传输中，由于网络带宽并没有这么的理想，大家肯定就会嫌弃<code>unicode</code>编码浪费带宽，所以，于1992年创建，由<strong>Ken Thompson</strong>创建了<code>UTF</code>传输标准，它的全名是<code>Unicode Transformation Format</code>，这个全名就能明白了<code>UTF</code>的意思。</p>
<p><code>UTF</code>是针对<code>unicode</code>的一种网络传输标准，按照我们通信的人来说，它就是一种针对<code>unicode</code>的编码方式。
它现在有<code>UTF-7</code>、<code>UTF-7.5</code>、<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>几种格式，当然现在最为流行的就是其中的<code>UTF-8</code>。
它是一种变长的编码方式，这样就能减少网络传输中的数据量，所以在网络传输中，大家都用它。</p>
<p><strong>下面直接看作业代码：</strong></p>
<p>作业的目标是将一个网页中的<code>span</code>标签中的整数进行求和，当然可以使用<code>socket</code>读取到网页，然后再使用<code>正则表达式</code>来去到整数。</p>
<p>但是这个作业规定使用<code>BeautifulSoup</code>来进行这个过程，它能够直接把网页给解析了，不过这个不是<code>BeautifulSoup</code>的功能，
在python中原有就有支持这个功能的函数，<code>BeautifulSoup</code>主要是将网页中一些不规范的表达的地方的雷点给你踩了。也就是它总结了网页中很多不规范的<code>奇葩写法</code>，然后过滤这些，使得<code>Soup</code>更加好喝。</p>
<p>另外<code>BeautifulSoup</code>是一个额外的模块，可以使用<code>pip install BeautifulSoup</code>来安装。</p>
<p><strong>注：</strong> 主要是<code>html</code>语言太强了，很多奇葩的写法，它也不报错…</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ignore SSL certificate errors</span></span><br><span class="line">ctx = ssl.create_default_context()</span><br><span class="line">ctx.check_hostname = <span class="literal">False</span></span><br><span class="line">ctx.verify_mode = ssl.CERT_NONE</span><br><span class="line"></span><br><span class="line">url = <span class="built_in">input</span>(<span class="string">&#x27;Enter - &#x27;</span>)</span><br><span class="line">html = urlopen(url, context=ctx).read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># html.parser is the HTML parser included in the standard Python 3 library.</span></span><br><span class="line"><span class="comment"># information on other HTML parsers is here:</span></span><br><span class="line"><span class="comment"># http://www.crummy.com/software/BeautifulSoup/bs4/doc/#installing-a-parser</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve all of the anchor tags</span></span><br><span class="line">tags = soup(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> tags:</span><br><span class="line">    <span class="comment"># Look at the parts of a tag</span></span><br><span class="line">    <span class="built_in">sum</span> += <span class="built_in">int</span>(tag.contents[<span class="number">0</span>])</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Count&quot;</span>, count)</span><br><span class="line">print(<span class="string">&quot;Sum&quot;</span>, <span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>
<p>代码就是调用方式，网页<code>http://py4e-data.dr-chuck.net/comments_29102.html</code>。</p>
<p>其中格式为<code>&lt;tr&gt;&lt;td&gt;Modu&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;comments&quot;&gt;90&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;</code>。
这里就是去取其中的<strong>90</strong>。</p>
<p><strong>代码二：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request, urllib.parse, urllib.error</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ignore SSL certificate errors</span></span><br><span class="line">ctx = ssl.create_default_context()</span><br><span class="line">ctx.check_hostname = <span class="literal">False</span></span><br><span class="line">ctx.verify_mode = ssl.CERT_NONE</span><br><span class="line"></span><br><span class="line">url = <span class="built_in">input</span>(<span class="string">&#x27;Enter URL: &#x27;</span>)</span><br><span class="line">c = <span class="built_in">input</span>(<span class="string">&#x27;Enter count: &#x27;</span>)</span><br><span class="line">p = <span class="built_in">input</span>(<span class="string">&#x27;Enter position: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">count = <span class="built_in">int</span>(c)</span><br><span class="line">posi = <span class="built_in">int</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count+<span class="number">1</span>):</span><br><span class="line">    print(<span class="string">&quot;Retrieving: &quot;</span>, url)</span><br><span class="line">    html = urllib.request.urlopen(url, context=ctx).read()</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Retrieve all of the anchor tags</span></span><br><span class="line">    tags = soup(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    url = tags[posi-<span class="number">1</span>].get(<span class="string">&#x27;href&#x27;</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>输入链接，跳转次数，从第几个链接跳转，这就像一个网络爬虫一样。</p>
<p>具体的细节完全都不懂，现在只知道表象。</p>
<hr>
<h2 id="Web-Services-and-XML"><a href="#Web-Services-and-XML" class="headerlink" title="Web Services and XML"></a>Web Services and XML</h2><p>这一节将的主要是<strong>XML</strong>语言，以及python对<strong>XML</strong>的一个解析，内容很简单。</p>
<p>直接上代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request, urllib.parse, urllib.error</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line">address = <span class="built_in">input</span>(<span class="string">&#x27;Enter location: &#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(address) &lt; <span class="number">1</span>: </span><br><span class="line">    print(<span class="string">&#x27;invalid location! Enter a location like \&quot;http://py4e-data.dr-chuck.net/comments_42.xml\&quot;&#x27;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line">url = address</span><br><span class="line">print(<span class="string">&#x27;Retrieving&#x27;</span>, url, <span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">uh = urllib.request.urlopen(url)</span><br><span class="line">data = uh.read()</span><br><span class="line">print(<span class="string">&#x27;Retrieved&#x27;</span>, <span class="built_in">len</span>(data), <span class="string">&#x27;characters&#x27;</span>)</span><br><span class="line"><span class="comment"># print(data.decode())</span></span><br><span class="line">tree = ET.fromstring(data)</span><br><span class="line"></span><br><span class="line">items = tree.findall(<span class="string">&#x27;.//count&#x27;</span>)</span><br><span class="line">print(<span class="string">&quot;Count&quot;</span>, <span class="built_in">len</span>(items))</span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    total += <span class="built_in">int</span>(item.text)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Sum:&quot;</span>, total)</span><br></pre></td></tr></table></figure>
<p>输入一个地址，使用<strong>urllib</strong>库来进行连接，然后调用<code>xml.etree.ElementTree</code>来解析其中的data，
解析得到的就是一个<strong>XML</strong>树结构。然后将其中所有count节点的值加起来就行。</p>
<hr>
<h2 id="JSON-and-the-REST-Architecture"><a href="#JSON-and-the-REST-Architecture" class="headerlink" title="JSON and the REST Architecture"></a>JSON and the REST Architecture</h2><p>这一节其实主要讲了<strong>JSON</strong>的解析，它和<strong>XML</strong>类似，但是<strong>JSON</strong>更加轻量级，更加简单，可以使用python解析得到字典或者列表等数据结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request, urllib.parse, urllib.error</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that Google is increasingly requiring keys</span></span><br><span class="line"><span class="comment"># for this API</span></span><br><span class="line">serviceurl = <span class="string">&#x27;http://py4e-data.dr-chuck.net/geojson?&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    address = <span class="built_in">input</span>(<span class="string">&#x27;Enter location: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(address) &lt; <span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    url = serviceurl + urllib.parse.urlencode(</span><br><span class="line">        &#123;<span class="string">&#x27;address&#x27;</span>: address&#125;)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;Retrieving&#x27;</span>, url)</span><br><span class="line">    uh = urllib.request.urlopen(url)</span><br><span class="line">    data = uh.read().decode()</span><br><span class="line">    print(<span class="string">&#x27;Retrieved&#x27;</span>, <span class="built_in">len</span>(data), <span class="string">&#x27;characters&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        js = json.loads(data)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        js = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> js <span class="keyword">or</span> <span class="string">&#x27;status&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> js <span class="keyword">or</span> js[<span class="string">&#x27;status&#x27;</span>] != <span class="string">&#x27;OK&#x27;</span>:</span><br><span class="line">        print(<span class="string">&#x27;==== Failure To Retrieve ====&#x27;</span>)</span><br><span class="line">        print(data)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;Place_id&quot;</span>, js[<span class="string">&quot;results&quot;</span>][<span class="number">0</span>][<span class="string">&quot;place_id&quot;</span>])</span><br></pre></td></tr></table></figure>
<p>这里使用了<strong>google</strong>提供的<strong>api</strong>，来查询到输入地址的位置信息。当然这里实际上调用的是<strong>py4e</strong>的接口，
因为地址的位置信息可能会变，为了批改作业，它就把它改成了<strong>py4e</strong>的接口，这样就不会有变动。</p>
<p>可以看到<strong>json</strong>的解析十分简单，这是它的一大优势。</p>
]]></content>
      <categories>
        <category>coursera</category>
        <category>python for everybody</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 37 Sudoku Solver</title>
    <url>/2017/09/09/2017-09-09-leetcode_37/</url>
    <content><![CDATA[<p>Description:</p>
<blockquote>
<p>Write a program to solve a Sudoku puzzle by filling the empty cells.  </p>
<p>Empty cells are indicated by the character <code>&#39;.&#39;</code>.  </p>
<p>You may assume that there will be only one unique solution.  </p>
</blockquote>
<p>excemple:</p>
<p><img src="/images/leetcode/37_2.png" alt="image"></p>
<p>solve:</p>
<p><img src="/images/leetcode/37_3.png" alt="image"></p>
<hr>
<p>题目理解：</p>
<p>数独应该每个人都玩过，它规则很简单，但是做起来很难，就是因为它可能性太多了。</p>
<p>那么这个问题要求解数独问题，首先肯定是需要使用递归来解，然后就可以想能不能动态规划，好像不能，那么就只能强行递归，复杂度不想计算，肯定是指数级，但是它是 <code>9x9</code>的格子，所以还好。</p>
<hr>
<p>代码：</p>
<p>这里其实挺考验的，如何组织数据是一个大问题，直接影响到整个代码的结构，一定要想得简单一点。</p>
<p>下面代码也是进过很多次调整的，思路比最开始清晰多了。</p>
<p>另外，一个清晰的思路十分重要，不要上来就写，要先想清楚。</p>
<p><strong>代码虽然很长，但是思路还是很清晰的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一，计算需要填写的格子的剩余可用的格子</span></span><br><span class="line"><span class="comment">     * 第二，取出当前操作数最少的格子</span></span><br><span class="line"><span class="comment">     * 第三，递归</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负责初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] r_used = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];   <span class="comment">// 行已使用的数字</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] c_used = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];   <span class="comment">// 列已使用的数字</span></span><br><span class="line">        <span class="keyword">boolean</span>[][][] b_used = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];  <span class="comment">// 3x3 的大格子已使用的数字</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ems = <span class="keyword">new</span> ArrayList&lt;&gt;();      <span class="comment">// 空的格子的下标</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( board[i][j] == <span class="string">&#x27;.&#x27;</span> ) &#123;</span><br><span class="line">                    <span class="keyword">int</span>[] empty = &#123;i, j, <span class="number">0</span>&#125;;      <span class="comment">// 行 + 列 + 它可以使用的数字的个数</span></span><br><span class="line">                    ems.add(empty);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="number">49</span>;   <span class="comment">// char 转 int 这里多减一个 1 ， 因为 &#x27;1&#x27; 对应 0 下标</span></span><br><span class="line">                    myAdjuster( i, j, num, <span class="keyword">true</span>, r_used, c_used, b_used );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_idx = findMin( ems, r_used, c_used, b_used );</span><br><span class="line">        mySolver ( board, ems, r_used, c_used, b_used, min_idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归主体，对输入的 ems.get(idx) 这个格子填数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">mySolver</span> <span class="params">( <span class="keyword">char</span>[][] bd, List&lt;<span class="keyword">int</span>[]&gt; ems, <span class="keyword">boolean</span>[][] r_used, <span class="keyword">boolean</span>[][] c_used, <span class="keyword">boolean</span>[][][] b_used, <span class="keyword">int</span> idx )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( idx == -<span class="number">1</span> ) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span>[] em = ems.get(idx);</span><br><span class="line">        ems.remove(em);     <span class="comment">// 将这个格子先移除集合，因为现在要填数字</span></span><br><span class="line">        <span class="keyword">int</span> i = em[<span class="number">0</span>], j = em[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> num = <span class="number">0</span>; num &lt; <span class="number">9</span>; num++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !r_used[i][num] &amp;&amp; !c_used[j][num] &amp;&amp; !b_used[i/<span class="number">3</span>][j/<span class="number">3</span>][num] ) &#123;  <span class="comment">// 可以使用的数字</span></span><br><span class="line">                myAdjuster( i, j, num, <span class="keyword">true</span>, r_used, c_used, b_used );        <span class="comment">// 调整所使用的数字</span></span><br><span class="line">                <span class="keyword">int</span> min_idx = findMin( ems, r_used, c_used, b_used );              <span class="comment">// 找到下一个最小</span></span><br><span class="line">                <span class="keyword">if</span> ( mySolver ( bd, ems, r_used, c_used, b_used, min_idx) ) &#123;      <span class="comment">// 递归</span></span><br><span class="line">                    bd[i][j] = (<span class="keyword">char</span>)(num + <span class="number">49</span>);                                   <span class="comment">// 成功表示问题已经解决</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                myAdjuster( i, j, num, <span class="keyword">false</span>, r_used, c_used, b_used );       <span class="comment">// 恢复调整</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ems.add(em);      <span class="comment">// 添加回集合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整或者恢复 使用的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myAdjuster</span><span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> num, <span class="keyword">boolean</span> add, <span class="keyword">boolean</span>[][] r_used, <span class="keyword">boolean</span>[][] c_used, <span class="keyword">boolean</span>[][][] b_used )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (add) &#123;</span><br><span class="line">            r_used[i][num] = <span class="keyword">true</span>;</span><br><span class="line">            c_used[j][num] = <span class="keyword">true</span>;</span><br><span class="line">            b_used[i/<span class="number">3</span>][j/<span class="number">3</span>][num] = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r_used[i][num] = <span class="keyword">false</span>;</span><br><span class="line">            c_used[j][num] = <span class="keyword">false</span>;</span><br><span class="line">            b_used[i/<span class="number">3</span>][j/<span class="number">3</span>][num] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到最小可操作的格子坐标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">( List&lt;<span class="keyword">int</span>[]&gt; ems, <span class="keyword">boolean</span>[][] r_used, <span class="keyword">boolean</span>[][] c_used, <span class="keyword">boolean</span>[][][] b_used )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span>[] em : ems ) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = em[<span class="number">0</span>], j = em[<span class="number">1</span>];</span><br><span class="line">            em[<span class="number">2</span>] = <span class="number">0</span>;   <span class="comment">// 将这个格子的计数先置零</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> num = <span class="number">0</span>; num &lt; <span class="number">9</span>; num++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( !r_used[i][num] &amp;&amp; !c_used[j][num] &amp;&amp; !b_used[i/<span class="number">3</span>][j/<span class="number">3</span>][num] )   <span class="comment">// 使用可用这个数字</span></span><br><span class="line">                    em[<span class="number">2</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">1000</span>, idx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ems.size(); i++ ) &#123;   <span class="comment">// 找到最小</span></span><br><span class="line">            <span class="keyword">int</span>[] em = ems.get(i);</span><br><span class="line">            <span class="keyword">if</span> ( em[<span class="number">2</span>] &lt; min ) &#123;</span><br><span class="line">                min = em[<span class="number">2</span>];</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时间：8ms。<br>复杂度：指数。<br>击败：94.23%</p>
<p><img src="/images/leetcode/37_1.png" alt="image"></p>
<p>代码二：</p>
<p>上面的代码每次去找最下操作的格子的时候显得比较复杂，那么将更新与格子的可操作数维护放在一起做，就得到下面的代码，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一，计算需要填写的格子的剩余可用的格子</span></span><br><span class="line"><span class="comment">     * 第二，取出当前操作数最少的格子</span></span><br><span class="line"><span class="comment">     * 第三，递归</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Ep</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> row, col, block;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Ep</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> block)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.row = row;</span><br><span class="line">            <span class="keyword">this</span>.col = col;</span><br><span class="line">            <span class="keyword">this</span>.block = block;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ( used[num] != flag ) &#123;</span><br><span class="line">                count = <span class="keyword">true</span> == flag ? count - <span class="number">1</span> : count + <span class="number">1</span>;</span><br><span class="line">                used[num] = flag;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负责初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        List&lt;Ep&gt; ems = <span class="keyword">new</span> ArrayList&lt;&gt;();      <span class="comment">// 空的格子的下标</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( board[i][j] == <span class="string">&#x27;.&#x27;</span> ) &#123;</span><br><span class="line">                    Ep empty = <span class="keyword">new</span> Ep(i, j, (i/<span class="number">3</span>)*<span class="number">3</span> + j/<span class="number">3</span> + <span class="number">1</span>);      <span class="comment">// 行 + 列 + 格子</span></span><br><span class="line">                    ems.add(empty);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_idx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] temp = <span class="keyword">new</span> <span class="keyword">boolean</span>[ems.size()];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( board[i][j] != <span class="string">&#x27;.&#x27;</span> ) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="number">49</span>;   <span class="comment">// char 转 int 这里多减一个 1 ， 因为 &#x27;1&#x27; 对应 0 下标</span></span><br><span class="line">                    min_idx = myAdjuster( ems, i, j, num, <span class="keyword">true</span> , temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mySolver ( board, ems, min_idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归主体，对输入的 ems.get(idx) 这个格子填数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">mySolver</span> <span class="params">( <span class="keyword">char</span>[][] bd, List&lt;Ep&gt; ems, <span class="keyword">int</span> idx )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( idx == -<span class="number">1</span> ) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Ep em = ems.get(idx);</span><br><span class="line">        ems.remove(idx);     <span class="comment">// 将这个格子先移除集合，因为现在要填数字</span></span><br><span class="line">        <span class="keyword">boolean</span>[] adjust = <span class="keyword">new</span> <span class="keyword">boolean</span>[ems.size()];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> num = <span class="number">0</span>; num &lt; <span class="number">9</span>; num++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( <span class="keyword">false</span> == em.used[num] ) &#123;  <span class="comment">// 可以使用的数字</span></span><br><span class="line">                <span class="keyword">int</span> min_idx = myAdjuster( ems, em.row, em.col, num, <span class="keyword">true</span>, adjust );        <span class="comment">// 调整所使用的数字</span></span><br><span class="line">                <span class="keyword">if</span> ( mySolver ( bd, ems, min_idx) ) &#123;      <span class="comment">// 递归</span></span><br><span class="line">                    bd[em.row][em.col] = (<span class="keyword">char</span>)(num + <span class="number">49</span>);                                   <span class="comment">// 成功表示问题已经解决</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                myAdjuster( ems, em.row, em.col, num, <span class="keyword">false</span>, adjust );       <span class="comment">// 恢复调整</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ems.add(idx, em);      <span class="comment">// 添加回集合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整或者恢复 使用的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">myAdjuster</span><span class="params">( List&lt;Ep&gt; ems, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> num, <span class="keyword">boolean</span> flag, <span class="keyword">boolean</span>[] adjust)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( flag == <span class="keyword">true</span> ) &#123;</span><br><span class="line">            <span class="keyword">int</span> block = (i/<span class="number">3</span>)*<span class="number">3</span> + j/<span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE, idx = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> ii = <span class="number">0</span>, bound = ems.size(); ii &lt; bound; ii++ ) &#123;</span><br><span class="line">                Ep em = ems.get(ii);</span><br><span class="line">                <span class="keyword">if</span> ( em.row == i || em.col == j || em.block == block )</span><br><span class="line">                    adjust[ii] = em.set(num, flag);</span><br><span class="line">                <span class="keyword">if</span> ( min &gt; em.count ) &#123;</span><br><span class="line">                    min = em.count;</span><br><span class="line">                    idx = ii;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">             <span class="keyword">return</span> idx;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; adjust.length; ii++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( adjust[ii] ) &#123;</span><br><span class="line">                    ems.get(ii).set(num, <span class="keyword">false</span>);</span><br><span class="line">                    adjust[ii] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的维护操作直接与格子绑定在一起，将它建立成为一个格子对象，这样耗费了更多的空间，换来的就是可以维护格子的操作数。</p>
<p>复杂度：指数。<br>运行时间：4ms。<br>击败：99.15%</p>
<p><img src="/images/leetcode/37_4.png" alt="image"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 41 First Missing Positive</title>
    <url>/2017/09/10/2017-09-10-leetcode_41/</url>
    <content><![CDATA[<p>Description:</p>
<blockquote>
<p>Given an unsorted integer array, find the first missing positive integer.  </p>
<p>For example,<br>Given [1,2,0] return 3,<br>and [3,4,-1,1] return 2.  </p>
<p>Your algorithm should run in O(n) time and uses constant space.  </p>
</blockquote>
<p>题目理解：问题倒是十分的简单，所以这道题hard的原因在于固定的额外空间，也就是要原址操作。</p>
<p>如果不要求原址操作，那就是easy，但是原址操作的确也是不太好想，最后一瞬间想到了散列表，就想到这题的解法了，
也就是将一个数放到它应该在的位置上，比如数字<code>5</code>，那么它就该在数组的<code>4</code>位置上，那么通过直接索引加上交换，
就能实现题目要求。</p>
<p>PS:之前写的没有考虑固定空间，辣鸡。</p>
<hr>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i &lt;= right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = nums[i] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ( idx == i ) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( idx &gt; right || idx &lt; <span class="number">0</span> || nums[idx] == nums[i] ) &#123;</span><br><span class="line">                nums[i] = nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[i] = nums[idx];</span><br><span class="line">                nums[idx] = idx + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额外空间只使用了三个<code>int</code>，循环每次都操作一个数，或是放到最后，或者正确位置，并且同一个位置最多会被交换一次，所以复杂度是O(n)的。</p>
<p>复杂度：O(n)。<br>运行时间：12ms。<br>击败：56.77%</p>
<p><img src="/images/leetcode/41_1.png" alt="image"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>Using Databases with Python 笔记</title>
    <url>/2017/09/12/2017-09-12-using-databases-with-python/</url>
    <content><![CDATA[<h2 id="Object-Oriented-Python"><a href="#Object-Oriented-Python" class="headerlink" title="Object Oriented Python"></a>Object Oriented Python</h2><p>课程首先讲了一下<strong>Python</strong>的类的定义，它也是很通常的定义，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartyAnimal</span>:</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;I am constructed&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">party</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.x = self.x + <span class="number">1</span></span><br><span class="line">        print(<span class="string">&#x27;So far&#x27;</span>, self.x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;I am destructed&#x27;</span>, self.x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span>(<span class="params">PartyAnimal</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;None&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        print(<span class="string">&#x27;I am constructed&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.name, <span class="string">&#x27;eat&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = PartyAnimal()</span><br><span class="line">p.party()</span><br><span class="line">p = <span class="number">102</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;eeeeeeeeeeeeeeeeeeeeeeeeeeeeee&quot;</span>)</span><br><span class="line"></span><br><span class="line">cc = cat(<span class="string">&quot;XIAOBAI&quot;</span>)</span><br><span class="line">cc.eat()</span><br><span class="line">cc = <span class="number">134</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>I am constructed<br>So far 1<br>I am destructed 1<br>eeeeeeeeeeeeeeeeeeeeeeeeeeeeee<br>I am constructed<br>XIAOBAI eat<br>I am destructed 0  </p>
</blockquote>
<p>所以新建类，使用<code>class</code>，继承类就在后面加上<code>(要继承的类)</code>，也就是<code>class name(Inheritance)</code>。</p>
<p>继承会继承<strong>成员变量</strong>和<strong>成员方法</strong>，以及<strong>构造器</strong>和<strong>析构器</strong>，当然也可以重写方法，总体就是十分正常的继承规则。</p>
<hr>
<h2 id="Basic-Structured-Query-Language"><a href="#Basic-Structured-Query-Language" class="headerlink" title="Basic Structured Query Language"></a>Basic Structured Query Language</h2><p>这一部分将了基本的数据库语法，然后在<strong>python</strong>中书写<strong>sql</strong>，需要注意的是<strong>python</strong>中自带的是<strong>sqlite</strong>，
是一个轻量级的<strong>sql</strong>的库，所以它可以直接做成一个包来调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;emaildb.sqlite&#x27;</span>)</span><br><span class="line">cur = conn.cursor()</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS Counts&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">CREATE TABLE Counts (org TEXT, count INTEGER)&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fname = <span class="built_in">input</span>(<span class="string">&#x27;Enter file name: &#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">len</span>(fname) &lt; <span class="number">1</span>): fname = <span class="string">&#x27;mbox-short.txt&#x27;</span></span><br><span class="line">fh = <span class="built_in">open</span>(fname)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fh:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line.startswith(<span class="string">&#x27;From: &#x27;</span>): <span class="keyword">continue</span></span><br><span class="line">    all_org = re.findall(<span class="string">&quot;@(.+)\s&quot;</span>, line)</span><br><span class="line">    org = all_org[<span class="number">0</span>]</span><br><span class="line">    cur.execute(<span class="string">&#x27;SELECT count FROM Counts WHERE org = ? &#x27;</span>, (org,))</span><br><span class="line">    row = cur.fetchone()</span><br><span class="line">    <span class="keyword">if</span> row <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        cur.execute(<span class="string">&#x27;&#x27;&#x27;INSERT INTO Counts (org, count)</span></span><br><span class="line"><span class="string">                VALUES (?, 1)&#x27;&#x27;&#x27;</span>, (org,))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cur.execute(<span class="string">&#x27;UPDATE Counts SET count = count + 1 WHERE org = ?&#x27;</span>,</span><br><span class="line">                    (org,))</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://www.sqlite.org/lang_select.html</span></span><br><span class="line">sqlstr = <span class="string">&#x27;SELECT org, count FROM Counts ORDER BY count DESC LIMIT 10&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cur.execute(sqlstr):</span><br><span class="line">    print(<span class="built_in">str</span>(row[<span class="number">0</span>]), row[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">cur.close()</span><br></pre></td></tr></table></figure>
<p>上面是一个建表并且更新或增加表项的过程，这个过程就会在当前目录下新建一个<code>emaildb.sqlite</code>的<strong>sql</strong>文件。</p>
<p>需要注意的是<strong>第29行</strong>的<code>commit()</code>，只有在执行它之后才会将结果写入文件，所以放到循环外面执行会快很多。</p>
<hr>
<h2 id="Data-Models-and-Relational-SQL"><a href="#Data-Models-and-Relational-SQL" class="headerlink" title="Data Models and Relational SQL"></a>Data Models and Relational SQL</h2><p>这一部分讲了数据库的一些使用技巧。</p>
<p>在使用数据库时，数据量小的时候自然是无所谓，但是在数据量很大的时候，要遵循一个原则，那就是对于经常会<strong>重复</strong>出现的字符串，我们不能让它重复，因为它这样会浪费空间。</p>
<p>所以存储时，对于重复出现的字符串，将它单独建立为一个表，别的表使用它的下标来进行索引。但是这个索引是我们自己做的，所以查询时要有技巧。</p>
<p>例如音乐的专辑和歌手。显然一个歌手平均不止一张专辑，那么就将专辑和歌手拆成两个表，</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>歌手名</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>周杰伦</td>
</tr>
<tr>
<td>2</td>
<td>林俊杰</td>
</tr>
<tr>
<td>3</td>
<td>Avril Lavigne</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>专辑名</th>
<th>歌手名</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>八度空间</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>范特西</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>第二天堂</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>Let go</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>叶惠美</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>Under My Skin</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<p>这样也就是在专辑表中，我们就节约了存储空间，更为重要的是这样可以得到数据之间清晰的关系。</p>
<p>那么查询的时候该怎么办呢？可以使用下面语句来查询，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 专辑.专辑名, 歌手.歌手名 <span class="keyword">FROM</span> 专辑 <span class="keyword">JOIN</span> 歌手 <span class="keyword">ON</span> 专辑.歌手名 <span class="operator">=</span> 歌手.序号</span><br></pre></td></tr></table></figure>
<p>其中<code>JOIN</code>关键字的任务是将两个表合在一起查询，<code>ON</code>关键字限定了条件，进行筛选。
这就能查询得到下面的结果:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>专辑名</th>
<th>歌手名  </th>
</tr>
</thead>
<tbody>
<tr>
<td>八度空间</td>
<td>周杰伦 </td>
</tr>
<tr>
<td>范特西</td>
<td>周杰伦 </td>
</tr>
<tr>
<td>第二天堂</td>
<td>林俊杰  </td>
</tr>
<tr>
<td>Let go</td>
<td>Avril </td>
</tr>
<tr>
<td>叶惠美</td>
<td>周杰伦 </td>
</tr>
<tr>
<td>Under My Skin</td>
<td>Avril </td>
</tr>
</tbody>
</table>
</div>
<p>下面是作业中使用python脚本建立数据库的过程，注意其中的关键字<code>IGNORE</code>，它的作用是如果当期数据存在，那就不插入，否则插入。在这个地方十分有用，因为索引不能随意变化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;trackdb.sqlite&#x27;</span>)</span><br><span class="line">cur = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make some fresh tables using executescript()</span></span><br><span class="line">cur.executescript(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS Artist;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS Album;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS Track;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS Genre;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE Artist (</span></span><br><span class="line"><span class="string">    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,</span></span><br><span class="line"><span class="string">    name TEXT UNIQUE</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE Genre (</span></span><br><span class="line"><span class="string">    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,</span></span><br><span class="line"><span class="string">    name TEXT UNIQUE</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE Album (</span></span><br><span class="line"><span class="string">    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,</span></span><br><span class="line"><span class="string">    artist_id  INTEGER,</span></span><br><span class="line"><span class="string">    title TEXT UNIQUE</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE Track (</span></span><br><span class="line"><span class="string">    id  INTEGER NOT NULL PRIMARY KEY </span></span><br><span class="line"><span class="string">        AUTOINCREMENT UNIQUE,</span></span><br><span class="line"><span class="string">    title TEXT  UNIQUE,</span></span><br><span class="line"><span class="string">    album_id  INTEGER,</span></span><br><span class="line"><span class="string">    genre_id  INTEGER,</span></span><br><span class="line"><span class="string">    len INTEGER, rating INTEGER, count INTEGER</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fname = <span class="built_in">input</span>(<span class="string">&#x27;Enter file name: &#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">len</span>(fname) &lt; <span class="number">1</span> ) : fname = <span class="string">&#x27;Library.xml&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;key&gt;Track ID&lt;/key&gt;&lt;integer&gt;369&lt;/integer&gt;</span></span><br><span class="line"><span class="comment"># &lt;key&gt;Name&lt;/key&gt;&lt;string&gt;Another One Bites The Dust&lt;/string&gt;</span></span><br><span class="line"><span class="comment"># &lt;key&gt;Artist&lt;/key&gt;&lt;string&gt;Queen&lt;/string&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookup</span>(<span class="params">d, key</span>):</span></span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> d:</span><br><span class="line">        <span class="keyword">if</span> found : <span class="keyword">return</span> child.text</span><br><span class="line">        <span class="keyword">if</span> child.tag == <span class="string">&#x27;key&#x27;</span> <span class="keyword">and</span> child.text == key :</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">stuff = ET.parse(fname)</span><br><span class="line"><span class="built_in">all</span> = stuff.findall(<span class="string">&#x27;dict/dict/dict&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;Dict count:&#x27;</span>, <span class="built_in">len</span>(<span class="built_in">all</span>))</span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> <span class="built_in">all</span>:</span><br><span class="line">    <span class="keyword">if</span> ( lookup(entry, <span class="string">&#x27;Track ID&#x27;</span>) <span class="keyword">is</span> <span class="literal">None</span> ) : <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    name = lookup(entry, <span class="string">&#x27;Name&#x27;</span>)</span><br><span class="line">    artist = lookup(entry, <span class="string">&#x27;Artist&#x27;</span>)</span><br><span class="line">    album = lookup(entry, <span class="string">&#x27;Album&#x27;</span>)</span><br><span class="line">    count = lookup(entry, <span class="string">&#x27;Play Count&#x27;</span>)</span><br><span class="line">    rating = lookup(entry, <span class="string">&#x27;Rating&#x27;</span>)</span><br><span class="line">    length = lookup(entry, <span class="string">&#x27;Total Time&#x27;</span>)</span><br><span class="line">    genre = lookup(entry, <span class="string">&#x27;Genre&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> artist <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> album <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> genre <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    print(name, artist, album, genre, count, rating, length)</span><br><span class="line"></span><br><span class="line">    cur.execute(<span class="string">&#x27;&#x27;&#x27;INSERT OR IGNORE INTO Artist (name) </span></span><br><span class="line"><span class="string">        VALUES ( ? )&#x27;&#x27;&#x27;</span>, ( artist, ) )</span><br><span class="line">    cur.execute(<span class="string">&#x27;SELECT id FROM Artist WHERE name = ? &#x27;</span>, (artist, ))</span><br><span class="line">    artist_id = cur.fetchone()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    cur.execute(<span class="string">&#x27;&#x27;&#x27;INSERT OR IGNORE INTO Genre (name) </span></span><br><span class="line"><span class="string">        VALUES ( ? )&#x27;&#x27;&#x27;</span>, ( genre, ) )</span><br><span class="line">    cur.execute(<span class="string">&#x27;SELECT id FROM Genre WHERE name = ? &#x27;</span>, (genre, ))</span><br><span class="line">    genre_id = cur.fetchone()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    cur.execute(<span class="string">&#x27;&#x27;&#x27;INSERT OR IGNORE INTO Album (title, artist_id) </span></span><br><span class="line"><span class="string">        VALUES ( ?, ? )&#x27;&#x27;&#x27;</span>, ( album, artist_id ) )</span><br><span class="line">    cur.execute(<span class="string">&#x27;SELECT id FROM Album WHERE title = ? &#x27;</span>, (album, ))</span><br><span class="line">    album_id = cur.fetchone()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    cur.execute(<span class="string">&#x27;&#x27;&#x27;INSERT OR REPLACE INTO Track</span></span><br><span class="line"><span class="string">        (title, album_id, genre_id, len, rating, count) </span></span><br><span class="line"><span class="string">        VALUES ( ?, ?, ?, ?, ?, ? )&#x27;&#x27;&#x27;</span>, </span><br><span class="line">        ( name, album_id, genre_id, length, rating, count ) )</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br></pre></td></tr></table></figure>
<h2 id="Many-to-Many-Relationships-in-SQL"><a href="#Many-to-Many-Relationships-in-SQL" class="headerlink" title="Many-to-Many Relationships in SQL"></a>Many-to-Many Relationships in SQL</h2><p>这一节很简单，讲了数据存在多对多关系时如何存储，这时的存储方式就是将数据分别存储，然后将它们之间的关系建成一个关系表。</p>
<p>代码省略。</p>
<h2 id="Databases-and-Visualization"><a href="#Databases-and-Visualization" class="headerlink" title="Databases and Visualization"></a>Databases and Visualization</h2><p>调用google的<code>Geocoding</code>这个<strong>API</strong>（这是<code>google map</code>的api，可以查询地理位置信息），获取到原始数据，
然后将数据进行一下处理，写入<code>where.js</code>，然后调用<code>html</code>脚本进行画图。</p>
<h2 id="后一课程"><a href="#后一课程" class="headerlink" title="后一课程"></a>后一课程</h2><p>最后的第五个课程完全是一些小项目，但是他都给好了代码，相当于他带你简单过一遍这些项目的代码。</p>
<p>很多地方现在还理解不了，先不记录了，以后可以再回来重看。</p>
]]></content>
      <categories>
        <category>coursera</category>
        <category>python for everybody</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 30 Substring with Concatenation of All Words</title>
    <url>/2017/09/15/2017-09-15-leetcode_30/</url>
    <content><![CDATA[<p>Description:</p>
<blockquote>
<p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.  </p>
<p>For example, given:<br>s: “barfoothefoobarman”<br>words: [“foo”, “bar”]  </p>
<p>You should return the indices: [0,9].<br>(order does not matter).  </p>
</blockquote>
<hr>
<p>题目理解：</p>
<p>乍一看这是一个字符串匹配问题，但是其实这样想的话就完全错误了，这比字符串匹配问题要复杂多了。</p>
<p>还好的是它所给的单词都是一样长的，这就已经简化了很多的问题，但是它可以给重复的单词，
那么这个问题又不那么简单了，因为这些单词之间可以随意的排列组合，重复的单词会带来很多问题。</p>
<p>那么首先一定要去除重复，不然会对重复的单词进行重复的匹配，并且对排列组合很不利。通常想到的肯定是使用
<code>HashMap</code>来做，这样很快能统计出重复的单词，以及这个单词重复的次数。</p>
<p>因为总长度固定，那么只需要在一个固定长度的窗内去检测是否匹配就好，那么就可以将这个窗从左向右进行滑动，
来一个单词一个单词的匹配。</p>
<p>那么如何进行单词的匹配呢？首先想到的是字符串匹配问题，可以使用<strong>KMP</strong>算法来匹配字符串与每一个单词，记录下所有匹配的位置，
注意到每个单词都不同（去除重复之后），单词长度一样，那么它们之间匹配的位置就不会重复。
所有可以直接使用一个与字符串同样长的数组来存储这些下标。</p>
<p>如何查看是否匹配？这时就需要发挥想象力，首先滑动窗是肯定的，在滑动窗中统计很有技巧，这里：</p>
<ul>
<li>设置一个总距离<strong>dis</strong>，表示窗口中单词与字典之间的距离。一个单词的距离就是<strong>1</strong>，所以初始的时候距离为字典的总单词数。</li>
<li>滑动窗口，从字符串上<strong>切割</strong>出一个新的单词，如果这个单词与字典中的单词<strong>不匹配</strong>，则不操作。否则<strong>匹配</strong>上单词<strong>A</strong>：<ul>
<li>单词<strong>A</strong>现在的计数<strong>超过</strong>所需个数，距离加一。</li>
<li>单词<strong>A</strong>现在的计数<strong>不超过</strong>所需个数，距离减一。</li>
</ul>
</li>
<li>滑动窗口，需要将最左端的一个单词<strong>弹出</strong>，进行与上面<strong>相反</strong>的操作。</li>
</ul>
<hr>
<p>代码一：</p>
<p><strong>注：</strong>这里没有使用<code>HashMap</code>来除去重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] matchs;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> ( s == <span class="keyword">null</span> || words == <span class="keyword">null</span> || ( words[<span class="number">0</span>].length()*words.length &gt; s.length() ) ) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span> ( words[<span class="number">0</span>].equals(<span class="string">&quot;&quot;</span>) ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= s.length() ; i++ ) </span><br><span class="line">                res.add(i);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        matchs = <span class="keyword">new</span> <span class="keyword">int</span>[ss.length];</span><br><span class="line">        Arrays.fill( matchs, -<span class="number">1</span> );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[words.length];</span><br><span class="line">        String[] words_wipe = <span class="keyword">new</span> String[words.length];</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[words.length];</span><br><span class="line">        <span class="keyword">int</span> counts_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !used[i] ) &#123;</span><br><span class="line">                words_wipe[counts_len] = words[i];</span><br><span class="line">                counts[counts_len] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.length; j++ ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( words[i].equals(words[j]) ) &#123;</span><br><span class="line">                        counts[counts_len]++;</span><br><span class="line">                        used[j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                counts_len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counts_len; i++ ) &#123;</span><br><span class="line">            KMP(ss, words_wipe[i].toCharArray(), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> step = words_wipe[<span class="number">0</span>].length(), dis = words.length, total_len = dis * step;</span><br><span class="line">        <span class="keyword">int</span>[] sub_count = <span class="keyword">new</span> <span class="keyword">int</span>[counts_len];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; i++ ) &#123;</span><br><span class="line">            Arrays.fill(sub_count, <span class="number">0</span>);</span><br><span class="line">            dis = words.length;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i; j &lt; ss.length; j += step ) &#123;</span><br><span class="line">                <span class="keyword">int</span> head = j - total_len;</span><br><span class="line">                <span class="keyword">if</span> ( head &gt; -<span class="number">1</span> &amp;&amp; matchs[head] != -<span class="number">1</span> ) &#123;</span><br><span class="line">                    dis = sub_count[matchs[head]] &lt;= counts[matchs[head]] ? dis + <span class="number">1</span> : dis - <span class="number">1</span>;</span><br><span class="line">                    sub_count[matchs[head]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( matchs[j] == -<span class="number">1</span> )</span><br><span class="line">                     <span class="keyword">continue</span>;</span><br><span class="line">                dis = sub_count[matchs[j]] &gt;= counts[matchs[j]] ? dis + <span class="number">1</span> : dis - <span class="number">1</span>;</span><br><span class="line">                sub_count[matchs[j]]++;</span><br><span class="line">                <span class="keyword">if</span> ( dis == <span class="number">0</span> )</span><br><span class="line">                    res.add(j - total_len + step);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span>[] t, <span class="keyword">char</span>[] p, <span class="keyword">int</span> widx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pai = computePai(p);</span><br><span class="line">        <span class="keyword">int</span> match_idx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length; i++ ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( match_idx &gt; -<span class="number">1</span> &amp;&amp; p[match_idx + <span class="number">1</span>] != t[i] )</span><br><span class="line">                match_idx = pai[match_idx];</span><br><span class="line">            <span class="keyword">if</span> ( p[match_idx + <span class="number">1</span>] == t[i] )</span><br><span class="line">                match_idx++;</span><br><span class="line">            <span class="keyword">if</span> ( match_idx == p.length - <span class="number">1</span> ) &#123;</span><br><span class="line">                matchs[i - p.length + <span class="number">1</span>] = widx;</span><br><span class="line">                match_idx = pai[match_idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] computePai(<span class="keyword">char</span>[] p) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pai = <span class="keyword">new</span> <span class="keyword">int</span>[p.length];</span><br><span class="line">        pai[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt; p.length; idx++ ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( k &gt; -<span class="number">1</span> &amp;&amp; p[k+<span class="number">1</span>] != p[idx] )</span><br><span class="line">                k = pai[k];</span><br><span class="line">            <span class="keyword">if</span> ( p[k+<span class="number">1</span>] == p[idx] )</span><br><span class="line">                k = k + <span class="number">1</span>;</span><br><span class="line">            pai[idx] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pai;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：O(mn)?<br>运行时间：50ms<br>击败：57.51%</p>
<p><img src="/images/leetcode/30_1.png" alt="image"></p>
<hr>
<p>代码还是很垃圾，所以和别人的差距在哪里，实在是想不出来，查看别人代码后发现，别人使用的是<code>HashMap</code>的<strong>Hash</strong>功能来匹配单词的，
这样通过<strong>Hash</strong>来进行两个个单词的匹配，复杂度是<strong>O(1)</strong>，额，原来<strong>Hash</strong>是这样使用的…</p>
<p>另外这里还要翻转一下思维，上面是用单词去匹配字符串，这里由于先建好了一个单词的<code>HashMap</code>，所以直接将字符串切割，
然后使用切出的单词使用<code>HashMap</code>查询就能知道它的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = words.length, step = words[<span class="number">0</span>].length(), bound = m - step, total_len = step * n;</span><br><span class="line">        <span class="comment">// Count the repeated words</span></span><br><span class="line">        Map&lt; String, Integer&gt; words_list = <span class="keyword">new</span> HashMap&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">int</span>[][] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][n];</span><br><span class="line">        Integer index = <span class="number">0</span>, temp;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ( temp = words_list.get(words[i])) != <span class="keyword">null</span> ) counts[<span class="number">0</span>][temp]++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                words_list.put( words[i], index);</span><br><span class="line">                counts[<span class="number">0</span>][index++] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// from s.start to s.end, match all the substring</span></span><br><span class="line">        <span class="keyword">int</span>[] matchs = <span class="keyword">new</span> <span class="keyword">int</span>[bound + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bound; i++ ) &#123;</span><br><span class="line">            String s_sub = s.substring(i, i + step);</span><br><span class="line">            matchs[i] = ((temp = words_list.get(s_sub)) != <span class="keyword">null</span>) ? temp : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// move window from head to end, dis = 0 means the current window contains all the words</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; i++ ) &#123;</span><br><span class="line">            Arrays.fill(counts[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> dis = n;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i; j &lt;= bound; j += step ) &#123;</span><br><span class="line">                <span class="keyword">int</span> head = j - total_len;</span><br><span class="line">                <span class="keyword">if</span> ( head &gt; -<span class="number">1</span> &amp;&amp; matchs[head] != -<span class="number">1</span> ) &#123;</span><br><span class="line">                    dis = counts[<span class="number">1</span>][matchs[head]] &lt;= counts[<span class="number">0</span>][matchs[head]] ? dis + <span class="number">1</span> : dis - <span class="number">1</span>;</span><br><span class="line">                    counts[<span class="number">1</span>][matchs[head]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( matchs[j] == -<span class="number">1</span> )</span><br><span class="line">                     <span class="keyword">continue</span>;</span><br><span class="line">                dis = counts[<span class="number">1</span>][matchs[j]] &gt;= counts[<span class="number">0</span>][matchs[j]] ? dis + <span class="number">1</span> : dis - <span class="number">1</span>;</span><br><span class="line">                counts[<span class="number">1</span>][matchs[j]]++;</span><br><span class="line">                <span class="keyword">if</span> ( dis == <span class="number">0</span> )</span><br><span class="line">                    res.add(j - total_len + step);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：O(n)。<br>运行时间：27ms。<br>击败：92.37%</p>
<p><img src="/images/leetcode/30_2.png" alt="image"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 76 Minimum Window Substring</title>
    <url>/2017/09/15/2017-09-15-leetcode_76/</url>
    <content><![CDATA[<p>Description:</p>
<blockquote>
<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).  </p>
<p>For example,<br>S = “ADOBECODEBANC”<br>T = “ABC”<br>Minimum window is “BANC”.  </p>
<p>Note:<br>If there is no such window in S that covers all characters in T, return the empty string “”.  </p>
<p>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.  </p>
</blockquote>
<hr>
<p>题目理解：</p>
<p>给定一个字符集合<strong>T</strong>，要找到字符串<strong>S</strong>中包含这些字符的最小子串，字符可以重复，<strong>要求复杂度为O(n)</strong>。</p>
<p>想了很久也不知道如何<strong>O(n)</strong>，只能想到<strong>O(mn)</strong>。</p>
<hr>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CharInt</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        CharInt next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CharInt</span> <span class="params">( <span class="keyword">char</span> c, <span class="keyword">int</span> idx )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.c = c;</span><br><span class="line">            <span class="keyword">this</span>.idx = idx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray(), tt = t.toCharArray();</span><br><span class="line">        CharInt head = <span class="keyword">new</span> CharInt(<span class="string">&#x27;0&#x27;</span>, -<span class="number">1</span>), tail, relay, temp;</span><br><span class="line">        relay = <span class="keyword">new</span> CharInt(tt[<span class="number">0</span>], -<span class="number">1</span>);</span><br><span class="line">        head.next = relay;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tt.length; i++ ) &#123;</span><br><span class="line">            relay.next = <span class="keyword">new</span> CharInt(tt[i], -<span class="number">1</span>);</span><br><span class="line">            relay = relay.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = relay;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE, l = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ss.length; i++ ) &#123;</span><br><span class="line">            relay = head;</span><br><span class="line">            <span class="keyword">while</span> ( relay.next != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( relay.next.c == ss[i] ) &#123; </span><br><span class="line">                    temp = relay.next;</span><br><span class="line">                    temp.idx = i;</span><br><span class="line">                    <span class="keyword">if</span> ( temp != tail ) &#123;</span><br><span class="line">                        relay.next = temp.next;</span><br><span class="line">                        temp.next = <span class="keyword">null</span>;</span><br><span class="line">                        tail.next = temp;</span><br><span class="line">                        tail = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> ll = head.next.idx;</span><br><span class="line">                    <span class="keyword">if</span> ( ll != -<span class="number">1</span> ) &#123;</span><br><span class="line">                        <span class="keyword">int</span> len = i - ll + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> ( len &lt; min ) &#123;</span><br><span class="line">                            min = len;</span><br><span class="line">                            l = ll;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                relay = relay.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( l == -<span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ss, l, min);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：O(mn)。<br>运行时间：165ms。<br>击败：3.94%</p>
<p><img src="/images/leetcode/76_1.png" alt="image"></p>
<p>显然复杂度太高，别人都在10ms内，这代码辣鸡。</p>
<hr>
<p>代码2：</p>
<p>看了别人的代码，总于明白他们是如何做到<strong>O(n)</strong>。</p>
<p>首先，这里的字符其实只有<strong>Ascii</strong>码里面的前<strong>128</strong>个字符，其次<strong>java</strong>里面的<strong>char</strong>是可以之间当成<strong>int</strong>来使用的，
那么这里在匹配字符的时候，就可以直接使用<strong>散列表</strong>的思想，申请一个<strong>128长的int数组就好了</strong>。</p>
<p>另外，即使能在<strong>O(1)</strong>的时间将一个字符匹配到它该在的位置上，那么怎么去找这么一个最小窗口又是一个大问题。</p>
<p>这里的思路实在是巧，首先统计字符集合之后，<strong>int[128]</strong>上就记录了每一个字符的个数。要想在<strong>O(n)</strong>的时间内完成，
那么肯定又要用到滑动窗的思路来统计。那么定义这个窗口，<strong>窗口的左边界到右边界内的字符能够满足字符集合，并且左边界一定不能再向右移动</strong>。</p>
<p>同<strong>30题</strong>很像，但是这里更加巧妙，只需要在这么个<strong>int[128]</strong>的数组上进行操作就行：</p>
<ul>
<li>定义距离dis，窗口里面每少一个字符，距离加一，初始化距离为字符集合的总大小。</li>
<li>右边界右移，输入一个字符，<strong>int[128]</strong>上对应位置值<strong>减1</strong>，然后判断：<ul>
<li>如果这个位置的值<strong>大于等于0</strong>，说明这个位置是集合中有的字符，并且现在窗中个数还不足，所以<strong>dis减1</strong>。</li>
<li>如果这个位置的值<strong>小于0</strong>，那么这个位置：<ul>
<li>本来就不是集合中的字符，不操作。</li>
<li>是集合中的字符，但是窗中这个字符太多，以至于<strong>为负</strong>，同样不需要操作。</li>
</ul>
</li>
</ul>
</li>
<li>当前距离<strong>dis为0</strong>，说明窗中包含了集合中所有字符，但是可能有多的，于是尝试移动左边界，并保持<strong>dis为0</strong>：<ul>
<li>设左边界对应字符<strong>A</strong>：<ul>
<li>如果此时<strong>A</strong>在<strong>int[128]</strong>上对应位置值<strong>等于0</strong>，说明此字符是集合需要的字符（否则这个位置的值该为负），并且现在的个数刚刚好，那么左边界不移动。</li>
<li>否则<strong>int[128]</strong>上对应位置值<strong>减1</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>dis等于0，尝试更新最小窗口。</li>
</ul>
<p>通过上面的方法，代码变得非常简单，并且复杂度<strong>O(n)</strong>，额外操作也非常少，甚至空间开销都是固定的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>, bound = t.length(); i &lt; bound; i++ )</span><br><span class="line">            counts[t.charAt(i)]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dis = t.length(), min = Integer.MAX_VALUE, l = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>, ll = <span class="number">0</span>, bound = s.length(); i &lt; bound; i++ ) &#123;</span><br><span class="line">            counts[s.charAt(i)]--;</span><br><span class="line">            <span class="keyword">if</span> ( counts[s.charAt(i)] &gt;= <span class="number">0</span> )</span><br><span class="line">                dis--;</span><br><span class="line">            <span class="keyword">while</span> ( dis == <span class="number">0</span> &amp;&amp; counts[s.charAt(ll)] != <span class="number">0</span>)</span><br><span class="line">                counts[s.charAt(ll++)]++;</span><br><span class="line">            <span class="keyword">if</span> ( dis == <span class="number">0</span> &amp;&amp; (i - ll + <span class="number">1</span>) &lt; min ) &#123;</span><br><span class="line">                min = i - ll + <span class="number">1</span>;</span><br><span class="line">                l = ll;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == -<span class="number">1</span> ? <span class="string">&quot;&quot;</span> : s.substring(l, l + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：O(n)。<br>运行时间：4ms。<br>击败：90.25%</p>
<p><img src="/images/leetcode/76_2.png" alt="image"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>python argparse 模块笔记</title>
    <url>/2017/09/26/2017-09-26-python-argparse/</url>
    <content><![CDATA[<p><strong>argparse</strong>是python中的一个模块，参考官方文档来理解它
<a href="https://docs.python.org/3/library/argparse.html?highlight=argparse#module-argparse">argparse — Parser for command-line options, arguments and sub-commands</a></p>
<p>第一句介绍就是<code>The argparse module makes it easy to write user-friendly command-line interfaces</code>，
所以这个模块是用于写命令行接口的，使得脚本友好的从命令行传入参数。</p>
<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br></pre></td></tr></table></figure>
<h2 id="创建一个parser对象"><a href="#创建一个parser对象" class="headerlink" title="创建一个parser对象"></a>创建一个parser对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser = argparse.ArgumentParser()</span><br></pre></td></tr></table></figure>
<h2 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;integers&#x27;</span>, metavar=<span class="string">&#x27;N&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, nargs=<span class="string">&#x27;+&#x27;</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;an integer for the accumulator&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里添加了一个叫做<code>integers</code>的参数，它的类型是<code>int</code>，<br><code>metavar</code>是用于在help里面来表示这个数的，本来是help里面会使用<code>integers</code>这个名字，这里就会被替换为<code>N</code>，<br><code>nargs</code>表示这个参数后面可以跟的输入的个数，这里的’+’表示一个或者多个，<br><code>help</code>是在打印help信息时给出的提示。</p>
<p> 例如下面脚本：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--foo&#x27;</span>, nargs=<span class="number">2</span>, metavar=<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;bar&#x27;</span>, nargs=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args)</span><br></pre></td></tr></table></figure>
<p>先在命令行中调用帮助信息，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python .\test.py -h</span><br><span class="line"></span><br><span class="line">usage: test.py [-h] [--foo f f] bar</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  bar</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help  show this help message and exit</span><br><span class="line">  --foo f f</span><br></pre></td></tr></table></figure>
<p>输入正确的参数个数和错误的参数个数，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python .\test.py --foo a b 1</span><br><span class="line"></span><br><span class="line">Namespace(bar&#x3D;[&#39;1&#39;], foo&#x3D;[&#39;a&#39;, &#39;b&#39;])</span><br><span class="line"></span><br><span class="line">$ python .\test.py --foo a b</span><br><span class="line"></span><br><span class="line">usage: test.py [-h] [--foo FOO FOO] bar</span><br><span class="line">test.py: error: the following arguments are required: bar</span><br><span class="line"></span><br><span class="line">$ python .\test.py --foo a b c 2</span><br><span class="line"></span><br><span class="line">usage: test.py [-h] [--foo FOO FOO] bar</span><br><span class="line">test.py: error: unrecognized arguments: 2</span><br></pre></td></tr></table></figure>
<p>另外有时候，可能需要使用下面的函数来返回输入参数，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FLAGS, unparsed = parser.parse_known_args()</span><br></pre></td></tr></table></figure>
<p>这里的意思就是说对于认识的参数，存到<code>FLAGS</code>里面，对于不认识的参数，存到<code>unparsed</code>里面。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.jianshu.com/p/a50aead61319">argparser模块学习</a></p>
]]></content>
      <categories>
        <category>python modules</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda 使用记录</title>
    <url>/2017/09/18/2017-09-18-anaconda/</url>
    <content><![CDATA[<hr>
<h2 id="Anacanda是什么？"><a href="#Anacanda是什么？" class="headerlink" title="Anacanda是什么？"></a>Anacanda是什么？</h2><p>目前把它看成一个python的发行版，它的方便之处在于它自带了很多第三方包，另外它可以方便的进行python的版本管理。</p>
<hr>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用环境 <strong>window10</strong>。</p>
<p>官网上面下载安装即可<a href="https://www.anaconda.com/download/">anaconda下载</a>。</p>
<hr>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>将安装目录加入环境变量即可，如果之前安装配置过<strong>python</strong>，需要把之前的path给删了，不然用的还是以前的python。</p>
<p><img src="/images/guide/anaconda_1.png" alt="image"></p>
<p>打开cmd，输入python，</p>
<p><img src="/images/guide/anaconda_2.png" alt="image"></p>
<p>ok！</p>
<hr>
<h2 id="安装TensorFlow"><a href="#安装TensorFlow" class="headerlink" title="安装TensorFlow"></a>安装TensorFlow</h2><p>anaconda它本身不带TensorFlow，需要进行安装，</p>
<p>执行anaconda命令需要使用<code>anaconda prompt</code>来打开cmd（可能需要管理员身份运行，另外最好先不要开代理）。</p>
<p><img src="/images/guide/anaconda_3.png" alt="image"></p>
<p>首先更换镜像源，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br><span class="line">$ conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>
<p>使用<code>conda info</code>可以看到当前的一些配置信息，</p>
<p><img src="/images/guide/anaconda_4.png" alt="image"></p>
<p>上面可以看到源以及更换成功。</p>
<p>然后搜索一下TensorFlow版本，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ anaconda search -t conda tensorflow</span><br></pre></td></tr></table></figure>
<p>这里选择了<code>anaconda/tensorflow 1.2.1</code>这个版本，输入下面命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ anaconda show anaconda&#x2F;tensorflow</span><br><span class="line"></span><br><span class="line">Using Anaconda API: https:&#x2F;&#x2F;api.anaconda.org</span><br><span class="line">Name:    tensorflow</span><br><span class="line">Summary: TensorFlow is a machine learning library</span><br><span class="line">Access:  public</span><br><span class="line">Package Types:  conda</span><br><span class="line">Versions:</span><br><span class="line">   + 0.10.0rc0</span><br><span class="line">   + 1.0.1</span><br><span class="line">   + 1.1.0</span><br><span class="line">   + 1.2.1</span><br><span class="line"></span><br><span class="line">To install this package with conda run:</span><br><span class="line">     conda install --channel https:&#x2F;&#x2F;conda.anaconda.org&#x2F;anaconda tensorflow</span><br></pre></td></tr></table></figure>
<p>然后就输入上面给出的<code>conda install --channel https://conda.anaconda.org/anaconda tensorflow</code>来进行安装，</p>
<p>这里速度非常慢，因为清华源上面没有这个版本，安装N次失败了。</p>
<p>最后换了<code>dhirschfeld/tensorflow</code>这个版本，终于它在清华源上面有，安装就快多了，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ conda install --channel https:&#x2F;&#x2F;conda.anaconda.org&#x2F;dhirschfeld tensorflow</span><br><span class="line"></span><br><span class="line">The following NEW packages will be INSTALLED:</span><br><span class="line"></span><br><span class="line">    backports.weakref: 1.0rc1-py36_0     https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free</span><br><span class="line">    libprotobuf:       3.2.0-vc14_0      https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free [vc14]</span><br><span class="line">    markdown:          2.6.9-py36_0      https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free</span><br><span class="line">    protobuf:          3.2.0-py36_0      https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free</span><br><span class="line">    tensorflow:        1.2.1-py36_0      https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free</span><br><span class="line"></span><br><span class="line">conda-env-2.6. 100% |###############################| Time: 0:00:00 994.18 kB&#x2F;s</span><br><span class="line">vs2015_runtime 100% |###############################| Time: 0:00:01   1.27 MB&#x2F;s</span><br><span class="line">libprotobuf-3. 100% |###############################| Time: 0:00:08   1.12 MB&#x2F;s</span><br><span class="line">backports.weak 100% |###############################| Time: 0:00:00   0.00  B&#x2F;s</span><br><span class="line">html5lib-0.999 100% |###############################| Time: 0:00:00   1.02 MB&#x2F;s</span><br><span class="line">protobuf-3.2.0 100% |###############################| Time: 0:00:00 808.75 kB&#x2F;s</span><br><span class="line">tensorflow-1.2 100% |###############################| Time: 0:00:12   1.72 MB&#x2F;s</span><br><span class="line">conda-4.3.13.p 100% |###############################| Time: 0:01:52   5.10 kB&#x2F;s</span><br><span class="line">conda-4.3.13.p 100% |###############################| Time: 0:00:48  11.97 kB&#x2F;s</span><br></pre></td></tr></table></figure>
<p>打开python，可以看到TensorFlow已经安装完成，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ C:\Users\龙\Desktop&gt; python</span><br><span class="line">Python 3.6.1 |Anaconda custom (64-bit)| (default, May 11 2017, 13:25:24) [MSC v.1900 64 bit (AMD64)] on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br><span class="line">&gt;&gt;&gt; a &#x3D; tf.constant(2, name&#x3D;&#39;a&#39;)</span><br><span class="line">&gt;&gt;&gt; b &#x3D; tf.constant(3, name&#x3D;&#39;b&#39;)</span><br><span class="line">&gt;&gt;&gt; c &#x3D; a * b + b</span><br><span class="line">&gt;&gt;&gt; d &#x3D; tf.placeholder(tf.int32, name &#x3D; &#39;d&#39;)</span><br><span class="line">&gt;&gt;&gt; f &#x3D; d + c</span><br><span class="line">&gt;&gt;&gt; init &#x3D; tf.global_variables_initializer()</span><br><span class="line">&gt;&gt;&gt; with tf.Session() as session:</span><br><span class="line">...     session.run(init)</span><br><span class="line">...     print(session.run(f, feed_dict &#x3D; &#123;d: 100&#125;))</span><br><span class="line">...</span><br><span class="line">109</span><br></pre></td></tr></table></figure>
<p>同样的，使用<code>conda list</code>命令也可以看到安装的包中出现了<strong>TensorFlow</strong>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ conda list</span><br></pre></td></tr></table></figure>
<p><img src="/images/guide/anaconda_5.png" alt="image"></p>
<p><strong>注：最终也没能用anaconda装上TensorFlow_1.3.0，最后用回了原始的python3.6.1，使用pip3装的TensorFlow…</strong></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/willnote/p/6746499.html">Anaconda+Tensorflow环境安装与配置</a></p>
]]></content>
      <categories>
        <category>guide</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 84 Largest Rectangle in Histogram</title>
    <url>/2017/09/28/2017-09-28-leetcode_84/</url>
    <content><![CDATA[<p><strong>Descriptin:</strong></p>
<blockquote>
<blockquote>
<p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
</blockquote>
</blockquote>
<p><img src="/images/leetcode/84_1.png" alt="image"></p>
<p><img src="/images/leetcode/84_2.png" alt="image"></p>
<hr>
<p>题目理解：本题需要从柱状图中找出最大的长方形，求解当然不难，但是想要降低复杂度就很难。</p>
<hr>
<p>代码一：</p>
<p>最简单的求解方法，遍历柱状图，对每一根柱，求它的最大长方形，所以也需要一个循环来做，于是复杂度O(n^2)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, n = heights.length;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ( left &gt;= <span class="number">0</span> &amp;&amp; heights[left] &gt;= heights[i] )</span><br><span class="line">                left--;</span><br><span class="line">            <span class="keyword">while</span> ( right &lt; n &amp;&amp; heights[right] &gt;= heights[i] )</span><br><span class="line">                right++;</span><br><span class="line">            <span class="keyword">int</span> area = (right - left - <span class="number">1</span>) * heights[i];</span><br><span class="line">            <span class="keyword">if</span> ( max &lt; area )</span><br><span class="line">                max = area;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是代码超时，最后一个用例全是<strong>1</strong>，卡在上面了。</p>
<hr>
<p>代码二：</p>
<p>这个代码是自己想了很久写出来的，看了别人的才发现自己有些地方想偏了，所以才想了这么久。</p>
<p>想法是，由于在上面遍历过程中，老是重复一些东西，所以这里对已经遍历过的部分进行一定的处理，并且计算方式有所变化。</p>
<p>遍历到一个柱时，它前面的柱体一定是削平了的。</p>
<p>如下图，</p>
<p><img src="/images/leetcode/84_3.png" alt="image"></p>
<p>在遍历到下标<strong>3</strong>时，把前面变成<strong>2</strong>削成了<strong>1</strong>，同时下标<strong>1</strong>的<strong>1</strong>值也不用再保存了，
因为后面的柱体和它组成的长方形一定没有与前面的“<strong>1</strong>”大。</p>
<p>同样的，遍历到下标<strong>5</strong>时会变成下面的形式，</p>
<p><img src="/images/leetcode/84_4.png" alt="image"></p>
<p>前面只是保证了前面的柱体是削平的，那么时候去计算长方形的大小呢？当遇到<strong>下坡</strong>时就去计算，</p>
<p>比如当遍历到<strong>2</strong>的时候，</p>
<p><img src="/images/leetcode/84_5.png" alt="image"></p>
<p>它前面的柱体呈现一个<strong>1,5,6</strong>的形式，由于<strong>5,6</strong>比<strong>2</strong>高，那么就要去把它们削到高度为<strong>2</strong>，
在削的时候，就去计算被削的柱体它能组成的长方形大小。
<strong>比如高度为6的柱体，因为它是被削平的，所以它到当前高度2的柱体之间如果有别的柱体，也一定是至少比6要高的。</strong>
<strong>所以就长方形的长度就等于6到2之间的间隔，乘上6</strong>。</p>
<p>这样每一个柱体只会计算一次长方形的大小，并且这个过程是没有查找的操作的。</p>
<p>所以复杂度为O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, flen = <span class="number">0</span>, n = heights.length;</span><br><span class="line">        <span class="keyword">int</span>[][] front = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( flen == <span class="number">0</span> || heights[i] &gt; front[flen-<span class="number">1</span>][<span class="number">0</span>] ) &#123;</span><br><span class="line">                front[flen][<span class="number">0</span>] = heights[i];</span><br><span class="line">                front[flen++][<span class="number">1</span>] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> j = flen - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> ( j &gt;= <span class="number">0</span> &amp;&amp; front[j][<span class="number">0</span>] &gt; heights[i] ) &#123;</span><br><span class="line">                    <span class="keyword">int</span> area = (i - front[j][<span class="number">1</span>]) * front[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span> ( area &gt; max )</span><br><span class="line">                        max = area;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( j == -<span class="number">1</span> || front[j][<span class="number">0</span>] &lt; heights[i] )</span><br><span class="line">                    j++;</span><br><span class="line">                front[j][<span class="number">0</span>] = heights[i];</span><br><span class="line">                flen = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = flen - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( j &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">int</span> area = (n - front[j][<span class="number">1</span>]) * front[j][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> ( area &gt; max )</span><br><span class="line">                max = area;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/leetcode/84_6.png" alt="image"></p>
<hr>
<p>代码三：</p>
<p>这个是看的别人的代码，这个思想很好，而且正好是从代码一最简单形式变化而来的，不得不佩服。</p>
<p>考虑到代码一每次都重复去寻找左右比当前柱体矮的柱体，它就相当于进行了预处理，先将一个柱体的左右比它矮的柱体找到了，
然后就可以快速的计算了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] lessFromLeft = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &gt;= <span class="number">0</span> &amp;&amp; height[p] &gt;= height[i]) &#123;</span><br><span class="line">        p = lessFromLeft[p];</span><br><span class="line">    &#125;</span><br><span class="line">    lessFromLeft[i] = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的就是上面的代码，它就是去寻找当前柱体左边的第一个比它矮的柱体，使用了一个数组进行保存柱体下标，
它的核心思想是，前面的柱体已经找到了比自己矮的柱体的位置，那么当前柱体就可以利用到这个信息，
快速的找到比自己矮的柱体。就如写这个代码的那个人所说，这里的思想有点像<strong>KMP</strong>。</p>
<p>这里的这种将问题拆分，然后进行求解的思想值得学习。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, n = heights.length;</span><br><span class="line">    <span class="keyword">int</span>[] small_left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] small_right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    small_left[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    small_right[n-<span class="number">1</span>] = n;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( idx &gt;= <span class="number">0</span> &amp;&amp; heights[idx] &gt;= heights[i] )</span><br><span class="line">            idx = small_left[idx];</span><br><span class="line">        small_left[i] = idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( idx &lt; n &amp;&amp; heights[idx] &gt;= heights[i] )</span><br><span class="line">            idx = small_right[idx];</span><br><span class="line">        small_right[i] = idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> area = (small_right[i] - small_left[i] - <span class="number">1</span>) * heights[i];</span><br><span class="line">        <span class="keyword">if</span> ( area &gt; max )</span><br><span class="line">            max = area;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时间：5ms。<br>复杂度：O(n)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 85 Maximal Rectangle</title>
    <url>/2017/09/28/2017-09-28-leetcode_85/</url>
    <content><![CDATA[<p><strong>Description:</strong></p>
<blockquote>
<blockquote>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.  </p>
<p>For example, given the following matrix:</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>Return 6.</p>
</blockquote>
</blockquote>
<hr>
<p>题目理解：</p>
<p>在矩阵中去找最小的长方形，初步想法是尝试用动态规划来做，但是实际上是不行的，
因为原问题的最优解好像并不能由它的子问题的最优解来构成。</p>
<p>然后就想能不能用什么搜索的方法来寻找，通过逐步扩大搜索范围来求解，并不知道怎么做。</p>
<p>突然想到将两行加在一起，例如下面两行，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br></pre></td></tr></table></figure>
<p>加起来得到，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 0 2 1 1</span><br></pre></td></tr></table></figure>
<p>那么这两行的最大长方形要不就是<strong>2</strong>，要不就是衡向的三个<strong>1</strong>，那么如果是三行呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br></pre></td></tr></table></figure>
<p>加起来得到，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 1 3 2 2</span><br></pre></td></tr></table></figure>
<p>从这个结果可以看出，这里就将上面的矩阵表现成为了一个<strong>柱状图</strong>，值就是它的高度！！！</p>
<p>那么这不正好就是上一题<strong>84题</strong>所做的东西，求柱状图中的最大长方形。</p>
<p>于是就变得十分简单，将上一题的代码直接拿过来，就解决了问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] row_sum = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ )</span><br><span class="line">                row_sum[j] = (<span class="string">&#x27;0&#x27;</span> == matrix[i][j]) ? <span class="number">0</span> : row_sum[j] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> area = largestRectangleArea(row_sum);</span><br><span class="line">            <span class="keyword">if</span> ( area &gt; max )</span><br><span class="line">                max = area;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, n = heights.length;</span><br><span class="line">        <span class="keyword">int</span>[] small_left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] small_right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        small_left[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        small_right[n-<span class="number">1</span>] = n;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ( idx &gt;= <span class="number">0</span> &amp;&amp; heights[idx] &gt;= heights[i] )</span><br><span class="line">                idx = small_left[idx];</span><br><span class="line">            small_left[i] = idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ( idx &lt; n &amp;&amp; heights[idx] &gt;= heights[i] )</span><br><span class="line">                idx = small_right[idx];</span><br><span class="line">            small_right[i] = idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            <span class="keyword">int</span> area = (small_right[i] - small_left[i] - <span class="number">1</span>) * heights[i];</span><br><span class="line">            <span class="keyword">if</span> ( area &gt; max )</span><br><span class="line">                max = area;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于上一题的代码复杂度为O(n)，那么这里的复杂度就是O(n^2)。<br>运行时间：8ms。<br>击败：95.90%</p>
<p><img src="/images/leetcode/85_1.png" alt="image"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>python pip 安装小指南</title>
    <url>/2017/10/03/2017-10-03-pip-install/</url>
    <content><![CDATA[<h2 id="原始命令"><a href="#原始命令" class="headerlink" title="原始命令"></a>原始命令</h2><p>首先，在python安装目录下的<code>Scripts</code>目录下，有<code>pip</code>和<code>pip3</code>两个命令。这两个命令的区别是，
如果电脑上安装了python2，那么<code>pip</code>安装的包会在python2下面，而<code>pip3</code>会在python3下面。</p>
<p>当然如果没有python2，那么它们是没有区别的。</p>
<p>安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install package</span><br><span class="line"></span><br><span class="line">$ pip3 install package</span><br></pre></td></tr></table></figure>
<p>卸载命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip uninstall package</span><br></pre></td></tr></table></figure>
<p>升级命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install --upgrade package</span><br></pre></td></tr></table></figure>
<p>查看可以更新的包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip list --outdated</span><br></pre></td></tr></table></figure>
<p>查看某个已经安装的包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip show --files SomePackage</span><br></pre></td></tr></table></figure>
<h2 id="国内源"><a href="#国内源" class="headerlink" title="国内源"></a>国内源</h2><p>上面安装默认用的不是国内源，可能会很慢，那么就要用到国内源。</p>
<p>一般使用<strong>豆瓣源</strong>或者<strong>清华源</strong>，</p>
<blockquote>
<p><a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a><br><a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
</blockquote>
<p>在pip命令中加入<code>-i 源地址</code>就行，例如，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip3 install -i http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F; package</span><br></pre></td></tr></table></figure>
<p>（今天清华源莫名奇妙崩了，不知道为何）</p>
<h2 id="安装失败问题"><a href="#安装失败问题" class="headerlink" title="安装失败问题"></a>安装失败问题</h2><p>今天在安装<code>scripy</code>时，不知道出了什么问题，安装不上，百度后发现这个直接安装就是不行，</p>
<p>先看官网说明<a href="https://www.scipy.org/install.html">Installing via pip</a></p>
<p>其中有一句：</p>
<blockquote>
<p>pip does not work well for Windows because the standard pip package index site, PyPI, does not yet have Windows wheels for some packages, such as SciPy.</p>
</blockquote>
<p><strong>wtf</strong>，那么windows该怎么安装啊，靠。</p>
<p>百度一下，发现通过以下网站来解决问题，</p>
<p><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy">Unofficial Windows Binaries for Python Extension Packages</a></p>
<p>安装它的说明，先安装<code>wheel</code>，然后下载<code>numpy</code>安装，再下载<code>scipy</code>安装就行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip3 install wheel</span><br></pre></td></tr></table></figure>
<p>然后将对应版本的安装包下载下来进行安装，我这里选择的是<code>scipy-1.0.0rc1-cp36-cp36m-win_amd64.whl</code>，
下载之后，到对应的文件目录执行下面的命令即可安装（numpy早就已经安装了），</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip3 install scipy-1.0.0rc1-cp36-cp36m-win_amd64.whl</span><br></pre></td></tr></table></figure>
<p><strong>然后sklearn还是不能用！！！</strong></p>
<p>所以如果使用<strong>whl</strong>安装，那么最好这几个依赖包都使用<strong>whl</strong>来安装，这样才能没有问题！！！</p>
<p>于是，下载对应的<code>numpy</code>、<code>scipy</code>、<code>matplotlib</code>和<code>scikit_learn</code>的<strong>whl</strong>包来安装。</p>
<p>首先卸载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip3 uninstall scikit_learn</span><br><span class="line">$ pip3 uninstall matplotlib</span><br><span class="line">$ pip3 uninstall scipy</span><br><span class="line">$ pip3 uninstall numpy</span><br></pre></td></tr></table></figure>
<p>然后安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip3 install numpy-1.13.3+mkl-cp36-cp36m-win_amd64.whl</span><br><span class="line">$ pip3 install scipy-1.0.0rc1-cp36-cp36m-win_amd64.whl</span><br><span class="line">$ pip3 install matplotlib-2.1.0rc1-cp36-cp36m-win_amd64.whl</span><br><span class="line">$ pip3 install scikit_learn-0.19.0-cp36-cp36m-win_amd64.whl</span><br></pre></td></tr></table></figure>
<p>终于ok了，我去。</p>
<h2 id="安装失败问题-1"><a href="#安装失败问题-1" class="headerlink" title="安装失败问题"></a>安装失败问题</h2><p>安装的时候遇到了UnicodeDecodeError，提示<code>UTF-8</code>解码有问题。</p>
<p>这是因为windows的shell的编码问题，它使用的是<code>gbk</code>？</p>
<p>总之切换一下shell的代码页就好了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chcp 65001</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>guide</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>java使用poi读写excel文件</title>
    <url>/2017/10/10/2017-10-10-java-poi/</url>
    <content><![CDATA[<p>在java中使用poi来读取excel文件是一种比较普遍的做法，这里记录一下代码，免得以后又忘记如何读写excel文件。</p>
<hr>
<h2 id="下载poi"><a href="#下载poi" class="headerlink" title="下载poi"></a>下载poi</h2><p>直接取官网下载poi包，<a href="https://poi.apache.org/download.html">Apache POI - Download Release Artifacts</a>。</p>
<p>这里下载的是最新的3.17版本。</p>
<p><img src="/images/guide/java-poi_1.png" alt="image"></p>
<p>可以看到里面有很多jar包。</p>
<hr>
<h2 id="读取excel文件"><a href="#读取excel文件" class="headerlink" title="读取excel文件"></a>读取excel文件</h2><p>在读excel文件的过程中，只需要用到<code>poi-3.17.jar</code>和<code>poi-ooxml-3.17.jar</code>两个jar包就够了。</p>
<p>在官方的
<a href="https://poi.apache.org/spreadsheet/quick-guide.html">Quick Guide</a>
中有读取文件以及读取单元格的例子，依照它就可以写出读取excel文件的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.poi.openxml4j.exceptions.InvalidFormatException;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将Excel按照行解析</span></span><br><span class="line"><span class="comment"> * 希望第一行是标题，重第二行开始是数据，格式不要乱啊</span></span><br><span class="line"><span class="comment"> * 解析给定的 excel 文件，然后返回 excel 的所有内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017-10-10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoiWithExcel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入excel文件的路径（.xls结尾的文件），输出文件内容，第一行是 title，剩下的行是内容。</span></span><br><span class="line"><span class="comment">     * 注意，这里认为文件只有一个 sheet 。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String[]&gt; parseExcelData(String path) <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        File input = <span class="keyword">new</span> File(path);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(input);</span><br><span class="line">        List&lt;String[]&gt; contents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Workbook workbook = <span class="keyword">null</span>;</span><br><span class="line">        Sheet sheet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            workbook = WorkbookFactory.create(fis);</span><br><span class="line">            sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidFormatException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row_num = sheet.getPhysicalNumberOfRows(); <span class="comment">//获取总行数</span></span><br><span class="line">        <span class="comment">/************* 遍历第一行，获取 title  ***********/</span></span><br><span class="line">        Row row = sheet.getRow(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ( row == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> contents;</span><br><span class="line">        <span class="keyword">int</span> col_num = row.getPhysicalNumberOfCells(); <span class="comment">//获取总列数</span></span><br><span class="line">        String[] content = <span class="keyword">new</span> String[col_num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span> ; col &lt; col_num ; col++ ) &#123;</span><br><span class="line">            Cell cell = row.getCell(col);</span><br><span class="line">            content[col] = myGetCellValue(cell);</span><br><span class="line">        &#125;</span><br><span class="line">        contents.add(content);</span><br><span class="line">        <span class="comment">/************* 遍历剩余行，读取内容  ***********/</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> r = <span class="number">1</span>; r &lt; row_num; r++ ) &#123;</span><br><span class="line">            row = sheet.getRow(r);</span><br><span class="line">            content = <span class="keyword">new</span> String[col_num];</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> col = <span class="number">0</span>; col &lt; col_num; col++ ) &#123;</span><br><span class="line">                Cell cell = row.getCell(col);</span><br><span class="line">                content[col] = myGetCellValue(cell);</span><br><span class="line">            &#125;</span><br><span class="line">            contents.add(content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            workbook.close();</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> contents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照 单元格 的 类型 来解析它其中的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cell</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">myGetCellValue</span><span class="params">(Cell cell)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( cell == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String cellValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 在官方的说明中，它使用的是 cell.getCellType(), 但是这个方法是过时的，</span></span><br><span class="line">        <span class="comment">// 所以这里使用 cell.getCellTypeEnum() 来取代了它。</span></span><br><span class="line">        <span class="keyword">switch</span>(cell.getCellTypeEnum()) &#123;</span><br><span class="line">            <span class="keyword">case</span> STRING: <span class="comment">//文本</span></span><br><span class="line">                cellValue = cell.getStringCellValue();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NUMERIC: <span class="comment">//数字、日期</span></span><br><span class="line">                <span class="keyword">if</span> (DateUtil.isCellDateFormatted(cell)) &#123;</span><br><span class="line">                    cellValue = cell.getDateCellValue().toString();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cellValue = String.valueOf(cell.getNumericCellValue());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOLEAN: <span class="comment">//布尔型</span></span><br><span class="line">                cellValue = String.valueOf(cell.getBooleanCellValue());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FORMULA: <span class="comment">//公式</span></span><br><span class="line">                cellValue = cell.getCellFormula();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cellValue = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cellValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>guide</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络（CNN）笔记</title>
    <url>/2017/11/10/2017-11-10-CNN/</url>
    <content><![CDATA[<hr>
<h2 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h2><p><code>Convolutional Neural Networks</code>(CNN)，卷积神经网络主要是为了去解决计算机视觉上的问题，实际上，就是因为
CNN在计算机视觉上的成功应用，才让它变得这么火。</p>
<p>学习CNN，不光是为了在计算机视觉上的处理，更为重要的是去理解神经网络中蕴含的道理，事实上，
会觉得神经网络越来越像是一个搭积木的过程，有着各式各样的积木，你以随意的顺序或结构去搭建它们，
然后就得到了各式各样的神经网络类型。</p>
<h2 id="CNN的结构"><a href="#CNN的结构" class="headerlink" title="CNN的结构"></a>CNN的结构</h2><p>CNN其实与全连接神经网络并没有什么太大的区别，它只是在全连接的神经网络中加入了一种新的连接层，<strong>卷积层</strong>。</p>
<p><img src="/images/coursera/CNN_1.png" alt="image" title="from Andrew Ng"></p>
<p>如上图，网络先进过一层卷积层（CONV），然后通过一个RELU激活函数，再通过一个POOL层，最后输入到后面的两层全连接层。</p>
<p>通常CNN的结构就与上图一样，网络首先是一系列的卷积层（包括激活函数与POOL），在网络的最后跟着连接几层的全连接层。</p>
<h2 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h2><p>这里引用到吴恩达课程作业中的一段演示视频，这一段视频十分的形象，这里引用到它：</p>
<center>
<video width="100%" height="100%" src="/images/coursera/conv_kiank.mp4" type="video/mp4" controls></video>
</center>


<p>如上面的视频所示，可以把输入层看作一个矩阵，它的维度为<code>n_H_prev * n_W_prev * n_C_prev</code>（这里先考虑单独一个样本的情况），
如果这是从输入层开始的话，其中<code>n_H_prev * n_W_prev</code>就可以看成输入图片的<strong>长宽</strong>，
那么<code>n_C_prev</code>在图片是彩色的情况下就等于<strong>3</strong>，也就是<strong>RGB</strong>三个通道，如果是灰度图，那它就为<strong>1</strong>。
从英文上来说就是<strong>Height、Weight、Channel</strong>。</p>
<p>从视频中可以看到这个卷积层中有两个<strong>Filter</strong>，它们之间的运算完全没有关系，对于一个<strong>Filter</strong>来说，它在输入矩阵上从左上角开始，
左右滑动求取到值，每一次滑动就计算得到一个对应的值。在视频中它计算完毕后就得到一个<strong>3x3</strong>的输出。</p>
<p>通常情况下，所有<strong>Filter</strong>的维度都是一样的，视频中<strong>Filter</strong>的维度为<code>f * f * n_C_prev</code>，它的深度要与输入的<strong>Channel</strong>数一致
才能正常的进行计算，所有这里它的第三个维度为<strong>n_C_prev</strong>。设<strong>Filter</strong>对应的输入矩阵上的小格子为 $X$，<strong>Filter</strong>表示为$F$，
那么它们之间的计算公式为：</p>
<script type="math/tex; mode=display">
output = bias + \sum_i^f \sum_j^f \sum_k^{C} X_{(i,j,k)} * F_{(i,j,k)}</script><p>简单来说，就是两个矩阵做点积，然后求和，最后加上一个bias。那么对于一个<strong>Filter</strong>来说，
它就有 $f \times f \times C + 1$ 个参数。</p>
<p>最后将每一个<strong>Filter</strong>计算得到的结果作为一个<strong>Channel</strong>，叠在一起，就组成了最后的输出结果。</p>
<h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><p>通过上面的计算步骤，只要<strong>Filter</strong>的长宽不是<strong>1</strong>，输出矩阵的长与宽就一定比输入矩阵的长与宽要小，并且对于矩阵角上的值来说，
它们参与运算的次数是没有矩阵内部的值参与的次数多的。</p>
<p>为了不让矩阵长与宽一直变小，让所有值相对公平的参与计算，就可以使用到<strong>Padding</strong>操作。</p>
<p><img src="/images/coursera/CNN_2.png" alt="image" title="from Andrew Ng"></p>
<p>它的操作十分简单，就是在矩阵四周补零就可以了。</p>
<p>通常的深度学习框架中，例如TensorFlow，它在卷积层的参数中可以直接设置<strong>padding</strong>，它有两个取值<code>valid</code>和<code>same</code>，
其中<code>valid</code>就表示不进行padding，<code>same</code>则是表示进行padding，并且padding的大小刚好保证输入输出的维度大小相同。</p>
<h3 id="stride"><a href="#stride" class="headerlink" title="stride"></a>stride</h3><p>如上面所说，<strong>Filter</strong>在图片上进行滑动，那么滑动的距离就由<strong>stride</strong>来定义，通常它取值为<strong>1</strong>或<strong>2</strong>。</p>
<h3 id="输出维度"><a href="#输出维度" class="headerlink" title="输出维度"></a>输出维度</h3><p>进过上面的一顿操作，输出的维度为多少呢？随便就可以推出来，计算输出的维度公式如下：</p>
<script type="math/tex; mode=display">
n_H = \left \lfloor \frac{n_{H_{prev}} - f + 2 \times pad }{ stride } \right \rfloor + 1</script><h2 id="POOL层"><a href="#POOL层" class="headerlink" title="POOL层"></a>POOL层</h2><p><strong>POOL层</strong>总是接在卷积层的后面，那么它到的是在干嘛的，它为什么要取名字叫做POOL？在学习卷积神经网络之前一直以为这一层很复杂，
但是实际上，这一层的操作十分简单。</p>
<p><img src="/images/coursera/CNN_3.png" alt="image" title="from Andrew Ng"></p>
<p>如上图所示，左边是<code>Max Pool</code>，右边是<code>Average Pool</code>，它和卷积层的操作几乎一样，也是滑动，每滑动一次计算出一个值。</p>
<p>它与卷积层操作的区别是它每次取得是区域内的最大值或者是平均值，也就是它计算出的结果只与输入矩阵有关系，
因为只有输入矩阵的值会参与运算。<strong>另外</strong>，它没有通道的概念，也就是它只有一个通道，所以它不是同时对输入矩阵的多个通道进行操作，
而是对输入的每个通道分别进行操作。</p>
<p>所以，输入与输出的维度进行比较的话，长宽通常会发生变化，而深度不会发生变化。</p>
<p>实际上，通常把POOL层理解为降低数据维度的方法。</p>
<h2 id="卷积层在做神马？"><a href="#卷积层在做神马？" class="headerlink" title="卷积层在做神马？"></a>卷积层在做神马？</h2><p>在图像中，可以把每一个<strong>Filter</strong>看做一个特征的识别器（毕竟人家名字就叫做<strong>Filter</strong>），或许某个<strong>Filter</strong>的作用就是识别
一条直线，或者又是识别一个直角等。总之可以把一个<strong>Filter</strong>看成一个特征的识别。</p>
<p>事实上，全连接网络也能完成卷积层的作用，但是全连接层会带来太多的参数，另外，对于一个卷积层，不知要多少个全连接的网络层才能
完成与它相同的功能。所以卷积层的出现，带来了图像识别方面的巨大进步。</p>
<h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>其实<strong>卷积层</strong>与<strong>池化层</strong>的反向传播并不复杂。</p>
<p>首先注意到<strong>卷积层</strong>，对于它的一个输出值来说，它来源于输入的某一块与其中一个<strong>Filter</strong>运算后得到的结果，那么它对<strong>Filter</strong>
的求导，就能得到这个<strong>Filter</strong>的一个求导值。</p>
<p>这样一个一个求取，就能得到每个<strong>Filter</strong>的导数值，进而就能去更新<strong>Filter</strong>的权值。</p>
<p>对于<strong>POOL层</strong>，它的求导也十分简单，首先对于<strong>Max Pool</strong>，它的一个输出值来自与输入的一个值，那么直接把这个值传回就好。
对于<strong>Average Pool</strong>，它的一个输出值来源于很多个输入值，并且这些输入值对它的贡献是一样的，所以，将这个输出值平均传回就好。</p>
<p>未完待续？</p>
]]></content>
      <categories>
        <category>coursera</category>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>mechine learning</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>SFC分配简单实验</title>
    <url>/2017/11/17/2017-11-17-SFC/</url>
    <content><![CDATA[<p><a href="https://github.com/isadamu/ml_sfc_allocate_test/tree/master">github链接</a></p>
<h1 id="2017年11月17日"><a href="#2017年11月17日" class="headerlink" title="2017年11月17日"></a>2017年11月17日</h1><h2 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h2><p>这里先固定好整个<strong>SFC</strong>的结构，也就是一共几类<strong>VNF</strong>，以及每一类<strong>SFC</strong>的实例个数，以及<strong>QOS</strong>属性的数量和前向属性的个数<strong>K</strong>。</p>
<p>可以变动的参数有：</p>
<ul>
<li>每一个<strong>VNF</strong>当前的<strong>QOS</strong>取值</li>
<li>每一个属性的权重</li>
</ul>
<hr>
<p>那么生成的样本的<strong>输入属性</strong>就是:所有<strong>VNF</strong>当前的<strong>QOS</strong>，以及每一个<strong>属性</strong>的权重组成的一个向量</p>
<p>样本的<strong>标签</strong>为每一类VNF的选择。</p>
<hr>
<h2 id="模拟环境示意图"><a href="#模拟环境示意图" class="headerlink" title="模拟环境示意图"></a>模拟环境示意图</h2><div align="center"><img src="/images/study/sfc_show.png" style="zoom:65%" title="SFC示意图" /></div>


<h2 id="确定到网络的结构"><a href="#确定到网络的结构" class="headerlink" title="确定到网络的结构"></a>确定到网络的结构</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__init__(self, num_i = [<span class="number">2</span>, <span class="number">3</span>], scope_L = [[<span class="number">1</span>, <span class="number">1000</span>],[<span class="number">1</span>, <span class="number">100</span>]], K = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><code>num_i</code>为每一类<strong>VNF</strong>的数量</p>
<p><code>scope_L</code> 为每一个<strong>QOS</strong>属性的取值范围</p>
<p><code>K</code> 为前向属性的数量</p>
<h2 id="随机QOS请求"><a href="#随机QOS请求" class="headerlink" title="随机QOS请求"></a>随机QOS请求</h2><p>首先确定出<strong>QOS</strong>请求的<strong>范围</strong></p>
<p>注意到应该有<strong>QOS</strong>不能被<strong>SFC</strong>所满足</p>
<p>那么这里将它的范围上限定义为属性的上限乘上<strong>VNF</strong>的种类数，下限就为属性的下限。？</p>
<h2 id="生成样本写入文件"><a href="#生成样本写入文件" class="headerlink" title="生成样本写入文件"></a>生成样本写入文件</h2><p>生成一百万条样本</p>
<p>写成<strong>CSV</strong>文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sfc_model <span class="keyword">as</span> sfc</span><br><span class="line"></span><br><span class="line">num_i = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">scope_L = [[<span class="number">1</span>, <span class="number">1000</span>],[<span class="number">1</span>, <span class="number">100</span>],[<span class="number">1</span>,<span class="number">100</span>],[<span class="number">1</span>,<span class="number">1000</span>]]</span><br><span class="line"></span><br><span class="line">K = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">my_model = sfc.sfc_model(num_i = num_i, scope_L = scope_L, K = K)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_qos</span>(<span class="params"> N = <span class="number">3</span>, scope_L = [[<span class="number">1</span>, <span class="number">1000</span>],[<span class="number">1</span>, <span class="number">100</span>],[<span class="number">1</span>,<span class="number">100</span>],[<span class="number">1</span>,<span class="number">1000</span>]], K = <span class="number">2</span> </span>):</span></span><br><span class="line">    L = <span class="built_in">len</span>(scope_L)</span><br><span class="line">    qos = np.zeros(L)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        qos[i] = np.random.rand(<span class="number">1</span>)[<span class="number">0</span>] * (scope_L[i][<span class="number">1</span>] * N - scope_L[i][<span class="number">0</span>]) + scope_L[i][<span class="number">0</span>]</span><br><span class="line"><span class="comment">#         if i &lt; K:</span></span><br><span class="line"><span class="comment">#             qos[i] = np.random.rand(1)[0] * (scope_L[i][1] * N - scope_L[i][0]) + scope_L[i][0]</span></span><br><span class="line"><span class="comment">#         else:</span></span><br><span class="line"><span class="comment">#             qos[i] = np.random.rand(1)[0] * (scope_L[i][1] * N - scope_L[i][0]) + scope_L[i][0]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> qos</span><br><span class="line"></span><br><span class="line"><span class="comment">## 把 path 变成一个分类问题</span></span><br><span class="line"></span><br><span class="line">N = <span class="number">3</span></span><br><span class="line">back_muti = np.zeros(N)</span><br><span class="line">category = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    back_muti[i] = <span class="number">1</span></span><br><span class="line">    category = category * num_i[i]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, N):</span><br><span class="line">        back_muti[i] = back_muti[i] * num_i[j]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_category</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="keyword">if</span> path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> category</span><br><span class="line">    </span><br><span class="line">    cate = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        cate = cate + path[i] * back_muti[i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(cate)</span><br><span class="line"></span><br><span class="line">T = <span class="number">100</span> </span><br><span class="line">N = <span class="number">3</span></span><br><span class="line">num_i = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">samples = np.zeros((T, <span class="built_in">len</span>(scope_L)*np.<span class="built_in">sum</span>(num_i) + <span class="built_in">len</span>(scope_L)*<span class="number">2</span>))</span><br><span class="line"><span class="comment"># labels = np.zeros((T, len(num_i) + np.sum(num_i)))</span></span><br><span class="line">labels = np.zeros((T, category+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    qos = random_qos()</span><br><span class="line">    my_model.construct()</span><br><span class="line">    path, _ = my_model.serveQOS(random_qos())</span><br><span class="line">    sample = qos</span><br><span class="line">    sample = np.hstack((sample, my_model.W))</span><br><span class="line">    sample = np.hstack((sample, my_model.qoses.reshape(-<span class="number">1</span>)))</span><br><span class="line">    label = np.zeros(category+<span class="number">1</span>)</span><br><span class="line">    idx = get_category(path)</span><br><span class="line">    label[idx] = <span class="number">1</span>          </span><br><span class="line">    samples[t] = sample.reshape(<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">    labels[t] = label.reshape(<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> t % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">        print(t)</span><br><span class="line"></span><br><span class="line">np.savetxt(<span class="string">&#x27;data/X_train.csv&#x27;</span>, samples, delimiter = <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">np.savetxt(<span class="string">&#x27;data/Y_train.csv&#x27;</span>, labels, delimiter = <span class="string">&#x27;,&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>直接使用<strong>keras</strong>，使用一个三隐藏层的神经网络进行尝试。</p>
<p>每一层<strong>1000</strong>个神经元。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_net</span>(<span class="params">input_len = (<span class="params"><span class="number">56</span>,</span>), output_len = <span class="number">61</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    X_input = Input(input_len)</span><br><span class="line">    X = Dense(<span class="number">1000</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;fc1&#x27;</span>, kernel_initializer = glorot_uniform())(X_input)</span><br><span class="line">    X = BatchNormalization(name = <span class="string">&#x27;bn1&#x27;</span>)(X)</span><br><span class="line">    </span><br><span class="line">    X = Dense(<span class="number">1000</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;fc2&#x27;</span>, kernel_initializer = glorot_uniform())(X)</span><br><span class="line">    X = BatchNormalization(name = <span class="string">&#x27;bn2&#x27;</span>)(X)</span><br><span class="line">    </span><br><span class="line">    X = Dense(<span class="number">1000</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;fc3&#x27;</span>, kernel_initializer = glorot_uniform())(X)</span><br><span class="line">    X = BatchNormalization(name = <span class="string">&#x27;bn3&#x27;</span>)(X)</span><br><span class="line">    </span><br><span class="line">    X = Dropout(<span class="number">0.7</span>)(X)</span><br><span class="line">    </span><br><span class="line">    X = Dense(output_len, activation=<span class="string">&#x27;softmax&#x27;</span>, name=<span class="string">&#x27;output&#x27;</span>, kernel_initializer = glorot_uniform())(X)</span><br><span class="line"></span><br><span class="line">    model = Model(inputs = X_input, outputs = X, name=<span class="string">&#x27;DemoNet&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
<h2 id="目前的效果"><a href="#目前的效果" class="headerlink" title="目前的效果"></a>目前的效果</h2><p>使用<strong>100万</strong>条样本，其中<strong>70万</strong>条作为训练集，<strong>30万</strong>作为测试集。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Epoch 50&#x2F;50</span><br><span class="line"> - 124s - loss: 1.0770 - acc: 0.6653</span><br><span class="line">Test Loss &#x3D; 1.12501473908</span><br><span class="line">Test Accuracy &#x3D; 0.668746666667</span><br></pre></td></tr></table></figure></h2><h1 id="2017年11月24日"><a href="#2017年11月24日" class="headerlink" title="2017年11月24日"></a>2017年11月24日</h1><h2 id="sfc网络数据生成"><a href="#sfc网络数据生成" class="headerlink" title="sfc网络数据生成"></a>sfc网络数据生成</h2><p><strong>前提：</strong></p>
<ol>
<li>网络结构最大5*5,否则网络过大会造成数据量爆炸。</li>
<li>Qos属性数量最大为4。理由同上。</li>
<li>想象中，请求从前向后依次经过每一类VNF，因为这里是加性的权重，经过顺序其实没有关系。</li>
<li>Qos属性的取值范围确定。反正进行归一化之后，范围没有任何影响。</li>
</ol>
<p><strong>可变参数：</strong></p>
<ol>
<li>网络中存在的VNF。在5*5的网络结构矩阵中，存在的VNF取值为1，否则为0。</li>
<li>VNF的Qos取值。由于是4维属性，那么就是5*5*4的矩阵。</li>
<li>前后向属性的个数。前向属性，Qos取值乘上-1。</li>
<li>每一个属性的权重。4维属性，那么将每一个属性的权重扩张为5*5的矩阵，组成5*5*4的矩阵。</li>
<li>Qos请求。4维属性，与上面相同，扩张为5*5*4的矩阵。</li>
</ol>
<p><strong>注意：</strong>这里的参数之所以设计为矩阵，是为了利用到卷积神经网络。</p>
<hr>
<p><strong>样本属性：</strong></p>
<p>4层Qos属性取值，4层Qos属性权重，4层Qos请求，总共12层，5*5*12？</p>
<p><strong>样本标签：</strong></p>
<p>5*6的矩阵，第一行有6列，每一列代表一个分类，那么就是选1、2、3、4、5或者不选（也就是不满足）。</p>
<p><strong>图形表示：</strong></p>
<div align="center"><img src="/images/study/模型2.png" style="zoom:75%" title="SFC示意图" /></div>

<h2 id="神经网络-1"><a href="#神经网络-1" class="headerlink" title="神经网络"></a>神经网络</h2><p>训练<strong>五个同样结构的神经网络</strong>，每一个指示其中一类VNF的选取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def my_net(input_len &#x3D; (5,5,12), classes &#x3D; 6 ):</span><br><span class="line">    </span><br><span class="line">    X_input &#x3D; Input(input_len)</span><br><span class="line">    </span><br><span class="line">    # padding to 6 * 6</span><br><span class="line">    X &#x3D; ZeroPadding2D((1, 1))(X_input)</span><br><span class="line">    </span><br><span class="line">    # first conv</span><br><span class="line">    X &#x3D; Conv2D(filters &#x3D; 64, kernel_size &#x3D; (3, 3), strides &#x3D; (1,1), padding &#x3D; &#39;same&#39;, name &#x3D; &#39;conv1&#39;, kernel_initializer &#x3D; glorot_uniform())(X)</span><br><span class="line">    X &#x3D; BatchNormalization(axis &#x3D; 3, name &#x3D; &#39;bn1&#39;)(X)</span><br><span class="line">    X &#x3D; Activation(&#39;relu&#39;)(X)</span><br><span class="line">    </span><br><span class="line">    # second conv</span><br><span class="line">    X &#x3D; Conv2D(filters &#x3D; 128, kernel_size &#x3D; (3, 3), strides &#x3D; (1,1), padding &#x3D; &#39;same&#39;, name &#x3D; &#39;conv2&#39;, kernel_initializer &#x3D; glorot_uniform())(X)</span><br><span class="line">    X &#x3D; BatchNormalization(axis &#x3D; 3, name &#x3D; &#39;bn2&#39;)(X)</span><br><span class="line">    X &#x3D; Activation(&#39;relu&#39;)(X)</span><br><span class="line">    </span><br><span class="line">    # Pooling</span><br><span class="line">    X &#x3D; MaxPooling2D((2, 2), strides&#x3D;(2, 2))(X)</span><br><span class="line">    </span><br><span class="line">    # output layer</span><br><span class="line">    X &#x3D; Flatten()(X)</span><br><span class="line">    X &#x3D; Dense(512, activation&#x3D;&#39;relu&#39;, name&#x3D;&#39;fc1&#39;, kernel_initializer &#x3D; glorot_uniform())(X)</span><br><span class="line">    X &#x3D; Dropout(0.5)(X)</span><br><span class="line">    X &#x3D; Dense(classes, activation&#x3D;&#39;softmax&#39;, name&#x3D;&#39;fc2&#39;, kernel_initializer &#x3D; glorot_uniform())(X)</span><br><span class="line"></span><br><span class="line">    model &#x3D; Model(inputs &#x3D; X_input, outputs &#x3D; X, name&#x3D;&#39;SFC_Net&#39;)</span><br><span class="line">    </span><br><span class="line">    return model</span><br></pre></td></tr></table></figure>
<p><strong>训练集样本：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ print(X_train.shape, Y_train.shape)</span><br><span class="line"></span><br><span class="line">(100000, 5, 5, 12) (100000, 5, 6)</span><br></pre></td></tr></table></figure>
<p><strong>测试集样本：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ print(X_test.shape, Y_test.shape)</span><br><span class="line"></span><br><span class="line">(10000, 5, 5, 12) (10000, 5, 6)</span><br></pre></td></tr></table></figure>
<p><strong>样本中大约10%的样本为当前不能服务。</strong></p>
<p><strong>训练次数：</strong></p>
<p>epoch = 100。</p>
<p><strong>测试集上精度：</strong></p>
<p>单神经网络精度（单类VNF选择）：88.58 %</p>
<p>总精度：58.12%</p>
]]></content>
      <categories>
        <category>deep learning</category>
        <category>network</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 149 Max Points on a Line</title>
    <url>/2017/11/20/2017-11-20-leetcode_149/</url>
    <content><![CDATA[<h2 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h2><p>Description:</p>
<ul>
<li>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</li>
</ul>
<p><strong>题目理解</strong>：</p>
<p>首先这道题的题干很短，基本第一遍都会理解错，也不清楚输入是个啥，所以这道题被踩了300多次，赞了100次不到…</p>
<p>经过几次错误的理解之后，明白了题目的意思：<strong>给一系列点，每个点有一个（x，y）的坐标取值，找出处于同一条直线上的最多点数。</strong></p>
<p>这里需要<strong>注意</strong>：</p>
<ul>
<li>可以有取值重复的坐标点。</li>
<li>直线可以是任意的斜率（以x,y的直角坐标系来看）。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>思路一：</strong></p>
<p>计算出可能的所有直线，统计每一条直线上的点的个数。直线以它的<strong>斜率</strong>加<strong>截距</strong>来表示：</p>
<script type="math/tex; mode=display">
y = kx + b</script><p>给予两个点的坐标，$(x_1,y_1)$、$(x_2,y_2)$，计算$k$与$b$的计算公式为：</p>
<script type="math/tex; mode=display">
k = \frac{y_1 - y_2}{x_1 - x_2}</script><script type="math/tex; mode=display">
b = y_1 - k x_1</script><p><strong>遇到的问题：</strong></p>
<ol>
<li>除法会有精度损失，可能造成不一样的直线算出来的斜率一样，而且可能会溢出，因为有<strong>加减</strong>运算。</li>
<li>不好统计直线上的点数，例如A、B、C三个点在一条线上，那么就有(A,B)(B,C)(A,C)三个组合，
那么这条直线上的点数该如何统计？</li>
</ol>
<p><strong>思路二：</strong></p>
<p>以每一个点为起点，计算它与其它的点组成的直线，统计直线上的点的次数。</p>
<p>这里的直线斜率直接使用分数表示，不需要截距，因为起点为同一个点。</p>
<p><strong>这里的分数表示需要计算分子与分母的最大公约数</strong>，在后面进行介绍，感觉这个才是这道题的重点。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a point.</span></span><br><span class="line"><span class="comment"> * class Point &#123;</span></span><br><span class="line"><span class="comment"> *     int x;</span></span><br><span class="line"><span class="comment"> *     int y;</span></span><br><span class="line"><span class="comment"> *     Point() &#123; x = 0; y = 0; &#125;</span></span><br><span class="line"><span class="comment"> *     Point(int a, int b) &#123; x = a; y = b; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PCount</span> </span>&#123;</span><br><span class="line">        Point point;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PCount</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.point = point;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ( b != <span class="number">0</span> ) &#123; </span><br><span class="line">            c = a % b; </span><br><span class="line">            a = b;  </span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( points == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        PCount[] pcount = <span class="keyword">new</span> PCount[points.length];</span><br><span class="line">        <span class="keyword">int</span> pidx = <span class="number">0</span>;</span><br><span class="line">        Map&lt;String, Integer&gt; ptable = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( Point point : points ) &#123;</span><br><span class="line">            String coord = point.x + <span class="string">&quot;*&quot;</span> + point.y;</span><br><span class="line">            Integer idx = ptable.get(coord);</span><br><span class="line">            <span class="keyword">if</span> ( idx == <span class="keyword">null</span> ) &#123;</span><br><span class="line">                ptable.put(coord, pidx);</span><br><span class="line">                pcount[pidx++] = <span class="keyword">new</span> PCount(point);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                pcount[idx].count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( pidx == <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> points.length;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pidx; i++ ) &#123;</span><br><span class="line">            Point p1 = pcount[i].point;</span><br><span class="line">            Map&lt;String, Integer&gt; lines = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; pidx; j++ ) &#123;</span><br><span class="line">                Point p2 = pcount[j].point;</span><br><span class="line">                String line = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ( p1.x == p2.x ) &#123;</span><br><span class="line">                    line = <span class="string">&quot;1/0&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( p1.y == p2.y ) &#123;</span><br><span class="line">                    line = <span class="string">&quot;0/1&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> denominator = p1.y - p2.y;</span><br><span class="line">                    <span class="keyword">int</span> numerator = p1.x - p2.x;</span><br><span class="line">                    <span class="keyword">int</span> gcd = GCD(denominator, numerator);</span><br><span class="line">                    <span class="keyword">if</span> ( gcd != <span class="number">0</span> ) &#123;</span><br><span class="line">                        denominator /= gcd;</span><br><span class="line">                        numerator /= gcd;</span><br><span class="line">                    &#125;</span><br><span class="line">                    line = denominator + <span class="string">&quot;/&quot;</span> + numerator;</span><br><span class="line">                &#125;</span><br><span class="line">                lines.put(line, lines.getOrDefault(line, pcount[i].count) + pcount[j].count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> count : lines.values() ) </span><br><span class="line">                max = max &lt; count ? count : max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/leetcode/149_1.png" alt="image"></p>
<h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><p>对于两个数A、B，求解它们的最大公约数。</p>
<p><strong>方法一：</strong></p>
<p>选出A、B中最小的数，向下一个一个进行取余，直到两个数的余数同时为0：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a &gt; b ? b : a;</span><br><span class="line">    <span class="keyword">while</span> ( a % c != <span class="number">0</span> || b % c != <span class="number">0</span> ) &#123;</span><br><span class="line">        c--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：</strong></p>
<p>显然方法一的效率很低，那么肯定有别的快速的方法。</p>
<p>对A、B，假设它们的最大公约数为C，那么：</p>
<script type="math/tex; mode=display">
A = k_1 C</script><script type="math/tex; mode=display">
B = k_2 C</script><p>注意，其中$k_1$与$k_2$一定是互质的，那么对A与B取余：</p>
<script type="math/tex; mode=display">
D = A \% B = (k_1 \% k_2)C</script><p>那么注意到D的取值情况：</p>
<ol>
<li>D的值为0，那么B就是最大公约数，其中$k_2=1$。</li>
<li>D的值不为0，D与B之间的最大公约数还是C。</li>
</ol>
<p>由于D的绝对值会比A要小，并且B、D之间的最大公约数还是C，所以可以计算B、D之间的最大公约数来代替计算A、B之间的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ( b != <span class="number">0</span> ) &#123; </span><br><span class="line">        c = a % b; </span><br><span class="line">        a = b;  </span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法会比方法一快很多。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习第二章《线性代数》</title>
    <url>/2017/11/23/2017-11-23-linear-algebra/</url>
    <content><![CDATA[<h2 id="标量、向量、矩阵和张量"><a href="#标量、向量、矩阵和张量" class="headerlink" title="标量、向量、矩阵和张量"></a>标量、向量、矩阵和张量</h2>]]></content>
      <categories>
        <category>deep learning</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Sibyl 论文笔记</title>
    <url>/2017/11/28/2017-11-28-Sibyl/</url>
    <content><![CDATA[<h2 id="Sibyl-A-Practical-Internet-Route-Oracle"><a href="#Sibyl-A-Practical-Internet-Route-Oracle" class="headerlink" title="Sibyl: A Practical Internet Route Oracle"></a>Sibyl: A Practical Internet Route Oracle</h2><p>论文<a href="https://pdfs.semanticscholar.org/0d89/37cad20f57a0453111691efe0ddbc90604b3.pdf">Calder, Matt, Yi-Ching Chiu, and Brandon Schlinker. “Sibyl: A Practical Internet Route Oracle.”</a></p>
<p>网络路由（Internet Route），描述两点之间的路由路径，经常用于解决网络问题或者是用于描述网络。</p>
<hr>
<h2 id="目前的形式"><a href="#目前的形式" class="headerlink" title="目前的形式"></a>目前的形式</h2><p>现在获取网络路由的还是一些老的工具，例如路由跟踪（traceroute）、BGP route collectors以及Looking Glasses等。</p>
<p>有很多公开的测量平台可以使用，它们提供遍布整个世界的<code>vantage points</code>来发起traceroute，
例如<code>RIPE Atlas</code>、<code>PlanetLab</code>、<code>Traceroute servers</code>、<code>DIMES</code>、<code>Dasu</code>。
可以通过这些平台来发起<code>traceroute</code>，但是这样的查询方式存在很多的限制：</p>
<ul>
<li>没有将历史的查询与实时的查询相结合。</li>
<li>平台与平台之间是独立的。</li>
<li>只能接受一个简单的question：“What is the path from here to there?”</li>
<li>因为是公开的平台，它们有资源限制。</li>
</ul>
<p>这导致目前的路由跟踪所能获得的信息十分有限，通常只能回答一些简单的问题。</p>
<hr>
<h2 id="Sibyl"><a href="#Sibyl" class="headerlink" title="Sibyl"></a>Sibyl</h2><p>论文提出一个网络路由查询系统，<strong>Sibyl</strong><em>[‘sɪbɪl]</em>。</p>
<p><strong>Sibyl提供正则表达式形式的查询</strong>，查询形式十分丰富，例如“在亚特兰大地区，哪些路由穿过Level3但是又不经过AT&amp;T？”。</p>
<p>为了满足查询，它的后端将从多种<code>vantage points</code>中发起<code>traceroute</code>，也就是使用多个测量平台来加快收敛。</p>
<p><strong>问题：测量平台存在资源限制。</strong>由于一些查询需要发起很多的<code>traceroute</code>，它们都可能可以满足查询，
但是由于资源限制，不可能做到。</p>
<p>为了解决这个问题，需要下面三个步骤：</p>
<ol>
<li>根据查询的结构缩小需要发出的<code>traceroute</code>，使得问题专注到一小部分<code>traceroute</code>。（正则表达式的结构）</li>
<li>结合历史数据来预测哪些未发出的<code>traceroute</code>更可能匹配到查询。（iPlane、RuleFit）</li>
<li>根据预测来最优化测量的资源分配。（贪心算法）</li>
</ol>
<hr>
<h2 id="Sibyl-结构"><a href="#Sibyl-结构" class="headerlink" title="Sibyl 结构"></a>Sibyl 结构</h2><p><img src="/images/paper/Sibyl_1.png" alt="image" title="Sibyl结构"></p>
<ol>
<li>UI界面。</li>
<li>一批Query。</li>
<li>预测与Query相匹配的路径。</li>
<li>最优化资源的利用。</li>
<li>结合多个平台执行测量。</li>
<li>测量结果与Query比较，返回满足的测量结果。</li>
<li>查看当前Model的数据是不是过时，如果过时，就用本次的测量结果去更新它。</li>
</ol>
<hr>
<h2 id="Query与正则表达"><a href="#Query与正则表达" class="headerlink" title="Query与正则表达"></a>Query与正则表达</h2><p><code>Query</code>的两种类型，一种是查询一条路径，例如查询从特定的源到目的的路径；
另一种是查询一个路径的集合，例如查询经过某个特定<code>AS link</code>的所有路径，为了知道哪些源目对使用了这条路径。</p>
<p>它们均使用正则表达式来表达，下面是文中给出的一些例子：</p>
<p><code>Reverse traceroute</code>：查询从<code>r</code>到<code>s</code>的路径：</p>
<script type="math/tex; mode=display">
r-.*-s$</script><p><code>Detecting prefix hijacks with iSpy</code>：查询所有能够到达p的AS：</p>
<script type="math/tex; mode=display">
\wedge \{.*\}-p$ \ \ by \ <AS></script><p>其中的$\wedge$表示反方向也需要查询。</p>
<hr>
<h2 id="预测部分"><a href="#预测部分" class="headerlink" title="预测部分"></a>预测部分</h2><p>首先使用<strong>iPlane</strong>来预测一条未经测量的路径是否有可能匹配查询。</p>
<p>然后<strong>RuleFit</strong>来对预测出来的路径分配置信度。</p>
<h3 id="iPlane"><a href="#iPlane" class="headerlink" title="iPlane"></a>iPlane</h3><p><strong>iPlane</strong>使用路径拼接的方法去预测一条没有测量过的路径。</p>
<p>例如预测从<strong>s</strong>到<strong>d</strong>的路径，<strong>iPlane</strong>将从<strong>s</strong>出发到某个目的的路径，
与从某个源出发目的为<strong>d</strong>的两条路径进行拼接，这两条路径需要存在相交的点。</p>
<p>原始的<strong>iPlane</strong>存在的问题：</p>
<ol>
<li>对一个点对<strong>s</strong>到<strong>d</strong>之间会选出一条最好的预测路径，但这条路径可能是错的。</li>
<li>对于预测出的路径没有置信度，这不利于测量资源的分配。</li>
</ol>
<p>解决思路：</p>
<ol>
<li>考虑<strong>s</strong>到<strong>d</strong>之间所有预测出的路径。</li>
<li>给予这些路径赋予置信度。</li>
</ol>
<h3 id="RuleFit"><a href="#RuleFit" class="headerlink" title="RuleFit"></a>RuleFit</h3><p><strong>RuleFit</strong>是一种监督学习的方法，这里使用它来给拼接的路径分配权重。</p>
<p>训练大概流程：先取出路径的很多属性，使用<strong>RuleFit</strong>可以计算出各个属性的重要程度(内部使用<code>decision trees</code>或者<code>lasso constraints</code>)，</p>
<blockquote>
<p>The score for a spliced path is the sum of rule values for rules that match the spliced path’s features</p>
<p>if the spliced path’s AS-path length is among the shortest, then increase the confidence (score) that it is very similar to &gt; the actual path</p>
</blockquote>
<p>使用拼接路径的一些属性，<strong>RuleFit</strong>可以给出与真实路径之间相似程度分数。</p>
<hr>
<h2 id="最优化资源的利用"><a href="#最优化资源的利用" class="headerlink" title="最优化资源的利用"></a>最优化资源的利用</h2><div align="center"><img src="/images/paper/Sibyl_2.png" style="zoom:60%" title="优化问题描述"/></div>

<p>直接使用贪心的方法去近似的解决这个问题，每次选择使得期望<code>utility</code>最大的<code>traceroute</code>。</p>
<hr>
<h2 id="结合多个平台"><a href="#结合多个平台" class="headerlink" title="结合多个平台"></a>结合多个平台</h2><p>结合到多个平台可以提高系统的覆盖范围，每个平台都提供了很多<code>vantage points</code>，它们之间存在不重合的部分，
将它们结合到一起可以得到<code>Path diversity</code>的提升。</p>
<div align="center"><img src="/images/paper/Sibyl_3.png" style="zoom:60%" title="RIPE Atlas"/></div>

<div align="center"><img src="/images/paper/Sibyl_4.png" style="zoom:60%" title="PlanetLab"/></div>

<hr>
<h2 id="论文附录例子"><a href="#论文附录例子" class="headerlink" title="论文附录例子"></a>论文附录例子</h2><p>假如有三条已存在的<code>traceroute</code>:</p>
<div align="center"><img src="/images/paper/Sibyl_5.png" style="zoom:70%" title="Three Traceroutes"/></div>

<p>为了简单这里IP的前八位就代表它是哪个AS。</p>
<p>查询问题，进过AS2和AS9的所有路径：</p>
<script type="math/tex; mode=display">
\wedge .*AS2.*AS9.*$.</script><p>首先将问题转化为<code>FSA</code>（论文没有找到FSA的具体说明）：</p>
<div align="center"><img src="/images/paper/Sibyl_6.png" style="zoom:45%"/></div>

<p>然后建立起前向和后向的两张表：</p>
<div align="center"><img src="/images/paper/Sibyl_7.png" style="zoom:65%"/></div>

<p>对左边的前向表进行一下解释（右表同理）：</p>
<ul>
<li>表的第一行$S_1 \xrightarrow[]{.*} S_1$，表示路径的起点，所以这里所有的AS都可以作为起点。</li>
<li>表的第二行$S_1 \xrightarrow[]{AS2} S_2$，表示从起点开始，经过AS2，所以只有第一行中的<code>Trace 1</code>的AS2满足。</li>
<li>表的第三行$S_2 \xrightarrow[]{.*} S_2$，表示S2可以向后扩展（也就是上一行中的AS2），这里就可以扩展到<code>3,4,5</code>。</li>
<li>第四行向后没有满足的路径。</li>
</ul>
<p>将前向后向路径拼接到一起，这里就可以从S2的位置拼接，前向路径<code>1-&gt;2-&gt;3</code>，后向路径<code>13-&gt;9-&gt;3</code>，
于是就得到路径<code>1-&gt;2-&gt;3-&gt;9-&gt;13</code>。</p>
<p><strong>Likelihood estimation：</strong></p>
<p>假如拼接得到以下的路径：</p>
<div align="center"><img src="/images/paper/Sibyl_8.png" style="zoom:65%" title="All spliced paths"/></div>

<p>对于<code>1.0.0.1</code>到<code>13.0.0.1</code>拼接得到两条路径，其中路径A满足查询，路径B不满足，进行归一化<code>0.41 = 0.7x0.7/(0.7 + 0.5)</code>，
<code>0.29 = 0.7x0.5/(0.7 + 0.5)</code>，由于路径B不满足查询，所以最后<code>1.0.0.1</code>到<code>13.0.0.1</code>的likelihood为0.41。</p>
<p>对于<code>15.0.0.1</code>到<code>16.0.0.1</code>拼接得到两条路径，其中路径C、D都满足查询，进行归一化<code>0.3 = 0.6x0.6/(0.6 + 0.6)</code>，
<code>0.3 = 0.6x0.6/(0.6 + 0.6)</code>，所以最后<code>15.0.0.1</code>到<code>16.0.0.1</code>的likelihood为<code>0.3 + 0.3 = 0.6</code>。</p>
<p>所以这里路径<code>15.0.0.1</code>到<code>16.0.0.1</code>满足查询的概率大于路径<code>1.0.0.1</code>到<code>13.0.0.1</code>。</p>
]]></content>
      <categories>
        <category>paper</category>
        <category>network</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>Residual Net and Inception Net</title>
    <url>/2017/11/29/2017-11-29-net-structures/</url>
    <content><![CDATA[<h1 id="Residual-Net"><a href="#Residual-Net" class="headerlink" title="Residual Net"></a>Residual Net</h1><p>参考：
<a href="https://www.coursera.org/learn/convolutional-neural-networks/lecture/HAhz9/resnets">coursera-convolutional-neural-networks-resnets</a></p>
<p>论文:
<a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/html/He_Deep_Residual_Learning_CVPR_2016_paper.html">He, Kaiming, et al. “Deep residual learning for image recognition.” Proceedings of the IEEE conference on computer vision and pattern recognition. 2016.</a></p>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><div align="center"><img src="/images/paper/ResNet_1.png" style="zoom:70%" title="ResNet结构" /></div>

<p><strong>VGG-19</strong>:2014年ImageNet亚军，top-5错误率7.3%，19层神经网络。（那一年的冠军是InceptionNet，top-5错误率6.7%，22层神经网络）</p>
<p><strong>plain</strong>:为了与ResNet区分，给中间的网络取名为“平坦”。</p>
<p><strong>residual</strong>:残差网络。为2015年ImageNet冠军，top-5错误率3.57%，152层神经网络。</p>
<h2 id="为什么使用残差网络？"><a href="#为什么使用残差网络？" class="headerlink" title="为什么使用残差网络？"></a>为什么使用残差网络？</h2><p><strong>原因</strong>，神经网络现在越来越深，但是简单的堆砌，使得网络深度增加，并不一定能使网络的精度增加。</p>
<div align="center"><img src="/images/paper/ResNet_2.png" style="zoom:60%" title="误差对比" /></div>

<p>图上56层的神经网络的精度反而比20层的神经网络精度低。</p>
<p>造成这个问题的原因有：</p>
<ol>
<li>梯度消失、梯度爆炸。虽然这个问题很大程度上被<code>normalization</code>解决了，但是可能还是会带来一些影响。</li>
<li>随着网络深度的增加，网络精度达到饱和，这时再增加网络层数，会使得网络精度迅速下降。这不是由于过拟合而造成的，可能是由于更深的网络更加难训练造成的。</li>
</ol>
<p>为此，引入残差网络的结构：</p>
<div align="center"><img src="/images/paper/ResNet_3.png" style="zoom:60%" title="Residual Block"/></div>

<p>将前几层的输出加到后几层的输出之上，上面的X是经过激活函数之后的输出，F(X)还未经过激活函数，
F(X)加上X之后再共同的经过激活函数。</p>
<p>这个结构的直接好处就是，<strong>如果网络精度已经饱和，中间新加入的层没有价值，残差网络将十分容易的将新加入层置为0（也就是F(X)=0，F(X)+X=X），这就不会影响到网络的精度。</strong></p>
<div align="center"><img src="/images/paper/ResNet_4.png" style="zoom:60%" title="误差对比"/></div>

<p>上面左图中34层的<code>plain</code>网络反而比18层的网络训练精度要低，而对于右图中的<code>ResNet</code>不会存在这种情况，</p>
<h2 id="对残差网络的另一种理解"><a href="#对残差网络的另一种理解" class="headerlink" title="对残差网络的另一种理解"></a>对残差网络的另一种理解</h2><p>文献：<a href="https://www.researchgate.net/profile/Andreas_Veit/publication/303409435_Residual_Networks_are_Exponential_Ensembles_of_Relatively_Shallow_Networks/links/57e2985b08aefabc9bb886c8/Residual-Networks-are-Exponential-Ensembles-of-Relatively-Shallow-Networks.pdf">Veit, Andreas, Michael Wilber, and Serge Belongie. “Residual networks are exponential ensembles of relatively shallow networks.” arXiv preprint arXiv:1605.06431 1 (2016).</a></p>
<p>通过下图可以表现出残差网络的另一种形式：</p>
<div align="center"><img src="/images/paper/ResNet_6.png" style="zoom:60%" title="Residual Blocks"/></div>

<p>把左图变形一下就变成右图，那么这里注意到<strong>残差网络其实就相当于是多个网络的叠加，结果就相当于是这些网络一起投票投出来的，有一种Ensembling的意思在里面。</strong></p>
<h2 id="实现上的一些技巧"><a href="#实现上的一些技巧" class="headerlink" title="实现上的一些技巧"></a>实现上的一些技巧</h2><p>在实际的残差网络实现中，有一些技巧：</p>
<div align="center"><img src="/images/paper/ResNet_5.png" style="zoom:60%" title="Residual Blocks"/></div>

<p><strong>限制</strong>，进入<code>block</code>的输入与出去<code>block</code>的输出维度要一致，包括长、宽以及深度。那么图中的卷积使用的都是<code>same</code>，也就是保持长宽不变的卷积。</p>
<p><strong>技巧</strong>，假设这里输入长宽是<code>64 x 64</code>，那么对于右图来说，如果没有前后的<code>1 x 1 x 64</code>、<code>1 x 1 x 256</code>的两个卷积，输入直接进行<code>3 x 3 x 256</code>的卷积:</p>
<script type="math/tex; mode=display">
Calculation = 64 \times 64 \times 3 \times 3 \times 256 \times 256 = 24'1591'9104</script><p>加上<code>1 x 1 x 64</code>、<code>1 x 1 x 256</code>两个卷积层：</p>
<script type="math/tex; mode=display">
\begin{equation}\begin{split}
Calculation &= 64 \times 64 \times 1 \times 1 \times 256 \times 64 +
64 \times 64 \times 3 \times 3 \times 64 \times 64 + 
64 \times 64 \times 1 \times 1 \times 64 \times 256 \\
&= 67108864 + 150994944 + 67108864 \\
&= 2'8521'2672
\end{split}\end{equation}</script><p>通过这样的方法，计算量可以减少一个数量级，其中<code>1 x 1 x 64</code>的卷积把它称为<code>bottleneck</code>，它在这就类似于一个瓶颈。<strong>在实际中表明，</strong>这样的方法并不会对神经网络的精度造成损害，所以通常使用这样的方式来构建block，降低计算量。</p>
<hr>
<hr>
<h1 id="Incepution-Net"><a href="#Incepution-Net" class="headerlink" title="Incepution Net"></a>Incepution Net</h1><p>2014年ImageNet冠军，top-5错误率6.7%，22层神经网络。那么实际上<code>Incepution Net</code>比<code>residual net</code>要早。</p>
<div align="center"><img src="/images/paper/Inception_net_0.png" style="zoom:70%" title="We need to go deeper"/></div>

<p>论文：<a href="https://arxiv.org/abs/1409.4842">Going Deeper with Convolutions,2014</a></p>
<p><a href="https://arxiv.org/abs/1512.00567">Rethinking the Inception Architecture for Computer Vision,2015</a></p>
<h2 id="网络结构-1"><a href="#网络结构-1" class="headerlink" title="网络结构"></a>网络结构</h2><p>在进行一次卷积操作时，不知道该选择<code>1 x 1</code>还是<code>3 x 3</code>还是<code>5 x 5</code>，怎么办？<strong>答：那么就在一层里面把它们全部都用上。</strong></p>
<div align="center"><img src="/images/paper/Inception_net_1.png" style="zoom:70%" title="Inception module"/></div>

<p>在同一层里面使用<code>1 x 1</code>、<code>3 x 3</code>、<code>5 x 5</code>以及<code>max pooling</code>，它们都使用<code>same</code>的卷积方式，
最后将它们的结果<strong>叠</strong>在一起就可以了。</p>
<p>同样的，这里也可以使用降维的思想（它的思想在ResNet之前）：</p>
<div align="center"><img src="/images/paper/Inception_net_2.png" style="zoom:70%" title="Inception module with dimensionality reduction"/></div>

<p>中间加入了几个<code>1 x 1</code>卷积，用于降低总的计算量。</p>
<p>比赛中使用的网络叫做<strong>GoogLeNet</strong>，整个网络的结构如下：</p>
<div align="center"><img src="/images/paper/Inception_net_3.png" style="zoom:90%" title="GoogLeNet"/></div>

<p>注意到中间有两个额外的输出，<strong>这是为了避免梯度消失，网络额外增加了2个辅助的softmax用于向前传导梯度。</strong>（博客上面看的，具体文章中还没看）</p>
<h2 id="升级版本"><a href="#升级版本" class="headerlink" title="升级版本"></a>升级版本</h2><p>在<code>Rethinking the Inception Architecture for Computer Vision,2015</code>这篇文章中有新的思路，目前还没有看。</p>
<div align="center"><img src="/images/paper/Inception_net_4.png" style="zoom:80%" title="Inception modules after the factorization of the n x n convolutions"/></div>

<p>其中大概多了下面的操作：</p>
<div align="center"><img src="/images/paper/Inception_net_5.png" style="zoom:80%" title="New module"/></div>

]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Keras 自定义 generator</title>
    <url>/2017/12/29/2017-12-29-keras-generator/</url>
    <content><![CDATA[<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>在做kaggle上的<code>Facial Keypoints Detection</code>时候，它输入是一些人脸的图片，
标签是类似眼角、鼻尖、嘴角等在图片上的坐标。</p>
<p>整个数据集的图片数量并不多，<strong>7000+</strong>，而且中间数据集其实可以分为两个部分，
一部分是质量较好的数据集，图片数<strong>2000+</strong>，剩下的就是另外一部分质量较差的。
实际上在训练的时候，只用了质量较好的这一部分，那么也就<strong>2000+</strong>的图片，
对于图片类的任务来说，样本太少了。</p>
<p>那么这里显然使用<code>Data Augmentation</code>是比较明智的选择，也就是将图片进行一下平移、镜像、对比度变化、旋转等操作，反正这些操作并不会影响到图片本身的性质，但是在神经网络看来又不会是重复样本。</p>
<p>所以，这里就需要使用<code>generator</code>，也就是流式的数据生成，因为不可能先把图片进行变换，保存下来再进行训练，因为一张图片可以变换成为无数张图片，所以需要一边使用原始图片来生成新图片，一边进行训练。</p>
<p>在Keras中，<code>model.fit_generator()</code>就是用来进行这种类型的训练的，它需要传入一个生成器，也就是python中的生成器。</p>
<p>注意到，在Keras中，提供了<code>ImageDataGenerator</code>这么一个类可以来进行图片的变换，其中有很多的功能。
<strong>但是，但是，但是，</strong>这里的任务不是分类，是回归，其中标签是眼角、鼻尖、嘴角等在图片上的坐标，
那么在图片进行变换的时候，当然这里坐标也需要跟着变，<strong>那么这里就得自己来写<code>generator</code></strong>。</p>
<hr>
<h2 id="generator是什么？"><a href="#generator是什么？" class="headerlink" title="generator是什么？"></a>generator是什么？</h2><p>我现在只有简单的理解，它就是一个python的生成器，每一次返回一个batch的样本以及标签。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_generator</span>(<span class="params">X, Y, batch_size=<span class="number">32</span>, gray_change_range=<span class="number">30</span>, cut_out_size=<span class="number">88</span></span>):</span></span><br><span class="line">    indexs = <span class="built_in">list</span>(<span class="built_in">range</span>(X.shape[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        np.random.shuffle(indexs)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(indexs), batch_size):</span><br><span class="line">            ge_batch_x = np.empty((batch_size, cut_out_size, cut_out_size))</span><br><span class="line">            ge_batch_y = np.empty((batch_size, Y.shape[<span class="number">1</span>]))</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> ge_batch_x, ge_batch_y</span><br></pre></td></tr></table></figure>
<p>生成器方法就类似于上面的代码，其中<code>yield</code>是关键的地方，程序每次运行到它的时候，
就会将它后面的数据返回，下一次调用又接着向后运行。</p>
<p>另外，这里写成了一个死循环<code>while True</code>，因为<code>model.fit_generator()</code>在使用在个函数的时候，
并不会在每一个epoch之后重新调用，那么如果这时候generator自己结束了就会有问题。</p>
<hr>
<h2 id="Keras使用generator进行训练"><a href="#Keras使用generator进行训练" class="headerlink" title="Keras使用generator进行训练"></a>Keras使用generator进行训练</h2><p>这里使用<code>model.fit_generator()</code>来进行训练即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fit_generator(self, generator, steps_per_epoch=<span class="literal">None</span>, epochs=<span class="number">1</span>, verbose=<span class="number">1</span>, callbacks=<span class="literal">None</span>,</span><br><span class="line">            validation_data=<span class="literal">None</span>, validation_steps=<span class="literal">None</span>, class_weight=<span class="literal">None</span>, max_queue_size=<span class="number">10</span>,</span><br><span class="line">            workers=<span class="number">1</span>, use_multiprocessing=<span class="literal">False</span>, shuffle=<span class="literal">True</span>, initial_epoch=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>函数声明中有很多可以选择的参数，具体的说明可以去查看官方的文档，里面介绍了每一个参数的说明，
通常我们只需要定义几个参数就够了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.fit_generator(my_generator(train_x, train_y), steps_per_epoch=train_x.shape[<span class="number">0</span>] / <span class="number">32</span>, epochs=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>上面的调用，参数中传入了生成器，多少个batch为一个epoch，训练多少个epoch。</p>
<hr>
<h2 id="关于参数设置多个workers的问题"><a href="#关于参数设置多个workers的问题" class="headerlink" title="关于参数设置多个workers的问题"></a>关于参数设置多个workers的问题</h2><p>关于workers的文档说明：</p>
<blockquote>
<blockquote>
<p>workers: Integer. Maximum number of processes to spin up when using process based threading. If unspecified, workers will default to 1. If 0, will execute the generator on the main thread.</p>
</blockquote>
</blockquote>
<p>我的理解，它是与数据生成有关的，应该是使用多个线程来生成数据。</p>
<p>由于有时候生成数据的过程可能较慢，它可能会拖慢整个训练的速度，所以需要使用多个线程来同时生成，
使得生成数据不会是训练时间的瓶颈。</p>
<p><strong>但是</strong>，当我设置<code>workers=2</code>时，程序报错，提示<code>generator already executing</code>，
google之后，大概确定了这个是没有线程安全而导致的问题。</p>
<p>我没有实际去解决，因为其实一个线程已经够用了。如果下次需要开启多个线程，解决方法可以参考，<a href="https://github.com/keras-team/keras/issues/1638">Proper way of making a data generator which can handle multiple workers #1638</a></p>
]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Keras在多GPU时指定单GPU执行以及显存控制，以及任务挂起的命令。</title>
    <url>/2017/12/29/2017-12-29-keras-gpu-control/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>实验室有一台服务器，其中有<strong>两块</strong>GPU，现在有<strong>几个人</strong>可能会去同时使用它，如果不进行GPU选择的话，
就一次只能执行一个任务，下一个任务去执行的时候就会提示错误，也就是资源不足。</p>
<p>所以这里需要<strong>指定</strong>任务使用哪一个GPU。</p>
<p>另外，如果不进行<strong>显存</strong>控制，只要任务跑起来，不管有多少个GPU，不管现在任务实际需要多少的显存，
不管现在任务实际是在哪一块GPU上面跑，<strong>所有</strong>的GPU的显存都会被占满，所以需要进行一下控制，
以便多人同时一起使用。</p>
<p><strong>注意：</strong>这里针对的Backend是<strong>TensorFlow</strong>。</p>
<hr>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在代码的头部加入一下代码即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> keras.backend.tensorflow_backend <span class="keyword">import</span> set_session</span><br><span class="line">config = tf.ConfigProto()</span><br><span class="line">config.gpu_options.per_process_gpu_memory_fraction = <span class="number">0.5</span></span><br><span class="line">config.gpu_options.visible_device_list = <span class="string">&quot;1&quot;</span></span><br><span class="line">set_session(tf.Session(config=config))</span><br></pre></td></tr></table></figure>
<p>这里的<code>visible_device_list</code>就指定了可见的GPU，也就是所使用的GPU。这里指定了<code>1</code>号GPU，
前面还有一张<code>0</code>号GPU。</p>
<p>这里的<code>per_process_gpu_memory_fraction</code>就指定了使用的GPU内存比例，这里设置了0.5。</p>
<p>运行任务时效果使用<code>nvidia-smi</code>命令查看：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI <span class="number">375</span>.<span class="number">26</span>                 Driver Version: <span class="number">375</span>.<span class="number">26</span>                    |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   <span class="number">0</span>  Tesla K40m          On   | <span class="number">0000</span>:<span class="number">04</span>:<span class="number">00</span>.<span class="number">0</span>     Off |                    <span class="number">0</span> |</span><br><span class="line">| N/A   <span class="number">28</span>C    P8    <span class="number">20</span>W / <span class="number">235</span>W |      <span class="number">2</span>MiB / <span class="number">11439</span>MiB |      <span class="number">0</span>%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   <span class="number">1</span>  Tesla K40m          On   | <span class="number">0000</span>:<span class="number">82</span>:<span class="number">00</span>.<span class="number">0</span>     Off |                    <span class="number">0</span> |</span><br><span class="line">| N/A   <span class="number">50</span>C    P0   <span class="number">129</span>W / <span class="number">235</span>W |   <span class="number">5860</span>MiB / <span class="number">11439</span>MiB |     <span class="number">88</span>%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">                                                                               </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                       GPU Memory |</span><br><span class="line">|  GPU       PID  <span class="built_in">Type</span>  Process name                               Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|    <span class="number">1</span>     <span class="number">19055</span>    C   python                                        <span class="number">5858</span>MiB |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>可以看到只使用了<code>1</code>号GPU，同时只用了它的<strong>50%</strong>的显存。</p>
<hr>
<h2 id="一些小坑"><a href="#一些小坑" class="headerlink" title="一些小坑"></a>一些小坑</h2><h3 id="1-关于Keras版本2-0-9"><a href="#1-关于Keras版本2-0-9" class="headerlink" title="1. 关于Keras版本2.0.9"></a>1. 关于Keras版本2.0.9</h3><p>对于这个版本，上面的代码并起不到效果，这是这个版本的BUG，在后续版本中就没有问题了。</p>
<p>我这直接升级了Keras到版本2.1.2，上面的代码就起了效果。</p>
<hr>
<h2 id="任务挂起"><a href="#任务挂起" class="headerlink" title="任务挂起"></a>任务挂起</h2><p>因为一般都是在linux环境下面跑，ssh建立起一个连接之后，在这个连接下面启动任务。
但是有时任务一下子执行不完，所以当然想把任务挂起来，即使这个ssh连接关闭，也不影响任务的执行。</p>
<p>很简单，使用<strong>nohup</strong>命令即可，它的使用方法为：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ nohup 命令 &gt; logs.file <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>] <span class="number">18864</span></span><br></pre></td></tr></table></figure>
<p>这里的命令就是要挂起执行的命令，在跑python脚本的时候一般就是<code>python xxx.py</code>。
另外其中的<code>logs.file</code>就是中间打印文件进行重定向的文件，使用它来存下中间的打印结果。</p>
<p>执行命名完毕之后，就会有一个<code>[1] 18864</code>，表示这个进程的进程id。</p>
]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>deep learning</tag>
        <tag>Keras</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 218 The Skyline Problem</title>
    <url>/2018/03/05/2018-03-05-leetcode_218/</url>
    <content><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>第一眼看到，“额，城市天际线（steam上一款游戏）？”，读了题目之后，明白它和游戏还真是有一点关系，那就是它真是城市的<strong>天际线</strong>。</p>
<p>所以这里的<strong>天际线</strong>的意思，其实是你在水平方向平视一个城市，它所展现出的轮廓，有点类似于工程制图里面的正视图。</p>
<p>那么建筑物在这道题中都以长方形来表示，与地面保持垂直，那么实际上，只需要给出房顶的坐标就可以确定一栋建筑。</p>
<p>题目要求就是求出这一条天际线，通过坐标点的形式来表示。</p>
<h2 id="自己的解决思路"><a href="#自己的解决思路" class="headerlink" title="自己的解决思路"></a>自己的解决思路</h2><p>本着能自己做就先不看别人的思路的原则，至少浪费了五个小时以上的时间，我一直都没有编写出来，今天把之前的代码删了，重新整理了一遍思路，
还是写了出来。</p>
<p>自己的思路就很直白，维护当前的天际线，把剩下的建筑一栋一栋加进来就好，那么就涉及到很多情况的判断，这种思路最容易出错的地方就在：</p>
<ul>
<li>一条线一定要以左端为准，这样在出现两栋刚好贴在一起的建筑的情况下，才不会出错。</li>
<li>将两条线的各种重叠情况判断清楚，分情况一一处理。这里情况有好几种，很容易遗漏或者绕晕。</li>
<li>初始情况的考虑，以及最后一条线的处理。</li>
</ul>
<p>由于这样的想法很好想，但是写起来十分痛苦，写完之后调了好几遍才过，搞不好就写乱了，然后就调不出来。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; roofs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] floor = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        roofs.add(floor);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span>[] building : buildings ) &#123;</span><br><span class="line">            helpAdd(roofs, building);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; roofs.size() - <span class="number">1</span>; i++ ) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] roof = roofs.get(i);</span><br><span class="line">            <span class="keyword">int</span>[] next = roofs.get(i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ( roof[<span class="number">1</span>] == next[<span class="number">1</span>] ) &#123;</span><br><span class="line">                roofs.remove(i+<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] first = roofs.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ( first[<span class="number">1</span>] == <span class="number">0</span> ) &#123;</span><br><span class="line">            roofs.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roofs;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helpAdd</span><span class="params">(List&lt;<span class="keyword">int</span>[]&gt; roofs, <span class="keyword">int</span>[] bu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = begin; i &lt; roofs.size() - <span class="number">1</span>; i++ ) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] roof = roofs.get(i);</span><br><span class="line">            <span class="keyword">int</span>[] next = roofs.get(i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ( roof[<span class="number">0</span>] &gt;= bu[<span class="number">1</span>] ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( roof[<span class="number">1</span>] &gt;= bu[<span class="number">2</span>] || next[<span class="number">0</span>] &lt;= bu[<span class="number">0</span>] ) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( roof[<span class="number">0</span>] &lt; bu[<span class="number">0</span>] ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( next[<span class="number">0</span>] &lt;= bu[<span class="number">1</span>] ) &#123;</span><br><span class="line">                    <span class="keyword">int</span>[] nroof = &#123;bu[<span class="number">0</span>], bu[<span class="number">2</span>]&#125;;</span><br><span class="line">                    roofs.add(++i, nroof);</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span>[] nroof = &#123;bu[<span class="number">0</span>], bu[<span class="number">2</span>]&#125;;</span><br><span class="line">                    <span class="keyword">int</span>[] nroof2 = &#123;bu[<span class="number">1</span>], roof[<span class="number">1</span>]&#125;;</span><br><span class="line">                    roofs.add(i+<span class="number">1</span>, nroof2);</span><br><span class="line">                    roofs.add(i+<span class="number">1</span>, nroof);</span><br><span class="line">                    begin = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( next[<span class="number">0</span>] &lt;= bu[<span class="number">1</span>] ) &#123;</span><br><span class="line">                    roof[<span class="number">1</span>] = bu[<span class="number">2</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span>[] nroof = &#123;bu[<span class="number">1</span>], roof[<span class="number">1</span>]&#125;;</span><br><span class="line">                    roof[<span class="number">1</span>] = bu[<span class="number">2</span>];</span><br><span class="line">                    roofs.add(i+<span class="number">1</span>, nroof);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] last = roofs.get(roofs.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( last[<span class="number">1</span>] &lt; bu[<span class="number">2</span>] &amp;&amp; last[<span class="number">0</span>] &lt; bu[<span class="number">1</span>] ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( last[<span class="number">0</span>] &lt; bu[<span class="number">0</span>] ) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] nroof = &#123;bu[<span class="number">0</span>], bu[<span class="number">2</span>]&#125;;</span><br><span class="line">                <span class="keyword">int</span>[] nroof2 = &#123;bu[<span class="number">1</span>], last[<span class="number">1</span>]&#125;;</span><br><span class="line">                roofs.add(nroof);</span><br><span class="line">                roofs.add(nroof2);</span><br><span class="line">                begin = roofs.size() - <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span>[] nroof = &#123;bu[<span class="number">1</span>], last[<span class="number">1</span>]&#125;;</span><br><span class="line">                last[<span class="number">1</span>] = bu[<span class="number">2</span>];</span><br><span class="line">                roofs.add(nroof);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/leetcode/218_1.png" alt="image"></p>
<p>算法复杂度：最坏情况$O(n^2)$，通常情况应该接近$O(n)$，主要是<strong>因为原本的建筑的左端起点已经排好序了，大量情况下只需要比较最后的几条线</strong>。</p>
<p>运行时间：4ms</p>
<p>击败：99.57%</p>
<p>另外，看了3ms的答案，别人的思路应该和我差不多，但是别人数据结构用了链表，这就是别人的优势了，也不知道为什么自己在写的时候没有想到。</p>
<h2 id="广泛的解决思路"><a href="#广泛的解决思路" class="headerlink" title="广泛的解决思路"></a>广泛的解决思路</h2><p>看了一下比较广泛的解决思路，主要使用了优先队列，其实就是一个对高度的排序，然后将一个一个点确定下来。不得不说这个思路很巧妙，
想要一下子想到这个思路，并不容易。但是一旦理清了这个思路，写起来又会相对简单一点。</p>
<p>参考资料：</p>
<p><a href="https://briangordon.github.io/2014/08/the-skyline-problem.html">leetCode上一哥们分享的解释，是真的强</a></p>
<p><a href="https://www.youtube.com/watch?v=GSBLe8cKu0s">YouTube上一个视频讲解，口音有点…</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>jar包的运行以及jre精简</title>
    <url>/2018/03/19/2018-03-19-java_jar_jre_reduce/</url>
    <content><![CDATA[<h2 id="工程打包"><a href="#工程打包" class="headerlink" title="工程打包"></a>工程打包</h2><p>无论是什么IDE，打包都是一件十分简单的事。（这里不讨论自己手动打包的情形）</p>
<hr>
<h2 id="jar包的运行"><a href="#jar包的运行" class="headerlink" title="jar包的运行"></a>jar包的运行</h2><p>如果环境变量中以及添加了jre的路径，那么java的执行如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java -jar xxx.jar arg1 arg2 XXX</span><br></pre></td></tr></table></figure>
<p>如果不想每次都使用命令行来输入的话，就可以把上面的命令变成一条<code>bat</code>脚本：</p>
<p>例如取名加<code>start.bat</code>，内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">start .\jre\bin\java -jar xxx.jar %1 %2</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p>其中<code>@echo off</code>意思为不打印输出，<code>start</code>意味着新建窗口执行后面的命令，<code>pause</code>表示暂停，
也就是可以在运行结束时出现<code>请按任意键继续...</code>，另外<code>%1 %2</code>表示两个输入参数。</p>
<p><strong>注意：</strong>此时jar包的路径就是它的执行路径，有时候程序可能需要取这个路径来进行相对路径的写操作，
java中可以使用下面语句来取到：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.getProperty(<span class="string">&quot;user.dir&quot;</span>)</span><br></pre></td></tr></table></figure></h2><h2 id="jre不添加环境变量运行"><a href="#jre不添加环境变量运行" class="headerlink" title="jre不添加环境变量运行"></a>jre不添加环境变量运行</h2><p>上面考虑的是环境变量中以及添加了jre的情况，有时候我们可能需要把程序放到别的电脑上来运行，
这时候如果别人的电脑上没有java环境，那就会执行不了，总不能让别人现装一个吧。</p>
<p>考虑到最大化的简便使用者，就需要把jre拿出来，和jar包绑在一起发送给别人。</p>
<p>那么如何使用jre来直接运行java呢？使用jre中bin下的java.exe或者javaw.exe即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .\jre\bin\java -jar xxx.jar arg1 arg2 ...</span><br><span class="line">或者</span><br><span class="line">$ .\jre\bin\javaw -jar xxx.jar arg1 arg2 ...</span><br></pre></td></tr></table></figure>
<p>它两之间没有什么不同，<code>javaw</code>会屏蔽打印信息，而<code>java</code>不会。</p>
<p>那么现在，就只需要将jre放到jar包同一个目录下，使用上面的命令就可以运行程序，
这样就能在没有java环境的电脑上运行，因为我们自带了java运行环境。</p>
<p>这里具体的目录结构当然不重要，看个人喜好了。</p>
<hr>
<h2 id="精简jre"><a href="#精简jre" class="headerlink" title="精简jre"></a>精简jre</h2><p>这里使用的是<code>jre 1.8</code>，从<code>jdk-8u131</code>下取出来的，大小为188M。</p>
<p>显然，相比于我的程序来说，这实在是太大了，如果不精简jre，整个程序包就得有近200M，
这有一点不能接受，所以还是需要精简jre。</p>
<p>这里我参考了博客<a href="http://blog.csdn.net/xiaomin1991222/article/details/50981415">整理JRE瘦身或精简JRE</a></p>
<p>那么有没有一些精简工具呢？</p>
<p>搜索了半天，有一个<a href="https://code.google.com/archive/p/greenvm/downloads">greenvm</a>，但是这程序好像已经非常久没有更新了，
这位作者是不是放弃它了，下载下来试了一下，好像有一点问题，总之我用的时候是报错了。</p>
<p>还有一个<a href="https://docs.oracle.com/javase/8/embedded/develop-apps-platforms/jrecreate.htm#A1142008">jrecreate</a>，这个是<code>oracle</code>公司官方的，不过好像不是针对某个程序设计的？感觉就是提供了几个较小版本的jre？有待考证。</p>
<p><strong>感觉大部分网友还是自己手动进行精简</strong>，那么如果要手动精简，首先整理几个点：</p>
<ol>
<li>jre文件下需要考虑的就是两个文件夹<code>bin</code>和<code>lib</code>。</li>
<li><code>bin</code>文件夹下总的文件数不多，体积大概为80M，其中大部分东西都用不到。</li>
<li><code>lib</code>文件夹下有很多文件，体积大概有100M，其中有少量的jar包会用到。</li>
</ol>
<p>有了上面几个点，下面就是第一步精简的策略:</p>
<p>首先对于<code>bin</code>文件夹的精简策略：</p>
<ol>
<li>手动删除几个文件，然后执行jar包，看是否报错，就这样精简到不能再精简。</li>
</ol>
<p>想着手动挺烦的，但是其实上这里大部分文件都可以删除，而且文件也不多，几分钟就能清理完毕。
（我清除完就剩下8M，主要是jvm.dll比较大）。</p>
<p>第二，对于<code>lib</code>文件夹的精简策略：</p>
<ol>
<li>同样的，手动删。</li>
<li>这里可能需要留的文件比较多，所以建议直接按文件大小，很多小文件（1KB，2KB）就不用删了，试一试删除一些大文件。</li>
</ol>
<p>我这里最后剩下两个较大的文件<code>charsets.jar</code>和<code>rt.jar</code>，那么加起来还是有60M多，恩，还需要继续精简。</p>
<hr>
<h2 id="精简charsets-jar和rt-jar"><a href="#精简charsets-jar和rt-jar" class="headerlink" title="精简charsets.jar和rt.jar"></a>精简charsets.jar和rt.jar</h2><p><code>charsets.jar</code>和<code>rt.jar</code>中有很多程序运行时需要调用的class文件，所以我们删不掉它们，那么很明显，
只要将程序不用的class文件从中删去，就能减小大小。</p>
<p>要这样做，首先就得知道自己的程序在运行过程中使用了哪些类，可以使用下面命令来打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java -jar -verbose:class XXX.jar</span><br></pre></td></tr></table></figure>
<p>这样就能打印我们使用了哪些类，将这些信息重定向到文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java -jar -verbose:class XXX.jar &gt;&gt; class.txt</span><br></pre></td></tr></table></figure>
<p>那么这里就得到了<code>class.txt</code>，其中以<code>[Load ...]</code>开头的就是在加载类。</p>
<p><strong>进一步</strong>，我们要将<code>charsets.jar</code>和<code>rt.jar</code>类中的相关class提取出来：</p>
<ol>
<li>将这两个文件给解压缩了，得到<code>charsets</code>，<code>rt</code>文件夹。</li>
<li>编写代码，取到<code>class.txt</code>中加载的类，对比的去<code>charsets</code>，<code>rt</code>文件夹中找，找到就复制到新文件夹。</li>
</ol>
<p>这里的代码会附加到最后面，总之，这里得到两个新的<code>charsets</code>，<code>rt</code>文件夹，下面已经去除了不需要的class文件。</p>
<p>直接将这两个文件夹用zip打包（不要将charsets或者rt文件夹也给包了，这样就比原来的jar包多了一层目录了），改名为<code>charsets.jar</code>和<code>rt.jar</code>，放回jre所在的位置中替换既可。</p>
<p>这样下来<code>lib</code>文件夹可以缩小到10M以下。</p>
<p><strong>讲道理应该是可以的，但是我这里报错了，可能是我个人的问题。</strong></p>
<hr>
<h2 id="实际上的精简操作"><a href="#实际上的精简操作" class="headerlink" title="实际上的精简操作"></a>实际上的精简操作</h2><p><strong>由于上面的方法最后在运行jar包时报错了，所以我手动添加了一些class回去。</strong></p>
<p>事实上，对于<code>charsets.jar</code>，我没有改动内容，只是将它解压重新用zip压缩了一遍，这样的确可以缩小一点。</p>
<p>对于<code>rt.jar</code>，我将java和sun两个包下的类都保留了，因为不知道到底少了哪个class。</p>
<p>最终jre的大小精简到22M。</p>
<hr>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>不知道在后面的使用中还会不会有别的问题。</p>
<p>2018-06-15：使用时问题，我程序中需要有输入文件，输入文件的格式可能是<code>.xml</code>、<code>.xls</code>、<code>.xlsx</code>、<code>.csv</code>，
但是在精简的时候我只使用了<code>.csv</code>文件测试，于是当输入文件变成<code>.xls</code>格式时，就出现了问腿。</p>
<p><strong>所以，在不得已的时候还是不要尝试使用本方法精简jre，由于程序运行过程的变化，可能会出现问题。</strong>当然，
如果程序比较简单，没什么变化时，还是可以精简jre的。</p>
<hr>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>参考了<a href="http://blog.csdn.net/xiaomin1991222/article/details/50981415">整理JRE瘦身或精简JRE</a>，进行了少量改动。</p>
<p><code>jarInputPath</code>是输入文件夹，这里下面就有两个文件夹rt、charsets。（解压了的）</p>
<p><code>jarOutputPath</code>是输出文件夹。</p>
<p><code>jarPackNames</code>就是两个包名。</p>
<p><code>classListInputPath</code>就是上面命令打印出来的信息。</p>
<p><code>classListOutputPath</code>所有这里复制了的类的名字会保存到这个文件中。</p>
<p><strong>另外:</strong>输入文件与输出文件的编码注意一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String jarInputPath = <span class="string">&quot;./input&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String jarOutputPath = <span class="string">&quot;./output&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] jarPackNames = &#123;<span class="string">&quot;rt&quot;</span>, <span class="string">&quot;charsets&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String classListInputPath = <span class="string">&quot;class.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String classListOutputPath = <span class="string">&quot;classClean.txt&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; classList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">int</span> totalLine = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> totalLineOut = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">				<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(classListInputPath), <span class="string">&quot;unicode&quot;</span>));</span><br><span class="line"></span><br><span class="line">            BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">				<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(classListOutputPath), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				totalLine++;</span><br><span class="line">                <span class="keyword">if</span> ( !line.startsWith(<span class="string">&quot;[L&quot;</span>) ) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				String str = line.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>];</span><br><span class="line">				classList.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// copy class</span></span><br><span class="line">			<span class="keyword">for</span> ( String str : classList ) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( copyClass(str) ) &#123;</span><br><span class="line">					System.out.println( <span class="string">&quot;copy : &quot;</span> + str);</span><br><span class="line">					bw.write(str);</span><br><span class="line">					bw.newLine();</span><br><span class="line">					totalLineOut++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;The number of input line: &quot;</span> + totalLine);</span><br><span class="line">			System.out.println(<span class="string">&quot;The number of out line: &quot;</span> + totalLineOut);</span><br><span class="line">            br.close();</span><br><span class="line">            bw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">copyClass</span><span class="params">(String className)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		className = className.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span> ( String pack : jarPackNames ) &#123;</span><br><span class="line">			String classPathIn = jarInputPath + <span class="string">&quot;/&quot;</span> + pack + <span class="string">&quot;/&quot;</span> + className + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">			String classPathOut = jarOutputPath + <span class="string">&quot;/&quot;</span> + pack + <span class="string">&quot;/&quot;</span> + className + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">			File fileIn = <span class="keyword">new</span> File(classPathIn);</span><br><span class="line">			File fileOut = <span class="keyword">new</span> File(classPathOut);</span><br><span class="line">			<span class="keyword">if</span> ( !fileIn.exists() || fileOut.exists() ) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			helpCopyFile(classPathIn, classPathOut);</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helpCopyFile</span><span class="params">(String input, String output)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File outDir = <span class="keyword">new</span> File(output.substring(<span class="number">0</span>, output.lastIndexOf(<span class="string">&quot;/&quot;</span>)));</span><br><span class="line">		<span class="keyword">if</span> ( !outDir.exists() ) &#123;</span><br><span class="line">			outDir.mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(input);</span><br><span class="line">		FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(output);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">256</span>];</span><br><span class="line">		<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> ( (len = fis.read(buf)) != -<span class="number">1</span> ) &#123;</span><br><span class="line">			fos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">		&#125;</span><br><span class="line">		fos.flush();</span><br><span class="line">		</span><br><span class="line">		fis.close();</span><br><span class="line">		fos.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>guide</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>guide</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>2017年华为软件精英挑战赛记录</title>
    <url>/2018/05/02/2018-05-02-2017_codecraft/</url>
    <content><![CDATA[<hr>
<h1 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>很好，网上找了一会也没有找到题目，我只想说，华为你把往年的题的链接给一下可好？</p>
<p>凭借记忆，初赛的题目大概是，有一个网络，要在上面部署cdn服务器，怎么部署既能满足用户需求，
又能使得部署费用最少。</p>
<p>具体一点，相当于一个无向图，有一些点是小区，每个小区都有视频业务的需求，而且需求量不一样，每条边是一条链路，
链路有它的带宽限制。现在需要部署cdn服务器，让每一个小区的视频业务都能满足，同时部署cdn服务器的费用越低越好。</p>
<p>每一个点都可以部署cdn服务器（包括是小区的点），每一个小区有一个需求值，每一条边是一条链路，每条链路都是双向的，
每条链路有一个链路容量和一个单位费用（使用链路上一个单位的流量需要多少钱）。cdn服务器数量无限，cdn服务器输出能力无限，
同样cdn服务器也有一个单价。</p>
<p>限制：不能使用第三方库，程序运行时间不超过60s。</p>
<h2 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h2><p>这个需要一步一步来分析：</p>
<ol>
<li>该选择哪些点来部署服务器？</li>
<li>在部署好了服务器的情况下，流量该如何流，才能满足所有用户，并且使得费用最小？</li>
</ol>
<p>这就是这个题目的两个核心问题。</p>
<h3 id="该选择哪些点来部署服务器？"><a href="#该选择哪些点来部署服务器？" class="headerlink" title="该选择哪些点来部署服务器？"></a>该选择哪些点来部署服务器？</h3><p>这是这个题目最难的一部分，因为这个选择是一个NP难的问题，所以是没有现成的解法来教你如何求解这个问题的，
通常都是将它变成一个整数规划模型，然后使用求解器来求解。但是由于不能使用第三方库，所以代码全靠手写，
那么这个问题基本上只能使用启发式算法来解。</p>
<p>那么有哪些常用的启发式算法呢？遗传算法、模拟退火、蚁群算法、粒子群算法等。</p>
<p>很好，那么从哪个算法开始呢？显然都不用，第一步当然是写一个最简单的版本，先熟悉问题，在深入问题。</p>
<p><strong>最简单的版本（原始想法）：</strong></p>
<p>版本1：初始每一个小区都给一个cdn，然后再尝试一个个cdn删除，直到不能降低费用，或者不能满足用户需求为止。</p>
<p>版本2：初始没有cdn，然后尝试一个小区一个小区添加cdn，直到需求满足且不能降低费用为止。</p>
<p><strong>初始版本的想法非常简单，但是很遗憾，这个想法在初赛的简单用例上能直接跑出最优解…</strong></p>
<p>(有时候问题就是这么简单，只不过很多人还没开始就觉得难，然后就没有然后了)</p>
<h3 id="在部署好了服务器的情况下，流量该如何流，才能满足所有用户，并且使得费用最小？"><a href="#在部署好了服务器的情况下，流量该如何流，才能满足所有用户，并且使得费用最小？" class="headerlink" title="在部署好了服务器的情况下，流量该如何流，才能满足所有用户，并且使得费用最小？"></a>在部署好了服务器的情况下，流量该如何流，才能满足所有用户，并且使得费用最小？</h3><p>解决这个问题很简单，使用<a href="待补充">最小费用最大流</a>就解决了。</p>
<p>使用最简单的增广路写法就好。</p>
<h2 id="进阶分析"><a href="#进阶分析" class="headerlink" title="进阶分析"></a>进阶分析</h2><p>同样的，两个步骤的想法。</p>
<h3 id="该选择哪些点来部署服务器？-1"><a href="#该选择哪些点来部署服务器？-1" class="headerlink" title="该选择哪些点来部署服务器？"></a>该选择哪些点来部署服务器？</h3><p>由于最初始的版本效果很好，那么在这个基础上还能加强吗？</p>
<p>当然能，很简单就能想到几个操作方法：</p>
<ol>
<li>cdn移动。现在cdn都是直接放在小区上面的，所以自然可以尝试移动cdn，只移动一步，
如果移动能降低费用就移动，否则维持原状。</li>
<li>cdn删除。这个删除不同于上面的原始想法中的删除，这个删除是根据cdn移动来的，如果有cdn移动成功了，
那么意味着图的结构变了，有的点就也许就可以删除了。</li>
</ol>
<p><strong>很遗憾，初赛使用的就是这个思路做的，最后大概成渝前3的水平…</strong></p>
<h3 id="在部署好了服务器的情况下，流量该如何流，才能满足所有用户，并且使得费用最小？-1"><a href="#在部署好了服务器的情况下，流量该如何流，才能满足所有用户，并且使得费用最小？-1" class="headerlink" title="在部署好了服务器的情况下，流量该如何流，才能满足所有用户，并且使得费用最小？"></a>在部署好了服务器的情况下，流量该如何流，才能满足所有用户，并且使得费用最小？</h3><p>上面选择了增广路写法。</p>
<p>但是，注意到时间限制60s，在这种分两步走的策略里面，需要跑很多次费用流，
这时候的问题就是如何解决好这个问题，也就是用时尽量少。</p>
<p><strong>最小费用最大流：</strong></p>
<p>这里我首先使用的是增广路解法，使用SPFA计算增广路的最短路径。</p>
<p>由于在一次求解最小费用最大流的过程中，需要反复的调用SPFA，那么<strong>在重复进行SPFA的过程中，不用每一次都重头开始</strong>，
也就是一部分最短路径的结果可以保留，这样在下一次计算时就可以少很多的计算量。</p>
<p>使用这样的方法，跑高级用例也没有问题，否则高级用例会有压力。</p>
<p>由于上面部署的思路太简单了，这个最小费用最大流的魔改是我觉得自己最有意思的地方了。</p>
<p>（具体用时忘记了…太过久远）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>参见github<a href="https://github.com/isadamu/2017-codecraft">2017-codecraft</a></p>
<p>在一年之后，看自己一年之前写的代码，真的写得稀烂…估计再过一年又会嫌弃现在。</p>
<h1 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>和上面的题目其实一样，</p>
<p>// TODO</p>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>competition</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数组拷贝Benchmark</title>
    <url>/2018/07/19/2018-07-19-java-array-copy-bench/</url>
    <content><![CDATA[<hr>
<p>在《疯狂Java》的7.3，关于Object类的内容中，作者表示使用Object的默认clone方法比使用静态copy方法快两倍。</p>
<p>这一点十分的有趣，毕竟平常在写算法题的时候，经常会需要对数组进行拷贝，而我最常用的还是<code>System.arraycopy()</code>方法，那么难道<code>Object.clone()</code>真的要更快吗？</p>
<p><strong>实践是检验真理的唯一标准</strong>，这里就对各种数组拷贝的方法进行比较，直接上代码比时间，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayCopyTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000</span>;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">5000000</span>;</span><br><span class="line">		<span class="keyword">long</span> start, end;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++ ) &#123;</span><br><span class="line">			a[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++ ) &#123;</span><br><span class="line">			<span class="keyword">int</span>[] b = a.clone();</span><br><span class="line">		&#125;</span><br><span class="line">		end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;Object.clone()用时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">		start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++ ) &#123;</span><br><span class="line">			<span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">			System.arraycopy(a, <span class="number">0</span>, c, <span class="number">0</span>, N);</span><br><span class="line">		&#125;</span><br><span class="line">		end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;System.arraycopy()用时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">		start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++ ) &#123;</span><br><span class="line">			<span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++ ) &#123;</span><br><span class="line">				c[j] = a[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;循环拷贝用时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">		start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++ ) &#123;</span><br><span class="line">			<span class="keyword">int</span>[] c = Arrays.copyOf(a, N);</span><br><span class="line">		&#125;</span><br><span class="line">		end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;Arrays.copyOf()用时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里一共使用了四种数组拷贝的方法，<code>Object.clone()</code>、<code>System.arraycopy()</code>、<code>for循环</code>、<code>Arrays.copyOf()</code>。</p>
<p>测试结果1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java ArrayCopyTest</span><br><span class="line"></span><br><span class="line">Object.clone()用时：14491ms</span><br><span class="line">System.arraycopy()用时：12859ms</span><br><span class="line">循环拷贝用时：12700ms</span><br><span class="line">Arrays.copyOf()用时：13938ms</span><br></pre></td></tr></table></figure>
<p>测试结果2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java ArrayCopyTest</span><br><span class="line"></span><br><span class="line">Object.clone()用时：44249ms</span><br><span class="line">System.arraycopy()用时：38115ms</span><br><span class="line">循环拷贝用时：38092ms</span><br><span class="line">Arrays.copyOf()用时：44240ms</span><br></pre></td></tr></table></figure>
<p>…显然，这是完全没有想到的情况，上面是在两台不同的电脑上跑出来的结果，速度排序<code>for循环</code>&gt;<code>System.arraycopy()</code>&gt;<code>Arrays.copyOf()</code>&gt;<code>Object.clone()</code>。</p>
<p>不是说好的<code>Object.clone()</code>更快吗？这就算了。那么为了<code>for循环</code>竟然是最快的？？？</p>
<hr>
<p>好吧，只能简单看一下源码了。</p>
<p><strong>System.arraycopy()</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>Arrays.copyOf()</strong>，它实际调用的是<code>copyOfRange()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOfRange(U[] original, <span class="keyword">int</span> from, <span class="keyword">int</span> to, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="keyword">int</span> newLength = to - from;</span><br><span class="line">    <span class="keyword">if</span> (newLength &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(from + <span class="string">&quot; &gt; &quot;</span> + to);</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, from, copy, <span class="number">0</span>,</span><br><span class="line">                        Math.min(original.length - from, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Object.clone()</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>
<p>可以发现，<code>System.arraycopy()</code>和<code>Object.clone()</code>调用的都是native方法，<code>Arrays.copyOf()</code>调用的是<code>System.arraycopy()</code>。</p>
<p>所以<code>Arrays.copyOf()</code>肯定是比<code>System.arraycopy()</code>慢。但是为什么这些方法都没有最简单的<code>for循环</code>快？？？</p>
<p><strong>重新测试：</strong></p>
<p>或许是刚才测试的顺序不对？</p>
<p>修改代码重新测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayCopyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">500000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] a;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> a, b, c, d;</span><br><span class="line">		a = b = c = d = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			a += test1();</span><br><span class="line">			b += test2();</span><br><span class="line">			c += test3();</span><br><span class="line">			d += test4();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;\n************************************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;Object.clone()总用时：&quot;</span> + a + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;System.arraycopy()总用时：&quot;</span> + b + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;循环拷贝总用时：&quot;</span> + c + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Arrays.copyOf()总用时：&quot;</span> + d + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start, end;</span><br><span class="line">		start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++ ) &#123;</span><br><span class="line">			a = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">			<span class="keyword">int</span>[] b = a.clone();</span><br><span class="line">		&#125;</span><br><span class="line">		end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;Object.clone()用时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> end - start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start, end;</span><br><span class="line">		start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++ ) &#123;</span><br><span class="line">			a = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">			<span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">			System.arraycopy(a, <span class="number">0</span>, c, <span class="number">0</span>, N);</span><br><span class="line">		&#125;</span><br><span class="line">		end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;System.arraycopy()用时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> end - start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start, end;</span><br><span class="line">		start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++ ) &#123;</span><br><span class="line">			a = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">			<span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++ ) &#123;</span><br><span class="line">				c[j] = a[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;循环拷贝用时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> end - start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start, end;</span><br><span class="line">		start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++ ) &#123;</span><br><span class="line">			a = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">			<span class="keyword">int</span>[] c = Arrays.copyOf(a, N);</span><br><span class="line">		&#125;</span><br><span class="line">		end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;Arrays.copyOf()用时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> end - start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java ArrayCopyTest</span><br><span class="line"></span><br><span class="line">Object.clone()用时：24763ms</span><br><span class="line">System.arraycopy()用时：23489ms</span><br><span class="line">循环拷贝用时：20988ms</span><br><span class="line">Arrays.copyOf()用时：21984ms</span><br><span class="line">Object.clone()用时：23799ms</span><br><span class="line">System.arraycopy()用时：23507ms</span><br><span class="line">循环拷贝用时：24672ms</span><br><span class="line">Arrays.copyOf()用时：22697ms</span><br><span class="line">Object.clone()用时：23126ms</span><br><span class="line">System.arraycopy()用时：21553ms</span><br><span class="line">循环拷贝用时：23705ms</span><br><span class="line">Arrays.copyOf()用时：21827ms</span><br><span class="line">Object.clone()用时：21787ms</span><br><span class="line">System.arraycopy()用时：21636ms</span><br><span class="line">循环拷贝用时：23640ms</span><br><span class="line">Arrays.copyOf()用时：21864ms</span><br><span class="line">Object.clone()用时：22287ms</span><br><span class="line">System.arraycopy()用时：23185ms</span><br><span class="line">循环拷贝用时：25596ms</span><br><span class="line">Arrays.copyOf()用时：22266ms</span><br><span class="line">Object.clone()用时：22126ms</span><br><span class="line">System.arraycopy()用时：22300ms</span><br><span class="line">循环拷贝用时：25772ms</span><br><span class="line">Arrays.copyOf()用时：22275ms</span><br><span class="line">Object.clone()用时：22513ms</span><br><span class="line">System.arraycopy()用时：22313ms</span><br><span class="line">循环拷贝用时：23993ms</span><br><span class="line">Arrays.copyOf()用时：22965ms</span><br><span class="line">Object.clone()用时：22571ms</span><br><span class="line">System.arraycopy()用时：22962ms</span><br><span class="line">循环拷贝用时：24482ms</span><br><span class="line">Arrays.copyOf()用时：22656ms</span><br><span class="line">Object.clone()用时：22233ms</span><br><span class="line">System.arraycopy()用时：23668ms</span><br><span class="line">循环拷贝用时：25993ms</span><br><span class="line">Arrays.copyOf()用时：23749ms</span><br><span class="line">Object.clone()用时：22468ms</span><br><span class="line">System.arraycopy()用时：22449ms</span><br><span class="line">循环拷贝用时：24113ms</span><br><span class="line">Arrays.copyOf()用时：22535ms</span><br><span class="line"></span><br><span class="line">************************************</span><br><span class="line"></span><br><span class="line">Object.clone()总用时：227673ms</span><br><span class="line">System.arraycopy()总用时：227062ms</span><br><span class="line">循环拷贝总用时：242954ms</span><br><span class="line">Arrays.copyOf()总用时：224818ms</span><br></pre></td></tr></table></figure>
<p>可以看到在第一轮的时候，循环拷贝最快，后面就变成最慢的了。</p>
<p>但是这里<code>Arrays.copyOf()</code>比<code>System.arraycopy()</code>快。</p>
<p>算了，随便了，这三个其实速度都差不多，具体速度每次测得的结果都不一样，喜欢用哪一个用哪一个吧。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基础练习-1</title>
    <url>/2019/07/11/2019-07-12-linux-base-practice_1/</url>
    <content><![CDATA[<hr>
<h2 id="创建文件并挂载到swap"><a href="#创建文件并挂载到swap" class="headerlink" title="创建文件并挂载到swap"></a>创建文件并挂载到swap</h2><p>通过<code>free</code>命令查看当前内存使用情况：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ free -m</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line"><span class="function">Mem:           3790         122        3467           8         200        3435</span></span><br><span class="line"><span class="function"><span class="title">Swap</span>:          3071           0        3071</span></span><br></pre></td></tr></table></figure>
<p>首先，需要使用<code>dd</code>命令创建一个固定大小的空文件:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=test.file bs=<span class="number">1</span>M count=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="number">1024</span>+<span class="number">0</span> records <span class="keyword">in</span></span><br><span class="line"><span class="number">1024</span>+<span class="number">0</span> records out</span><br><span class="line"><span class="number">1073741824</span> bytes (<span class="number">1</span>.<span class="number">1</span> GB) copied, <span class="number">0</span>.<span class="number">696093</span> s, <span class="number">1</span>.<span class="number">5</span> GB/s</span><br></pre></td></tr></table></figure>
<p>以上命令就创建了一个大小为1G的文件<code>test.file</code>。</p>
<p>注意到其中<code>if=/dev/zero</code>就是指定输入文件为<code>/dev/zero</code>，类似的还有<code>/dev/null</code>、<code>/dev/random</code>、<code>/dev/urandom</code>。</p>
<ul>
<li><code>/dev/null</code>，“空”设备，也有人称它为黑洞。任何输入到这个“设备”的数据都将被直接丢弃。最常用的用法是把不需要的输出重定向到这个文件。</li>
<li><code>/dev/zero</code>，“零”设备，可以无限的提供空字符（0x00，ASCII代码NUL）。常用来生成一个特定大小的文件。</li>
<li><code>/dev/random</code>，随机数设备，提供不间断的随机字节流。产生随机数据依赖系统中断，当系统中断不足时，/dev/random设备会“挂起”，因而产生数据速度较慢，但随机性好。</li>
<li><code>/dev/urandom</code>，随机数设备，提供不间断的随机字节流。不依赖系统中断，数据产生速度快，但随机性较低。</li>
</ul>
<p>然后，将这个文件转换为swap格式，并挂载：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ mkswap test.file</span><br><span class="line"></span><br><span class="line">Setting up swapspace version <span class="number">1</span>, size = <span class="number">1048572</span> KiB</span><br><span class="line"><span class="function">no label, <span class="title">UUID</span>=<span class="title">ddb65a66</span>-7<span class="title">f6b</span>-4394-8014-8<span class="title">ad22a10a953</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ swapon test.file</span><br><span class="line"></span><br><span class="line"><span class="function">swapon: /<span class="title">home</span>/<span class="title">long</span>/<span class="title">test.file</span>: <span class="title">insecure</span> <span class="title">permissions</span> 0664, 0600 <span class="title">suggested</span>.</span></span><br><span class="line"><span class="function"><span class="title">swapon</span>: /<span class="title">home</span>/<span class="title">long</span>/<span class="title">test.file</span>: <span class="title">insecure</span> <span class="title">file</span> <span class="title">owner</span> 1000, 0 (<span class="title">root</span>) <span class="title">suggested</span>.</span></span><br></pre></td></tr></table></figure>
<p>再次通过<code>free</code>命令查看当前内存使用情况：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ free -m</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line"><span class="function">Mem:           3790         122        2414           8        1252        3408</span></span><br><span class="line"><span class="function"><span class="title">Swap</span>:          4095           0        4095</span></span><br></pre></td></tr></table></figure>
<p>可以看到swap空间增加了1G。</p>
<p>也许你想要将这个swap文件开机自动挂起：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ vim /etc/fstab</span><br><span class="line"></span><br><span class="line">在文件中添加一行：</span><br><span class="line">/home/long/test.file swap swap defaults <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>重启之后可以看到：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ free -m</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line"><span class="function">Mem:           3790         123        3462           8         205        3433</span></span><br><span class="line"><span class="function"><span class="title">Swap</span>:          4095           0        4095</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>可以看到完成了开机自动挂载。</p>
<p>最后，可以相应的通过使用<code>swapoff</code>命令来进行卸载：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ swapoff test.file</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ free -m</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line"><span class="function">Mem:           3790         117        3486           8         186        3448</span></span><br><span class="line"><span class="function"><span class="title">Swap</span>:          3071           0        3071</span></span><br></pre></td></tr></table></figure>
<p>当然还要<strong>删除</strong><code>/etc/fstab</code>中的开机自动挂载的命令。</p>
<hr>
<h2 id="配置静态ip，重启后也能生效，系统可以访问公网"><a href="#配置静态ip，重启后也能生效，系统可以访问公网" class="headerlink" title="配置静态ip，重启后也能生效，系统可以访问公网"></a>配置静态ip，重启后也能生效，系统可以访问公网</h2><p>首先使用<code>ip addr</code>查询当前接口：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ ip addr</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="number">1000</span></span><br><span class="line">    link/loopback <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> brd <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">    inet <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>/<span class="number">8</span> scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::<span class="number">1</span>/<span class="number">128</span> scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">2</span>: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1500</span> qdisc pfifo_fast state UNKNOWN group default qlen <span class="number">1000</span></span><br><span class="line">    link/ether <span class="number">08</span>:<span class="number">00</span>:<span class="number">27</span>:<span class="number">26</span>:e4:<span class="number">08</span> brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet <span class="number">192</span>.<span class="number">168</span>.<span class="number">31</span>.<span class="number">202</span>/<span class="number">24</span> brd <span class="number">192</span>.<span class="number">168</span>.<span class="number">31</span>.<span class="number">255</span> scope global noprefixroute enp0s3</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::ac:cc04:a87b:<span class="number">74</span>ae/<span class="number">64</span> scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>可以看到网卡名为<code>enp0s3</code>，网卡的配置文件在<code>/etc/sysconfig/network-script/</code>目录下，
在其中可以看到当前的网卡配置：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ cat /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br><span class="line"></span><br><span class="line"><span class="built_in">TYPE</span>=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=enp0s3</span><br><span class="line">UUID=<span class="number">0</span>ee98256-fc86-<span class="number">4</span>fbf-aba5-<span class="number">8</span>c46e914fa89</span><br><span class="line">DEVICE=enp0s3</span><br><span class="line">ONBOOT=yes</span><br><span class="line">DNS1=<span class="number">8</span>.<span class="number">8</span>.<span class="number">8</span>.<span class="number">8</span></span><br><span class="line">DNS2=<span class="number">9</span>.<span class="number">9</span>.<span class="number">9</span>.<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>将其中的<code>BOOTPROTO</code>修改为<code>static</code>，再加入静态ip的相关配置，如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=<span class="number">192</span>.<span class="number">168</span>.<span class="number">31</span>.<span class="number">202</span></span><br><span class="line">NETMASK=<span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">0</span></span><br><span class="line">GATEWAY=<span class="number">192</span>.<span class="number">168</span>.<span class="number">31</span>.<span class="number">254</span></span><br></pre></td></tr></table></figure>
<p>重启网络服务：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ systemctl restart network</span><br><span class="line"></span><br><span class="line">$ ip addr</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="number">1000</span></span><br><span class="line">    link/loopback <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> brd <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">    inet <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>/<span class="number">8</span> scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::<span class="number">1</span>/<span class="number">128</span> scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">2</span>: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1500</span> qdisc pfifo_fast state UNKNOWN group default qlen <span class="number">1000</span></span><br><span class="line">    link/ether <span class="number">08</span>:<span class="number">00</span>:<span class="number">27</span>:<span class="number">26</span>:e4:<span class="number">08</span> brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet <span class="number">192</span>.<span class="number">168</span>.<span class="number">31</span>.<span class="number">202</span>/<span class="number">24</span> brd <span class="number">192</span>.<span class="number">168</span>.<span class="number">31</span>.<span class="number">255</span> scope global noprefixroute enp0s3</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::ac:cc04:a87b:<span class="number">74</span>ae/<span class="number">64</span> scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>可以看到已经完成了静态ip的设置，测试连通性：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ping</span> www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="built_in">PING</span> www.a.shifen.com (<span class="number">14</span>.<span class="number">215</span>.<span class="number">177</span>.<span class="number">38</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14</span>.<span class="number">215</span>.<span class="number">177</span>.<span class="number">38</span> (<span class="number">14</span>.<span class="number">215</span>.<span class="number">177</span>.<span class="number">38</span>): icmp_seq=<span class="number">1</span> ttl=<span class="number">53</span> <span class="built_in">time</span>=<span class="number">7</span>.<span class="number">23</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14</span>.<span class="number">215</span>.<span class="number">177</span>.<span class="number">38</span> (<span class="number">14</span>.<span class="number">215</span>.<span class="number">177</span>.<span class="number">38</span>): icmp_seq=<span class="number">2</span> ttl=<span class="number">53</span> <span class="built_in">time</span>=<span class="number">6</span>.<span class="number">77</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14</span>.<span class="number">215</span>.<span class="number">177</span>.<span class="number">38</span> (<span class="number">14</span>.<span class="number">215</span>.<span class="number">177</span>.<span class="number">38</span>): icmp_seq=<span class="number">3</span> ttl=<span class="number">53</span> <span class="built_in">time</span>=<span class="number">7</span>.<span class="number">00</span> ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到网络连接正常，也就完成了静态ip的设置。</p>
<p><strong>问题：</strong></p>
<p>在测试连通性的过程中，会发现主机（win 10）可以ping通虚拟机（centos7.5），但是虚拟机却无法ping通主机，
通过查询博客，发现问题主要是由于win10自带的防火墙造成的，可以通过以下方法来解决这个问题：</p>
<ul>
<li>控制面板-系统和安全-Windows Defender防火墙-高级设置-入站规则-文件和打印机共享(回显请求 - ICMPv4-In)</li>
</ul>
<p>将两条上面名字的入站规则启用，虚拟机就可以向外ping通主机了。</p>
<hr>
<h2 id="手动释放掉系统的全部buffer-cache，使得内存的free增加"><a href="#手动释放掉系统的全部buffer-cache，使得内存的free增加" class="headerlink" title="手动释放掉系统的全部buffer/cache，使得内存的free增加"></a>手动释放掉系统的全部buffer/cache，使得内存的free增加</h2><p>这里需要手动释放内存，主要涉及到的文件就是<code>/proc/sys/vm/drop_caches</code>，通过查询可以了解到，
“/proc/sys是一个虚拟文件系统，可以通过对它的读写操作做为与kernel实体间进行通信的一种手段”，
可以对它进行不同的修改来让内核释放内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Writing to this file causes the kernel to drop clean caches,</span><br><span class="line">dentries and inodes from memory, causing that memory to become free.</span><br><span class="line"></span><br><span class="line">To free pagecache, use</span><br><span class="line">    </span><br><span class="line">    echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches;</span><br><span class="line"></span><br><span class="line">to free dentries and inodes, use</span><br><span class="line"></span><br><span class="line">    echo 2 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches;</span><br><span class="line"></span><br><span class="line">to free pagecache, dentries and inodes, use</span><br><span class="line"></span><br><span class="line">    echo 3 &gt;&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches.</span><br><span class="line"></span><br><span class="line">Because this is a non-destructive operation and dirty objects </span><br><span class="line">are not freeable, the user should run sync first.</span><br></pre></td></tr></table></figure>
<p>可以看到，这里建议在清除内存之间执行<code>sync</code>命令，它将”将有关文件系统的存储器常驻信息送入物理介质内”。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line"><span class="function">Mem:           3.7<span class="title">G</span>        115<span class="title">M</span>        3.4<span class="title">G</span>        8.5<span class="title">M</span>        161<span class="title">M</span>        3.4<span class="title">G</span></span></span><br><span class="line"><span class="function"><span class="title">Swap</span>:          3.0<span class="title">G</span>          0<span class="title">B</span>        3.0<span class="title">G</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">$ <span class="title">sync</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">$ <span class="title">echo</span> 1 &gt; /<span class="title">proc</span>/<span class="title">sys</span>/<span class="title">vm</span>/<span class="title">drop_caches</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">$ <span class="title">free</span> -<span class="title">h</span></span></span><br><span class="line"><span class="function">              <span class="title">total</span>        <span class="title">used</span>        <span class="title">free</span>      <span class="title">shared</span>  <span class="title">buff</span>/<span class="title">cache</span>   <span class="title">available</span></span></span><br><span class="line"><span class="function"><span class="title">Mem</span>:           3.7<span class="title">G</span>        116<span class="title">M</span>        3.5<span class="title">G</span>        8.5<span class="title">M</span>         89<span class="title">M</span>        3.4<span class="title">G</span></span></span><br><span class="line"><span class="function"><span class="title">Swap</span>:          3.0<span class="title">G</span>          0<span class="title">B</span>        3.0<span class="title">G</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>buff/cache</code>从<code>161M</code>变化到了<code>89M</code>。</p>
<hr>
<h2 id="使用systemd的管理方式定制一个开机启动服务"><a href="#使用systemd的管理方式定制一个开机启动服务" class="headerlink" title="使用systemd的管理方式定制一个开机启动服务"></a>使用systemd的管理方式定制一个开机启动服务</h2><p><strong>原理：</strong></p>
<p>systemctl的每一个服务对应一个服务配置文件，以<code>.service</code>结尾，所有有效的服务配置文件默认存放在两个地方，
<code>/usr/lib/systemd/system/</code>这个目录存放的是服务的真实配置文件，<code>/etc/systemd/system/</code>这个目录存放的是
开机自启动的服务，多数为软连接。</p>
<p>启动顺序：</p>
<ol>
<li><p>当运行systemctl命令时，systemctl先去上面/etc/systemd/system目录中找目标service文件，找不到则
去/usr/lib/systemd/system/中找，还找不到就失败。</p>
</li>
<li><p>找到service后，会读取service文件并将@后面的参数传给服务。</p>
</li>
<li><p>开始监控这个服务，接管它的基本操作。</p>
</li>
</ol>
<hr>
<p><strong>目标：</strong></p>
<p>建立一个开机启动服务，每次开机时打印当前时间到<code>/tmp/hello</code>。</p>
<hr>
<p>首先，写好shell脚本：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ cat my_hello.sh</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> +&quot;<span class="variable">%Y-%</span>m-%d <span class="variable">%H:%</span>M:%S --- hello systemd&quot; &gt;&gt; /tmp/hello</span><br></pre></td></tr></table></figure>
<p>然后，编写服务脚本：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ cat my_hello.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=systemd test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="built_in">Type</span>=simple</span><br><span class="line">ExecStart=/home/long/my_hello.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>可以看到这里将<strong>Type</strong>指定为<code>simple</code>，将<code>my_hello.sh</code>作为启动脚本。
更多的<strong>Type</strong>可以参考<a href="https://blog.csdn.net/yuesichiu/article/details/51485147">CentOS 7之Systemd详解之服务单元设置system.service</a>。</p>
<p>将服务脚本复制到<code>/usr/lib/systemd/system/</code>目录下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ cp my_hello.service /usr/lib/systemd/system/</span><br></pre></td></tr></table></figure>
<p>启动服务看是否能够成功：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ systemctl <span class="built_in">start</span> my_hello</span><br><span class="line"></span><br><span class="line">$ cat /tmp/hello</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>-<span class="number">07</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">33</span> --- hello systemd</span><br></pre></td></tr></table></figure>
<p>可以看到服务启动成功，下面将它设置为开机自启：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ systemctl enable my_hello</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/my_hello.service</span><br><span class="line">to /usr/lib/systemd/system/my_hello.service.</span><br></pre></td></tr></table></figure>
<p>可以看到它为服务在<code>/etc/systemd/system</code>目录下创建了软连接。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ reboot</span><br><span class="line"></span><br><span class="line">$ cat /tmp/hello</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>-<span class="number">07</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">33</span> --- hello systemd</span><br><span class="line"><span class="number">2019</span>-<span class="number">07</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">35</span>:<span class="number">44</span> --- hello systemd</span><br></pre></td></tr></table></figure>
<p>可以看到服务自启动成功。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/sinat_26058371/article/details/86754683">Linux中的虚拟设备/dev/null、/dev/zero、/dev/random和/dev/urandom</a></p>
<p><a href="https://www.jianshu.com/p/c5344cfffc20">VirtualBox虚拟机ping不通宿主机解决方案</a></p>
<p><a href="https://www.jianshu.com/p/016f7cf0380d">echo N&gt;/proc/sys/vm/drop_caches清理缓存</a></p>
<p><a href="https://blog.csdn.net/vict_wang/article/details/81099544">Linux sync命令的作用</a></p>
<p><a href="https://www.cnblogs.com/zhouhbing/p/3909408.html">Linux sync命令的作用分析</a></p>
<p><a href="https://blog.csdn.net/yuesichiu/article/details/51485147">CentOS 7之Systemd详解之服务单元设置system.service</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基础练习-2</title>
    <url>/2019/07/15/2019-07-15-linux-base-practice_2/</url>
    <content><![CDATA[<hr>
<h2 id="练习目标"><a href="#练习目标" class="headerlink" title="练习目标"></a>练习目标</h2><p>使用iso镜像搭建一个本地源，安装httpd服务并局域网<code>yum install</code>成功</p>
<h2 id="所需准备"><a href="#所需准备" class="headerlink" title="所需准备"></a>所需准备</h2><ol>
<li>两台centos虚拟机（一般是mini安装），一台作为yum源，一台测试yum源。</li>
<li>一个centos的iso镜像，这里选择的是<code>CentOS-7-x86_64-Everything-1804.iso</code>。</li>
<li>配置好网络，起码两台虚拟机能相互ping通。</li>
</ol>
<hr>
<h2 id="配置本地yum源"><a href="#配置本地yum源" class="headerlink" title="配置本地yum源"></a>配置本地yum源</h2><p><strong>本地yum源</strong>，意思就是只有本机能够使用的yum源，这里需要先配置本地yum源，
然后再将其公布到局域网。</p>
<p>使用iso镜像搭建本地yum源，这里首先将iso镜像进行挂载：</p>
<p><img src="/images/linux/centos/practice/virtualbox挂载镜像.png" alt="images" title="virtualbox挂载镜像"></p>
<p>完成后，iso镜像就已经挂到了<code>/dev/cdrom</code>目录上，新建一个目录将它挂载：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> /mnt/iso</span><br><span class="line">$ mount /dev/cdrom /mnt/iso</span><br><span class="line"></span><br><span class="line"><span class="function">mount: /<span class="title">dev</span>/<span class="title">sr0</span> <span class="title">is</span> <span class="title">write</span>-<span class="title">protected</span>, <span class="title">mounting</span> <span class="title">read</span>-<span class="title">only</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">$ <span class="title">ll</span> /<span class="title">mnt</span>/<span class="title">iso</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">total</span> 1640</span></span><br><span class="line"><span class="function">-<span class="title">rw</span>-<span class="title">rw</span>-<span class="title">r</span>-- 1 <span class="title">root</span> <span class="title">root</span>      14 <span class="title">May</span>  2  2018 <span class="title">CentOS_BuildTag</span></span></span><br><span class="line"><span class="function"><span class="title">drwxr</span>-<span class="title">xr</span>-<span class="title">x</span> 3 <span class="title">root</span> <span class="title">root</span>    2048 <span class="title">May</span>  4  2018 <span class="title">EFI</span></span></span><br><span class="line"><span class="function">-<span class="title">rw</span>-<span class="title">rw</span>-<span class="title">r</span>-- 1 <span class="title">root</span> <span class="title">root</span>     227 <span class="title">Aug</span> 30  2017 <span class="title">EULA</span></span></span><br><span class="line"><span class="function">-<span class="title">rw</span>-<span class="title">rw</span>-<span class="title">r</span>-- 1 <span class="title">root</span> <span class="title">root</span>   18009 <span class="title">Dec</span> 10  2015 <span class="title">GPL</span></span></span><br><span class="line"><span class="function"><span class="title">drwxr</span>-<span class="title">xr</span>-<span class="title">x</span> 3 <span class="title">root</span> <span class="title">root</span>    2048 <span class="title">May</span>  4  2018 <span class="title">images</span></span></span><br><span class="line"><span class="function"><span class="title">drwxr</span>-<span class="title">xr</span>-<span class="title">x</span> 2 <span class="title">root</span> <span class="title">root</span>    2048 <span class="title">May</span>  4  2018 <span class="title">isolinux</span></span></span><br><span class="line"><span class="function"><span class="title">drwxr</span>-<span class="title">xr</span>-<span class="title">x</span> 2 <span class="title">root</span> <span class="title">root</span>    2048 <span class="title">May</span>  4  2018 <span class="title">LiveOS</span></span></span><br><span class="line"><span class="function"><span class="title">drwxrwxr</span>-<span class="title">x</span> 2 <span class="title">root</span> <span class="title">root</span> 1640448 <span class="title">May</span>  3  2018 <span class="title">Packages</span></span></span><br><span class="line"><span class="function"><span class="title">drwxrwxr</span>-<span class="title">x</span> 2 <span class="title">root</span> <span class="title">root</span>    4096 <span class="title">May</span>  7  2018 <span class="title">repodata</span></span></span><br><span class="line"><span class="function">-<span class="title">rw</span>-<span class="title">rw</span>-<span class="title">r</span>-- 1 <span class="title">root</span> <span class="title">root</span>    1690 <span class="title">Dec</span> 10  2015 <span class="title">RPM</span>-<span class="title">GPG</span>-<span class="title">KEY</span>-<span class="title">CentOS</span>-7</span></span><br><span class="line"><span class="function">-<span class="title">rw</span>-<span class="title">rw</span>-<span class="title">r</span>-- 1 <span class="title">root</span> <span class="title">root</span>    1690 <span class="title">Dec</span> 10  2015 <span class="title">RPM</span>-<span class="title">GPG</span>-<span class="title">KEY</span>-<span class="title">CentOS</span>-<span class="title">Testing</span>-7</span></span><br><span class="line"><span class="function">-<span class="title">r</span>--<span class="title">r</span>--<span class="title">r</span>-- 1 <span class="title">root</span> <span class="title">root</span>    2883 <span class="title">May</span>  7  2018 <span class="title">TRANS.TBL</span></span></span><br></pre></td></tr></table></figure>
<p>然后将这些文件都复制出来（貌似也可以不复制出来，直接使用<code>/mnt/iso</code>目录作为本地源目录）：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> /home/long/yum</span><br><span class="line">$ cp -r /mnt/iso/* /home/long/yum</span><br></pre></td></tr></table></figure>
<p>将现有的.repo文件备份，随便新建或者复制一个.repo文件，修改其中的内容：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line">$ <span class="built_in">mkdir</span> bak</span><br><span class="line">$ mv *.repo bak</span><br><span class="line">$ cp bak/CentOS-Base.repo .</span><br><span class="line">$ vim CentOS-Base.repo</span><br><span class="line"></span><br><span class="line">[base]      # yun源的名字，唯一即可</span><br><span class="line">name=CentOS-$releasever - Base  # 注释信息，随便</span><br><span class="line">baseurl=file:///home/long/yum         # yum源路径，支持三种协议：http、ftp、file</span><br><span class="line">enabled=<span class="number">1</span>     # <span class="number">1</span>表示启用，<span class="number">0</span>表示禁用</span><br><span class="line">gpgcheck=<span class="number">0</span>     # 指纹校验，为<span class="number">0</span>表示不校验</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-<span class="number">7</span>     #校验参考的文件</span><br></pre></td></tr></table></figure>
<p>清除默认源，重新缓存本地源：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ yum clean all</span><br><span class="line"></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Cleaning repos: base</span><br><span class="line">Cleaning up everything</span><br><span class="line">Maybe you want: rm -rf /var/cache/yum, to also free up space taken by orphaned data from disabled or removed repos</span><br><span class="line">Cleaning up list of fastest mirrors</span><br><span class="line"></span><br><span class="line">$ yum makecache</span><br><span class="line"></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Determining fastest mirrors</span><br><span class="line">base                                                                                                                                                | <span class="number">3</span>.<span class="number">6</span> kB  <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>     </span><br><span class="line">(<span class="number">1</span>/<span class="number">4</span>): base/group_gz                                                                                                                                | <span class="number">166</span> kB  <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>     </span><br><span class="line">(<span class="number">2</span>/<span class="number">4</span>): base/primary_db                                                                                                                              | <span class="number">5</span>.<span class="number">9</span> MB  <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>     </span><br><span class="line">(<span class="number">3</span>/<span class="number">4</span>): base/filelists_db                                                                                                                            | <span class="number">6</span>.<span class="number">9</span> MB  <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>     </span><br><span class="line">(<span class="number">4</span>/<span class="number">4</span>): base/other_db                                                                                                                                | <span class="number">2</span>.<span class="number">5</span> MB  <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>     </span><br><span class="line">Metadata Cache Created</span><br><span class="line"></span><br><span class="line">$ yum list</span><br></pre></td></tr></table></figure>
<p>测试本地yum源是否配置成功：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ yum install httpd</span><br><span class="line">$ yum install wget</span><br></pre></td></tr></table></figure>
<p>到这里本地yum源就搭建成功了</p>
<h2 id="配置局域网yum源"><a href="#配置局域网yum源" class="headerlink" title="配置局域网yum源"></a>配置局域网yum源</h2><p>上面已经安装了httpd服务（<code>yum install httpd</code>），它默认的目录是<code>/var/www/html</code>，这里需要对它进行修改：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ rm -rf /var/www/html</span><br><span class="line">$ ln -s /home/long/yum /var/www/html </span><br></pre></td></tr></table></figure>
<p>下面启动httpd服务，随便把它设置为开机自启：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ systemctl enable httpd</span><br><span class="line">$ systemctl <span class="built_in">start</span> httpd</span><br></pre></td></tr></table></figure>
<p>验证是否启动成功，在另一台虚拟机上进行测试：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ wget http://<span class="number">192</span>.<span class="number">168</span>.<span class="number">31</span>.<span class="number">201</span>/RPM-GPG-KEY-CentOS-<span class="number">7</span></span><br><span class="line"></span><br><span class="line">--<span class="number">2019</span>-<span class="number">07</span>-<span class="number">15</span> <span class="number">17</span>:<span class="number">55</span>:<span class="number">08</span>--  http://<span class="number">192</span>.<span class="number">168</span>.<span class="number">31</span>.<span class="number">201</span>/RPM-GPG-KEY-CentOS-<span class="number">7</span></span><br><span class="line">Connecting to <span class="number">192</span>.<span class="number">168</span>.<span class="number">31</span>.<span class="number">201</span>:<span class="number">80</span>... connected.</span><br><span class="line">HTTP request sent, awaiting response... <span class="number">200</span> OK</span><br><span class="line"><span class="function">Length: 1690 (1.7<span class="title">K</span>)</span></span><br><span class="line"><span class="function"><span class="title">Saving</span> <span class="title">to</span>: ‘<span class="title">RPM</span>-<span class="title">GPG</span>-<span class="title">KEY</span>-<span class="title">CentOS</span>-7’</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">100%[=================================================================================================================================&gt;] 1,690       --.-<span class="title">K</span>/<span class="title">s</span>   <span class="title">in</span> 0<span class="title">s</span>      </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2019-07-15 17:55:08 (3.62 <span class="title">MB</span>/<span class="title">s</span>) - ‘<span class="title">RPM</span>-<span class="title">GPG</span>-<span class="title">KEY</span>-<span class="title">CentOS</span>-7’ <span class="title">saved</span> [1690/1690]</span></span><br></pre></td></tr></table></figure>
<p>这里就完成了局域网yum源的配置。</p>
<h2 id="使用局域网yum源"><a href="#使用局域网yum源" class="headerlink" title="使用局域网yum源"></a>使用局域网yum源</h2><p>方法和使用本地yum源一样，唯一不一样的地方在于将file修改为http:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ vim CentOS-Base.repo</span><br><span class="line"></span><br><span class="line">[base]</span><br><span class="line">name=CentOS-$releasever - Base</span><br><span class="line">baseurl=http://<span class="number">192</span>.<span class="number">168</span>.<span class="number">31</span>.<span class="number">201</span>:<span class="number">80</span>/</span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">0</span></span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>尝试使用：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ yum install vim</span><br><span class="line"></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Package matching <span class="number">2</span>:vim-enhanced-<span class="number">7</span>.<span class="number">4</span>.<span class="number">160</span>-<span class="number">4</span>.el7.x86_64 already installed. Checking <span class="keyword">for</span> update.</span><br><span class="line">Nothing to <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p><strong>ok</strong></p>
<h2 id="过程中的问题"><a href="#过程中的问题" class="headerlink" title="过程中的问题"></a>过程中的问题</h2><p><strong>403 Forbidden:</strong></p>
<p>在执行<code>wget http://192.168.31.201/RPM-GPG-KEY-CentOS-7</code>命令时，出现403错误。</p>
<p>这里可能是由于一下的问题造成的：</p>
<ul>
<li>防火墙问题。解决办法：关闭防火墙。</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ systemctl status firewalld</span><br><span class="line">$ systemctl disable firewalld</span><br><span class="line">$ systemctl stop firewalld</span><br></pre></td></tr></table></figure>
<ul>
<li>selinux问题。解决办法：关闭selinux。</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ getenforce</span><br><span class="line"></span><br><span class="line">Enforcing</span><br><span class="line"></span><br><span class="line">$ vim /etc/sysconfig/selinux</span><br><span class="line"></span><br><span class="line">SELINUX=disabled</span><br><span class="line"></span><br><span class="line">$ reboot</span><br><span class="line"></span><br><span class="line">$ getenforce</span><br><span class="line"></span><br><span class="line">Disabled</span><br></pre></td></tr></table></figure>
<ul>
<li>权限问题。解决办法：修改yum源目录的权限。</li>
</ul>
<p>在centos上，httpd的log文件记录在<code>/var/log/httpd/</code>目录下，有<code>access_log</code>和<code>error_log</code>，
在<code>access_log</code>中可以看到接入信息，<code>error_log</code>中可以看到错误信息，这些信息十分有用。</p>
<p>查看<code>error_log</code>:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ sudo tail /var/log/httpd/error_log</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">[Mon Jul <span class="number">15</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">49</span>.<span class="number">577353</span> <span class="number">2019</span>] [core:error] [pid <span class="number">1303</span>] [client <span class="number">192</span>.<span class="number">168</span>.<span class="number">31</span>.<span class="number">202</span>:<span class="number">37660</span>] AH00037: Symbolic link <span class="keyword">not</span> allowed or link target <span class="keyword">not</span> accessible: /var/www/html</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到问题在于权限不够，这里需要将<code>/home/long/yum</code>从上到下这几个目录都添加执行权限：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ chmod -R +x /home</span><br></pre></td></tr></table></figure>
<p>当然这样将所有的文件和文件夹都添加了执行权限，实际上应该只需要将文件夹添加可执行权限就好。</p>
<h2 id="2019-07-18补充"><a href="#2019-07-18补充" class="headerlink" title="2019-07-18补充"></a>2019-07-18补充</h2><p>在上面的操作过程中，使用的是iso镜像，镜像是已经建立成repo仓库的，所以可以直接使用。
<strong>但是</strong>，如果现在有一堆rpm文件在一个文件夹下，直接像上面那样是不行的，因为它还不是一个repo仓库，
简单来说就是文件中不包含<code>repodata</code>文件夹。</p>
<p>所以这里引入<strong>createrepo</strong>命令来将一个文件夹做成一个repo仓库。</p>
<p>可以直接使用yum安装它：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ sudo yum install createrepo</span><br></pre></td></tr></table></figure>
<p>比如将文件夹/home/tmp创建为repo仓库：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ createrepo -p -d -o /home/tmp /home/tmp</span><br></pre></td></tr></table></figure>
<p>如果在文件夹中又加入了新的rpm文件，则需要更新仓库：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ createrepo --update /home/tmp</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/Karloo/article/details/80282488">CentOS7 配置局域网内软件源 http模式</a></p>
<p><a href="https://blog.csdn.net/xin_y/article/details/79007986">临时和永久关闭Selinux</a></p>
<p><a href="https://allenzhang.iteye.com/blog/1098700">解决Symbolic link not allowed or link target not accessible问题一例</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7上的ceph指定版本安装方法</title>
    <url>/2019/07/18/2019-07-18-ceph-install/</url>
    <content><![CDATA[<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在centos7.5中，安装ceph-13.2.5版本，能使用<code>ceph -s</code>命令查询到<strong>HEALTH_OK</strong>为止。</p>
<p>通过查询ceph官网以及各种博客可以知道，大概有以下几种ceph安装方法：</p>
<ol>
<li>按照ceph官网教程，使用ceph-deploy工具进行安装。</li>
<li>按照ceph官网教程，下载源码并编译安装。</li>
<li>使用yum直接进行安装。</li>
</ol>
<p>上面的三个方法我都尝试了，只有第三种方法是最靠谱的，也只有这种方法完成了集群搭建。</p>
<p>在大量的尝试安装之后，总结流程如下：</p>
<ol>
<li>首先，按照官网教程完成前期准备工作。</li>
<li>其次，在用于搭建集群的每一台虚拟机上安装ceph-13.2.5。</li>
<li>最后，使用第一步搭好的ceph-deploy主机完成后续的集群搭建。</li>
</ol>
<p>也就是<strong>99%</strong>参考官网教程，但是<strong>取代</strong>其中的<code>ceph-deploy install XXX XXX XXX</code>这一步。</p>
<p>下面依次叙述各个步骤。</p>
<hr>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p><strong>难度：简单。</strong></p>
<p><img src="/images/linux/ceph/ceph-install-step1.png" alt="images" title="安装ceph的准备工作"></p>
<p>在ceph官网可以看到如何进行前期的准备（蓝色框部分），还是很详细的，<a href="http://docs.ceph.com/docs/master/start/">INSTALLATION (CEPH-DEPLOY)</a>。</p>
<p>这里同样参考官网教程，起了4台虚拟机，一台作为ceph-deploy，另外三台用于搭建cluster。</p>
<p><strong>注意事项：</strong></p>
<p>最好将每一台虚拟机上的<code>/etc/hosts</code>文件都进行修改，例如这里添加了下面内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.31.203 node1</span><br><span class="line">192.168.31.204 node2</span><br><span class="line">192.168.31.205 node3</span><br></pre></td></tr></table></figure>
<p>这里的node1、node2、node3就是用来搭集群的三台虚拟机，不包含ceph-deploy虚拟机。
做这件事主要是因为后面在使用<code>ceph-deploy mon create-initial</code>这个命令时，它使用到这些修改后的hostname去创建文件，
在没有添加以上内容的机器上，就会使用localhost来代替本机，可能造成名称不同步而出现<strong>找不到文件的ERROR</strong>。</p>
<hr>
<h2 id="在用于搭建集群的每一台虚拟机上安装ceph-13-2-5"><a href="#在用于搭建集群的每一台虚拟机上安装ceph-13-2-5" class="headerlink" title="在用于搭建集群的每一台虚拟机上安装ceph-13.2.5"></a>在用于搭建集群的每一台虚拟机上安装ceph-13.2.5</h2><p><strong>难度：困难。</strong></p>
<p>实际上在第一次成功装上之后，你就会发现这其实是一件十分简单的事情，
但是要到达第一次成功安装，有一个十分艰难的过程。</p>
<hr>
<p><strong>方法一：使用ceph-deploy工具进行安装。</strong></p>
<p>在官网的教程中，就是使用ceph-deploy来进行ceph的安装的，但是在使用过程中会发现，
使用它安装只能指定<strong>大版本号</strong>（例如：mimic），而mimic现在的最新版本是13.2.6，
这里所需要的是13.2.5，使用它进行安装，就只能安装13.2.6。</p>
<p>当然在通过<code>ceph-deploy install -h</code>命令可以看到它可以指定镜像源<code>--local-mirror</code>，如果你有一个完整的本地ceph13.2.5的源，
也许用它来安装13.2.5也是可以的。</p>
<p>另外的问题是，就算你要装的就是13.2.6版本，在国内进行<code>ceph-deploy install XXX</code>时还是很容易出现error，因为一些依赖包可能会下载失败。</p>
<p>结论：方法一不合适。</p>
<hr>
<p><strong>方法二：下载源码并编译安装。</strong></p>
<p>在使用ceph-deploy工具受挫之后，这里也尝试了使用源码进行编译安装。</p>
<p><img src="/images/linux/ceph/ceph-install-manual.png" alt="images" title="源码安装ceph"></p>
<p>如上图中的蓝色框部分，就是官网教你如何源码编译安装的过程。</p>
<p>当然，这一步我还是失败了，因为在执行make时，速度非常慢，而且它还会去下载各种包，
当它编译了<strong>4</strong>个小时之后，卡在了一个依赖包，又等了<strong>1</strong>个小时，它一点没动，只能ctrl+c，
再进行make就直接error了。</p>
<p>所有这里如果你想进行make，那先shutdown虚拟机，并多分几个cpu，在make时，使用<code>make -j4</code>开启多线程，
会快很多，当然，过程中还是有可能失败，但至少不用等这么久！</p>
<p>结论：方法二不合适。</p>
<hr>
<p><strong>方法三：直接使用yum指定版本号安装。</strong></p>
<p><strong>难度：简单。</strong></p>
<p>在前辈的指点之下，发现原来yum直接可以指定版本号进行安装？？？</p>
<p>这里所需的命令就是:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y ceph-<span class="number">13</span>.<span class="number">2</span>.<span class="number">5</span> ceph-radosgw-<span class="number">13</span>.<span class="number">2</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>所以其实最简单的方法就是：</p>
<ol>
<li>配置ceph源（建议使用国内源，我这里使用了网易源）。</li>
<li>确定安装了epel-release。</li>
<li><code>sudo yum install -y ceph-13.2.5 ceph-radosgw-13.2.5</code>一定要两个一起安装，并都带上版本号。</li>
</ol>
<p>结论：方法三合适。</p>
<hr>
<p><strong>真正使用的方法：在方法三的基础上，建立局域网源。</strong></p>
<p>使用局域网源的好处就是快，而且不会在安装时给你报个错，所以可以在方法三的基础上制作一个ceph局域网源。</p>
<p>关键命令就是：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ sudo yum install --downloadonly --downloaddir=/home/long/yum/ceph-<span class="number">13</span>.<span class="number">2</span>.<span class="number">5</span> ceph-<span class="number">13</span>.<span class="number">2</span>.<span class="number">5</span> ceph-radosgw-<span class="number">13</span>.<span class="number">2</span>.<span class="number">5</span> </span><br></pre></td></tr></table></figure>
<p>使用了<code>--downloadonly</code>指令之后，yum就不会真正去安装ceph，而是将ceph以及它所有的相关依赖（本机上没有的）都下载下来。</p>
<p>为了获得完成的依赖，可以安装一个minimum版本（不是minimum安装，而是iso镜像就是minimum）的centos7.5，
然后在它上面不装东西，而只用来获取所有的依赖。</p>
<p>所以这里的操作步骤就是：</p>
<ol>
<li>安装一个minimum版本的centos7.5（非必须，但这样保证没有问题）。</li>
<li><code>sudo yum install --downloadonly --downloaddir=/home/long/yum/ceph-13.2.5 ceph-13.2.5 ceph-radosgw-13.2.5</code>获取所有依赖。</li>
<li>参考之前的方法建立局域网源<a href="http://longrm.com/2019/07/15/2019-07-15-linux-base-practice_2/">linux基础练习-2</a></li>
<li>在需要安装ceph的虚拟机上修改repo为局域网repo，然后进行ceph安装。</li>
</ol>
<hr>
<h2 id="使用第一步搭好的ceph-deploy主机完成后续的集群搭建"><a href="#使用第一步搭好的ceph-deploy主机完成后续的集群搭建" class="headerlink" title="使用第一步搭好的ceph-deploy主机完成后续的集群搭建"></a>使用第一步搭好的ceph-deploy主机完成后续的集群搭建</h2><p>这里同样的，直接参考官方教程即可：</p>
<p><img src="/images/linux/ceph/ceph-install-step2.png" alt="images" title="集群搭建"></p>
<p>其它的步骤都一样，只是<code>ceph-deploy install xxx xxx xxx</code>这一步我们已经在上一步完成了。</p>
<p>可以看到我这里终于完成了集群的搭建：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ ssh node1 sudo ceph -s</span><br><span class="line"></span><br><span class="line"><span class="function">  cluster:</span></span><br><span class="line"><span class="function">    <span class="title">id</span>:     082<span class="title">d1625</span>-1<span class="title">d68</span>-4261-82<span class="title">c8</span>-3<span class="title">fe9fe3ef489</span></span></span><br><span class="line"><span class="function">    <span class="title">health</span>: <span class="title">HEALTH_OK</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">  <span class="title">services</span>:</span></span><br><span class="line"><span class="function">    <span class="title">mon</span>: 3 <span class="title">daemons</span>, <span class="title">quorum</span> <span class="title">node1</span>,<span class="title">node2</span>,<span class="title">node3</span></span></span><br><span class="line"><span class="function">    <span class="title">mgr</span>: <span class="title">node1</span>(<span class="title">active</span>), <span class="title">standbys</span>: <span class="title">node2</span>, <span class="title">node3</span></span></span><br><span class="line"><span class="function">    <span class="title">osd</span>: 3 <span class="title">osds</span>: 3 <span class="title">up</span>, 3 <span class="title">in</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">  <span class="title">data</span>:</span></span><br><span class="line"><span class="function">    <span class="title">pools</span>:   0 <span class="title">pools</span>, 0 <span class="title">pgs</span></span></span><br><span class="line"><span class="function">    <span class="title">objects</span>: 0  <span class="title">objects</span>, 0 <span class="title">B</span></span></span><br><span class="line"><span class="function">    <span class="title">usage</span>:   3.0 <span class="title">GiB</span> <span class="title">used</span>, 27 <span class="title">GiB</span> / 30 <span class="title">GiB</span> <span class="title">avail</span></span></span><br><span class="line"><span class="function">    <span class="title">pgs</span>:     </span></span><br></pre></td></tr></table></figure>
<p>这里每一个osd上挂载了一个10G的虚拟硬盘，第一个硬盘什么都没做直接挂在了osd上，
另外两个先创建成lvm分区（比较推荐）再进行的挂载。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://docs.ceph.com/docs/master/start/">INSTALLATION (CEPH-DEPLOY)</a></p>
<p><a href="http://www.strugglesquirrel.com/2019/04/23/centos7%E9%83%A8%E7%BD%B2ceph/">centos7部署ceph</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7中lvm分区的创建与扩展</title>
    <url>/2019/07/23/2019-07-23-centos-lvm-create-extend/</url>
    <content><![CDATA[<hr>
<h2 id="创建LVM分区"><a href="#创建LVM分区" class="headerlink" title="创建LVM分区"></a>创建LVM分区</h2><p>首先，挂载虚拟硬盘到虚拟机上，这里挂了2个1T的硬盘。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsblk</span></span><br><span class="line"></span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0  100G  0 disk </span><br><span class="line">├─sda1            8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2            8:2    0   99G  0 part </span><br><span class="line">  ├─centos-root 253:0    0   50G  0 lvm  /</span><br><span class="line">  ├─centos-swap 253:1    0  9.8G  0 lvm  [SWAP]</span><br><span class="line">  └─centos-home 253:2    0 39.2G  0 lvm  /home</span><br><span class="line">sdb               8:16   0    1T  0 disk </span><br><span class="line">sdc               8:32   0    1T  0 disk </span><br><span class="line">sr0              11:0    1 1024M  0 rom  </span><br><span class="line"></span><br><span class="line">// 创建物理卷</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo pvcreate /dev/sdb</span></span><br><span class="line"></span><br><span class="line">  Physical volume &quot;/dev/sdb&quot; successfully created.</span><br><span class="line"></span><br><span class="line">// 创建卷组</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vgcreate VG1 /dev/sdb</span></span><br><span class="line"></span><br><span class="line">  Volume group &quot;VG1&quot; successfully created</span><br><span class="line"></span><br><span class="line">// 查看卷组剩多少PE</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vgdisplay</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               VG1</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  7</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                1</span><br><span class="line">  Open LV               0</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               &lt;2.00 TiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              524286</span><br><span class="line">  Alloc PE / Size       262143 / &lt;1024.00 GiB</span><br><span class="line">  Free  PE / Size       262143 / &lt;1024.00 GiB     //剩余空间大小</span><br><span class="line">  VG UUID               DYPyVN-9ssj-pLxN-bksi-9U0V-m2wQ-aQ3IPe</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">// 将所有剩余空间创建为逻辑卷</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo lvcreate -l 262143 -n MyLvm0 VG1</span></span><br><span class="line"></span><br><span class="line">  Logical volume &quot;MyLvm0&quot; created.</span><br><span class="line"></span><br><span class="line">// 创建完成</span><br><span class="line"><span class="meta">$</span><span class="bash"> lsblk</span></span><br><span class="line"></span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0  100G  0 disk </span><br><span class="line">├─sda1            8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2            8:2    0   99G  0 part </span><br><span class="line">  ├─centos-root 253:0    0   50G  0 lvm  /</span><br><span class="line">  ├─centos-swap 253:1    0  9.8G  0 lvm  [SWAP]</span><br><span class="line">  └─centos-home 253:2    0 39.2G  0 lvm  /home</span><br><span class="line">sdb               8:16   0    1T  0 disk </span><br><span class="line">└─VG1-MyLvm0    253:3    0 1024G  0 lvm        // 所创建的LVM逻辑卷</span><br><span class="line">sdc               8:32   0    1T  0 disk </span><br><span class="line">sr0              11:0    1 1024M  0 rom  </span><br></pre></td></tr></table></figure></h2><h2 id="扩展LVM分区"><a href="#扩展LVM分区" class="headerlink" title="扩展LVM分区"></a>扩展LVM分区</h2><p>上面使用了一块1T虚拟硬盘，下面将另外一块虚拟硬盘添加到刚才的逻辑卷中，实现扩展。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsblk</span></span><br><span class="line"></span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0  100G  0 disk </span><br><span class="line">├─sda1            8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2            8:2    0   99G  0 part </span><br><span class="line">  ├─centos-root 253:0    0   50G  0 lvm  /</span><br><span class="line">  ├─centos-swap 253:1    0  9.8G  0 lvm  [SWAP]</span><br><span class="line">  └─centos-home 253:2    0 39.2G  0 lvm  /home</span><br><span class="line">sdb               8:16   0    1T  0 disk </span><br><span class="line">└─VG1-MyLvm0    253:3    0 1024G  0 lvm        // 需要扩展的LVM逻辑卷</span><br><span class="line">sdc               8:32   0    1T  0 disk       // 额外的空间</span><br><span class="line">sr0              11:0    1 1024M  0 rom  </span><br><span class="line"></span><br><span class="line">// 创建物理卷</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo pvcreate /dev/sdc</span></span><br><span class="line"></span><br><span class="line">  Physical volume &quot;/dev/sdc&quot; successfully created.</span><br><span class="line"></span><br><span class="line">// 将它加入到卷组</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vgextend VG1 /dev/sdc</span></span><br><span class="line"></span><br><span class="line">  Volume group &quot;VG1&quot; successfully extended</span><br><span class="line"></span><br><span class="line">// 扩展逻辑卷MyLvm0</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo lvextend -l +262142 /dev/VG1/MyLvm0</span></span><br><span class="line"></span><br><span class="line">  Size of logical volume VG1/MyLvm0 changed from 1.00 TiB (262144 extents) to &lt;2.00 TiB (524286 extents).</span><br><span class="line">  Logical volume VG1/MyLvm0 successfully resized.</span><br><span class="line"></span><br><span class="line">// 成功扩展</span><br><span class="line"><span class="meta">$</span><span class="bash"> lsblk</span></span><br><span class="line"></span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0  100G  0 disk </span><br><span class="line">├─sda1            8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2            8:2    0   99G  0 part </span><br><span class="line">  ├─centos-root 253:0    0   50G  0 lvm  /</span><br><span class="line">  ├─centos-swap 253:1    0  9.8G  0 lvm  [SWAP]</span><br><span class="line">  └─centos-home 253:2    0 39.2G  0 lvm  /home</span><br><span class="line">sdb               8:16   0    1T  0 disk </span><br><span class="line">└─VG1-MyLvm0    253:3    0    2T  0 lvm  </span><br><span class="line">sdc               8:32   0    1T  0 disk </span><br><span class="line">└─VG1-MyLvm0    253:3    0    2T  0 lvm  </span><br><span class="line">sr0              11:0    1 1024M  0 rom  </span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/youn/p/6079376.html">Linux下添加磁盘创建lvm分区</a></p>
<p><a href="https://www.cnblogs.com/weiyiming007/p/9517484.html">centos7用lvm扩展xfs文件系统的根分区</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph-13.2.5删除osd，新建osd</title>
    <url>/2019/07/19/2019-07-19-ceph-osd-create-remove/</url>
    <content><![CDATA[<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在搭建集群的时候，在node2上挂了一个lvm格式的osd（VG1/MyLvm），10G大小，想着既然是lvm，那就可以直接扩容，
所以又加了一个10G的虚拟硬盘，并扩容进了VG1/MyLvm，结果就是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lsblk</span></span><br><span class="line"></span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0   20G  0 disk </span><br><span class="line">├─sda1            8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2            8:2    0   19G  0 part </span><br><span class="line">  ├─centos-root 253:0    0   17G  0 lvm  /</span><br><span class="line">  └─centos-swap 253:1    0    2G  0 lvm  [SWAP]</span><br><span class="line">sdb               8:16   0   10G  0 disk </span><br><span class="line">└─sdb1            8:17   0   10G  0 part </span><br><span class="line">  └─VG1-MyLvm   253:2    0   20G  0 lvm  </span><br><span class="line">sdc               8:32   0   10G  0 disk </span><br><span class="line">└─sdc1            8:33   0   10G  0 part </span><br><span class="line">  └─VG1-MyLvm   253:2    0   20G  0 lvm  </span><br><span class="line">sr0              11:0    1 1024M  0 rom </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vgdisplay</span></span><br><span class="line"></span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               centos</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  3</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                2</span><br><span class="line">  Open LV               2</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               &lt;19.00 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              4863</span><br><span class="line">  Alloc PE / Size       4863 / &lt;19.00 GiB</span><br><span class="line">  Free  PE / Size       0 / 0   </span><br><span class="line">  VG UUID               fEJqFf-qaqN-ZeZe-3FG1-Jeya-SyAi-WCtB0u</span><br><span class="line">   </span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               VG1</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  39</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                1</span><br><span class="line">  Open LV               1</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               19.99 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              5118</span><br><span class="line">  Alloc PE / Size       5118 / 19.99 GiB</span><br><span class="line">  Free  PE / Size       0 / 0   </span><br><span class="line">  VG UUID               OMx43d-hsd1-80vh-DCvO-870t-zPSn-123yoU</span><br></pre></td></tr></table></figure>
<p>首先可以看到逻辑卷MyLvm的确变成了20G大小。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph osd df tree</span></span><br><span class="line"></span><br><span class="line">ID CLASS WEIGHT  REWEIGHT SIZE   USE     AVAIL   %USE  VAR  PGS TYPE NAME      </span><br><span class="line">-1       0.02939        - 40 GiB  13 GiB  27 GiB 33.56 1.00   - root default   </span><br><span class="line">-3       0.00980        - 10 GiB 1.1 GiB 8.9 GiB 11.42 0.34   -     host node1 </span><br><span class="line"> 0   hdd 0.00980  1.00000 10 GiB 1.1 GiB 8.9 GiB 11.42 0.34  68         osd.0  </span><br><span class="line">-5       0.00980        - 20 GiB  11 GiB 8.9 GiB 55.71 1.66   -     host node2 </span><br><span class="line"> 1   hdd 0.00980  1.00000 20 GiB  11 GiB 8.9 GiB 55.71 1.66   0         osd.1  </span><br><span class="line">-7       0.00980        - 10 GiB 1.1 GiB 8.9 GiB 11.42 0.34   -     host node3 </span><br><span class="line"> 2   hdd 0.00980  1.00000 10 GiB 1.1 GiB 8.9 GiB 11.42 0.34  68         osd.2  </span><br><span class="line">                    TOTAL 40 GiB  13 GiB  27 GiB 33.56    </span><br></pre></td></tr></table></figure>
<p>可以看到<code>osd.1</code>的容量的确变成了20G，<strong>但是</strong>已经用了<strong>11G</strong>？？？
<strong>刚挂上去的10G空间全部被标记为使用？？？</strong></p>
<p>不明白这是什么原理，可能这样去扩容是不对的，为了把这10G空间夺取回来，
决定先删除osd.1，清空lvm卷，再把它加回来。</p>
<hr>
<h2 id="删除osd"><a href="#删除osd" class="headerlink" title="删除osd"></a>删除osd</h2><p>这里直接参考官方教程<a href="http://docs.ceph.com/docs/master/rados/operations/add-or-rm-osds/">ADDING/REMOVING OSDS</a></p>
<p>步骤即：</p>
<ol>
<li>将osd设置为out。</li>
<li>关闭正在运行的osd进程。</li>
<li>从<code>crush map</code>中删除它。</li>
<li>删除<code>OSD authentication key</code>。</li>
<li>删除osd。</li>
</ol>
<p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph osd out osd.1</span></span><br><span class="line"></span><br><span class="line">marked out osd.1.</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl stop ceph-osd@1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph osd crush remove osd.1</span></span><br><span class="line"></span><br><span class="line">removed item id 1 name &#x27;osd.1&#x27; from crush map</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph auth del osd.1</span></span><br><span class="line"></span><br><span class="line">updated</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph osd rm 1</span></span><br><span class="line"></span><br><span class="line">removed osd.1</span><br></pre></td></tr></table></figure>
<p>查看集群状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph -s</span></span><br><span class="line"></span><br><span class="line">  cluster:</span><br><span class="line">    id:     082d1625-1d68-4261-82c8-3fe9fe3ef489</span><br><span class="line">    health: HEALTH_WARN</span><br><span class="line">            Degraded data redundancy: 256/768 objects degraded (33.333%), 32 pgs degraded, 68 pgs undersized</span><br><span class="line"> </span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum node1,node2,node3</span><br><span class="line">    mgr: node1(active), standbys: node3, node2</span><br><span class="line">    mds: fs_test-1/1/1 up  &#123;0=node1=up:active&#125;</span><br><span class="line">    osd: 2 osds: 2 up, 2 in</span><br><span class="line">    rgw: 1 daemon active</span><br><span class="line"> </span><br><span class="line">  data:</span><br><span class="line">    pools:   8 pools, 68 pgs</span><br><span class="line">    objects: 256  objects, 136 MiB</span><br><span class="line">    usage:   2.3 GiB used, 18 GiB / 20 GiB avail</span><br><span class="line">    pgs:     256/768 objects degraded (33.333%)</span><br><span class="line">             36 active+undersized</span><br><span class="line">             32 active+undersized+degraded</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph osd df tree</span></span><br><span class="line"></span><br><span class="line">ID CLASS WEIGHT  REWEIGHT SIZE   USE     AVAIL   %USE  VAR  PGS TYPE NAME      </span><br><span class="line">-1       0.01959        - 10 GiB 1.1 GiB 8.8 GiB     0    0   - root default   </span><br><span class="line">-3       0.00980        - 10 GiB 1.1 GiB 8.8 GiB 11.48 1.00   -     host node1 </span><br><span class="line"> 0   hdd 0.00980  1.00000 10 GiB 1.1 GiB 8.8 GiB 11.48 1.00  68         osd.0  </span><br><span class="line">-5             0        -    0 B     0 B     0 B     0    0   -     host node2 </span><br><span class="line">-7       0.00980        - 10 GiB 1.1 GiB 8.8 GiB 11.48 1.00   -     host node3 </span><br><span class="line"> 2   hdd 0.00980  1.00000 10 GiB 1.1 GiB 8.8 GiB 11.48 1.00  68         osd.2  </span><br><span class="line">                    TOTAL 20 GiB 2.3 GiB  18 GiB 11.48                         </span><br></pre></td></tr></table></figure>
<p>可以看到<code>osd.1</code>已经删除，这里的WARN是因为只有两个osd节点造成的。</p>
<hr>
<h2 id="创建osd"><a href="#创建osd" class="headerlink" title="创建osd"></a>创建osd</h2><hr>
<p><strong>方法一：使用ceph-deploy。</strong></p>
<p>因为这里相当于是撤下来的盘，所以先将它里面的内容擦除，借助<code>ceph-volume</code>来进行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph-volume lvm zap VG1/MyLvm</span></span><br><span class="line"></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Zapping: /dev/VG1/MyLvm</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Unmounting /var/lib/ceph/osd/ceph-1</span></span><br><span class="line">Running command: /bin/umount -v /var/lib/ceph/osd/ceph-1</span><br><span class="line"> stderr: umount: /var/lib/ceph/osd/ceph-1 (tmpfs) unmounted</span><br><span class="line">Running command: /usr/sbin/wipefs --all /dev/VG1/MyLvm</span><br><span class="line">Running command: /bin/dd if=/dev/zero of=/dev/VG1/MyLvm bs=1M count=10</span><br><span class="line">Running command: /usr/sbin/lvchange --deltag ceph.type=block /dev/VG1/MyLvm</span><br><span class="line"> stdout: Logical volume VG1/MyLvm changed.</span><br><span class="line">Running command: /usr/sbin/lvchange --deltag ceph.osd_id=1 /dev/VG1/MyLvm</span><br><span class="line"> stdout: Logical volume VG1/MyLvm changed.</span><br><span class="line">Running command: /usr/sbin/lvchange --deltag ceph.cluster_fsid=082d1625-1d68-4261-82c8-3fe9fe3ef489 /dev/VG1/MyLvm</span><br><span class="line"> stdout: Logical volume VG1/MyLvm changed.</span><br><span class="line">Running command: /usr/sbin/lvchange --deltag ceph.cluster_name=ceph /dev/VG1/MyLvm</span><br><span class="line"> stdout: Logical volume VG1/MyLvm changed.</span><br><span class="line">Running command: /usr/sbin/lvchange --deltag ceph.osd_fsid=a59044b3-ff4c-4a99-978f-1336ff4504a0 /dev/VG1/MyLvm</span><br><span class="line"> stdout: Logical volume VG1/MyLvm changed.</span><br><span class="line">Running command: /usr/sbin/lvchange --deltag ceph.encrypted=0 /dev/VG1/MyLvm</span><br><span class="line"> stdout: Logical volume VG1/MyLvm changed.</span><br><span class="line">Running command: /usr/sbin/lvchange --deltag ceph.cephx_lockbox_secret= /dev/VG1/MyLvm</span><br><span class="line"> stdout: Logical volume VG1/MyLvm changed.</span><br><span class="line">Running command: /usr/sbin/lvchange --deltag ceph.block_uuid=B553Ss-LYdv-3FEW-q5u9-XKph-qn2v-y3ecu0 /dev/VG1/MyLvm</span><br><span class="line"> stdout: Logical volume VG1/MyLvm changed.</span><br><span class="line">Running command: /usr/sbin/lvchange --deltag ceph.block_device=/dev/VG1/MyLvm /dev/VG1/MyLvm</span><br><span class="line"> stdout: Logical volume VG1/MyLvm changed.</span><br><span class="line">Running command: /usr/sbin/lvchange --deltag ceph.vdo=0 /dev/VG1/MyLvm</span><br><span class="line"> stdout: Logical volume VG1/MyLvm changed.</span><br><span class="line">Running command: /usr/sbin/lvchange --deltag ceph.crush_device_class=None /dev/VG1/MyLvm</span><br><span class="line"> stdout: Logical volume VG1/MyLvm changed.</span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Zapping successful <span class="keyword">for</span>: &lt;LV: /dev/VG1/MyLvm&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用ceph-delpoy创建osd：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ceph-deploy osd create --data VG1/MyLvm node2</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">[node2][DEBUG ] --&gt; ceph-volume lvm activate successful for osd ID: 1</span><br><span class="line">[node2][DEBUG ] --&gt; ceph-volume lvm create successful for: VG1/MyLvm</span><br><span class="line">[node2][INFO  ] checking OSD status...</span><br><span class="line">[node2][DEBUG ] find the location of an executable</span><br><span class="line">[node2][INFO  ] Running command: sudo /bin/ceph --cluster=ceph osd stat --format=json</span><br><span class="line">[ceph_deploy.osd][DEBUG ] Host node2 is now ready for osd use.</span><br></pre></td></tr></table></figure>
<p>查询集群状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph -s</span></span><br><span class="line">  cluster:</span><br><span class="line">    id:     082d1625-1d68-4261-82c8-3fe9fe3ef489</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"> </span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum node1,node2,node3</span><br><span class="line">    mgr: node1(active), standbys: node3, node2</span><br><span class="line">    mds: fs_test-1/1/1 up  &#123;0=node1=up:active&#125;</span><br><span class="line">    osd: 3 osds: 3 up, 3 in</span><br><span class="line">    rgw: 1 daemon active</span><br><span class="line"> </span><br><span class="line">  data:</span><br><span class="line">    pools:   8 pools, 68 pgs</span><br><span class="line">    objects: 256  objects, 136 MiB</span><br><span class="line">    usage:   3.5 GiB used, 37 GiB / 40 GiB avail</span><br><span class="line">    pgs:     68 active+clean</span><br><span class="line"> </span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph osd df tree</span></span><br><span class="line">ID CLASS WEIGHT  REWEIGHT SIZE   USE     AVAIL   %USE  VAR  PGS TYPE NAME      </span><br><span class="line">-1       0.03908        - 40 GiB 3.3 GiB  37 GiB  8.34 1.00   - root default   </span><br><span class="line">-3       0.00980        - 10 GiB 1.1 GiB 8.8 GiB 11.49 1.38   -     host node1 </span><br><span class="line"> 0   hdd 0.00980  1.00000 10 GiB 1.1 GiB 8.8 GiB 11.49 1.38  68         osd.0  </span><br><span class="line">-5       0.01949        - 20 GiB 1.0 GiB  19 GiB  5.20 0.62   -     host node2 </span><br><span class="line"> 1   hdd 0.01949  1.00000 20 GiB 1.0 GiB  19 GiB  5.20 0.62  55         osd.1  </span><br><span class="line">-7       0.00980        - 10 GiB 1.1 GiB 8.8 GiB 11.49 1.38   -     host node3 </span><br><span class="line"> 2   hdd 0.00980  1.00000 10 GiB 1.1 GiB 8.8 GiB 11.49 1.38  68         osd.2  </span><br><span class="line">                    TOTAL 40 GiB 3.3 GiB  37 GiB  8.34                         </span><br><span class="line">MIN/MAX VAR: 0.62/1.38  STDDEV: 3.14</span><br></pre></td></tr></table></figure>
<p>可以看到集群现在就健康了，并且osd.1就有19G可用了。</p>
<hr>
<p><strong>方法二：手动创建。</strong></p>
<p><strong>尝试官方教程失败，如下：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mount -o user_xattr /dev/VG1/MyLvm /var/lib/ceph/osd/ceph-1</span></span><br><span class="line"></span><br><span class="line">mount: wrong fs type, bad option, bad superblock on /dev/mapper/VG1-MyLvm,</span><br><span class="line">       missing codepage or helper program, or other error</span><br><span class="line"></span><br><span class="line">       In some cases useful info is found in syslog - try</span><br><span class="line">       dmesg | tail or so.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mount /dev/VG1/MyLvm /var/lib/ceph/osd/ceph-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph-osd -i 1 --mkfs --mkkey</span></span><br><span class="line"></span><br><span class="line">2019-07-19 16:54:52.691 7efc821c7d80 -1 auth: unable to find a keyring on /var/lib/ceph/osd/ceph-1/keyring: (2) No such file or directory</span><br><span class="line">2019-07-19 16:54:52.691 7efc821c7d80 -1 monclient: ERROR: missing keyring, cannot use cephx for authentication</span><br><span class="line">failed to fetch mon config (--no-mon-config to skip)</span><br></pre></td></tr></table></figure>
<p><strong>暂时放弃手动。</strong></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://docs.ceph.com/docs/master/rados/operations/add-or-rm-osds/">ADDING/REMOVING OSDS</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph-13.2.5添加mon，删除mon（ceph-deploy）</title>
    <url>/2019/07/22/2019-07-22-ceph-mon-add-destroy/</url>
    <content><![CDATA[<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在集群搭建完毕之后，一共有三个host，每个host都是mon节点，这时新创建一个虚拟机，想要让它加入到mon节点，
就需要学习如何添加mon节点。</p>
<h2 id="添加mon节点"><a href="#添加mon节点" class="headerlink" title="添加mon节点"></a>添加mon节点</h2><p>这里添加的节点叫做<strong>node4</strong>。</p>
<p>由于这里使用的是ceph-deploy工具，所以首先要进行ssh免密登录的设置，然后再进行ntp设置。
当然，还需要对hosts文件进行修改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 先添加集群用户</span><br><span class="line"><span class="meta">[node4]$</span><span class="bash"> useradd -d /home/&#123;username&#125; -m &#123;username&#125;</span></span><br><span class="line"><span class="meta">[node4]$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;&#123;username&#125; ALL = (root) NOPASSWD:ALL&quot;</span> | sudo tee /etc/sudoers.d/&#123;username&#125;</span></span><br><span class="line"><span class="meta">[node4]$</span><span class="bash"> sudo chmod 0440 /etc/sudoers.d/&#123;username&#125;</span></span><br><span class="line"></span><br><span class="line">// 修改hosts文件</span><br><span class="line"><span class="meta">[deploy]$</span><span class="bash"> sudo vim /etc/hosts</span></span><br><span class="line"><span class="meta">[deploy]$</span><span class="bash"> cat /etc/hosts</span></span><br><span class="line"></span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line"></span><br><span class="line">192.168.31.203 node1</span><br><span class="line">192.168.31.204 node2</span><br><span class="line">192.168.31.205 node3</span><br><span class="line">192.168.31.207 node4</span><br><span class="line"></span><br><span class="line">// 其它所有节点拷贝hosts文件（不知道是不是必须的，反正我是做了这一步）</span><br><span class="line"><span class="meta">[node1]$</span><span class="bash"> sudo scp ming@192.168.31.202:/etc/hosts /etc/hosts</span></span><br><span class="line"><span class="meta">[node2]$</span><span class="bash"> sudo scp ming@192.168.31.202:/etc/hosts /etc/hosts</span></span><br><span class="line"><span class="meta">[node3]$</span><span class="bash"> sudo scp ming@192.168.31.202:/etc/hosts /etc/hosts</span></span><br><span class="line"><span class="meta">[node4]$</span><span class="bash"> sudo scp ming@192.168.31.202:/etc/hosts /etc/hosts</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ssh免密登录设置</span><br><span class="line"><span class="meta">[deploy]$</span><span class="bash"> vim ~/.ssh/config</span></span><br><span class="line"><span class="meta">[deploy]$</span><span class="bash"> cat ~/.ssh/config</span></span><br><span class="line"></span><br><span class="line">Host node1</span><br><span class="line">	HostName 192.168.31.203</span><br><span class="line">	User ming</span><br><span class="line">Host node2</span><br><span class="line">	HostName 192.168.31.204</span><br><span class="line">	User ming</span><br><span class="line">Host node3</span><br><span class="line">	HostName 192.168.31.205</span><br><span class="line">	User ming</span><br><span class="line">Host node4</span><br><span class="line">	HostName 192.168.31.207</span><br><span class="line">	User ming</span><br><span class="line"></span><br><span class="line"><span class="meta">[deploy]$</span><span class="bash"> ssh-copy-id &#123;username&#125;@node4</span></span><br><span class="line"></span><br><span class="line">// ntp设置</span><br><span class="line"><span class="meta">[node4]$</span><span class="bash"> sudo yum install -y ntp</span></span><br><span class="line"><span class="meta">[node4]$</span><span class="bash"> sudo systemctl start ntpd</span></span><br><span class="line"><span class="meta">[node4]$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> ntpd</span></span><br><span class="line"><span class="meta">[node4]$</span><span class="bash"> sudo vim /etc/ntp.conf</span></span><br><span class="line"><span class="meta">[node4]$</span><span class="bash"> cat /etc/ntp.conf</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> Use public servers from the pool.ntp.org project.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Please consider joining the pool (http://www.pool.ntp.org/join.html).</span></span><br><span class="line">server 192.168.31.202 prefer</span><br><span class="line">server 0.centos.pool.ntp.org iburst</span><br><span class="line">server 1.centos.pool.ntp.org iburst</span><br><span class="line">server 2.centos.pool.ntp.org iburst</span><br><span class="line">server 3.centos.pool.ntp.org iburst</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>完成上面的准备工作之后，开始进行mon的添加，</p>
<p><strong>注意：</strong>我这里使用的本地源来安装ceph，所以即使不装epel也无所谓，因为所需依赖包都在本地了，
具体可以参考之前的博客<a href="http://longrm.com/2019/07/18/2019-07-18-ceph-install/">centos7上的ceph指定版本安装方法</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 安装ceph</span><br><span class="line"><span class="meta">[node4]$</span><span class="bash"> sudo yum install -y ceph</span></span><br><span class="line"></span><br><span class="line">// 修改ceph.conf配置。</span><br><span class="line">// 这里在mon_initial_members、mon_host上的修改可能并不是必须的（经本人测试），但感觉还是加上好一点。</span><br><span class="line">// 一定要增加public_network字段的配置，否则大概率会出现&quot;admin_socket: exception getting command descriptions file ...&quot;的错误。</span><br><span class="line"><span class="meta">[deploy]$</span><span class="bash"> vim ceph.conf</span></span><br><span class="line"><span class="meta">[deploy]$</span><span class="bash"> cat ceph.conf</span></span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">fsid = a20b153c-c907-41bb-a5b2-753a40e2085c</span><br><span class="line">mon_initial_members = node1, node2, node3, node4</span><br><span class="line">mon_host = 192.168.31.203,192.168.31.204,192.168.31.205,192.168.31.207</span><br><span class="line">auth_cluster_required = cephx</span><br><span class="line">auth_service_required = cephx</span><br><span class="line">auth_client_required = cephx</span><br><span class="line">public_network = 192.168.31.0/24</span><br><span class="line"></span><br><span class="line">// 将这个配置发送到其它节点</span><br><span class="line"><span class="meta">[deploy]$</span><span class="bash"> ceph-deploy --overwrite-conf config push node1 node2 node3 node4</span></span><br><span class="line"></span><br><span class="line">// 添加mon节点</span><br><span class="line"><span class="meta">[deploy]$</span><span class="bash"> ceph-deploy mon add node4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">[deploy]$</span><span class="bash"> ssh node1 sudo ceph -s</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  services:</span><br><span class="line">    mon: 4 daemons, quorum node1,node2,node3,node4</span><br><span class="line">    mgr: node1(active), standbys: node2, node3</span><br><span class="line">    osd: 0 osds: 0 up, 0 in</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>这样就完成了mon节点的添加，注意到其中的<strong>关键在于public_network字段的添加</strong>。</p>
<h2 id="删除mon节点"><a href="#删除mon节点" class="headerlink" title="删除mon节点"></a>删除mon节点</h2><p>直接destroy就可以了：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[deploy]$</span><span class="bash"> ceph-deploy mon destroy node4</span></span><br></pre></td></tr></table></figure></h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://docs.ceph.com/docs/master/start/quick-ceph-deploy/">STORAGE CLUSTER QUICK START</a></p>
<p><a href="https://www.cnblogs.com/aguncn/p/7352393.html">ceph在扩展mon节点时，要注意的问题</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph-mimic-13.2.5中s3的初步使用</title>
    <url>/2019/08/02/2019-08-02-ceph-s3-use/</url>
    <content><![CDATA[<hr>
<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><p>有一个<strong>HEALTH_OK</strong>的ceph集群，并且还有剩余的存储空间。</p>
<p>这里是我所搭建的集群：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph -s</span></span><br><span class="line">  cluster:</span><br><span class="line">    id:     a20b153c-c907-41bb-a5b2-753a40e2085c</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"> </span><br><span class="line">  services:</span><br><span class="line">    mon: 4 daemons, quorum node1,node2,node3,node4</span><br><span class="line">    mgr: node2(active), standbys: node3, node1, node4</span><br><span class="line">    osd: 4 osds: 4 up, 4 in</span><br><span class="line">    rgw: 1 daemon active</span><br><span class="line"> </span><br><span class="line">  data:</span><br><span class="line">    pools:   6 pools, 48 pgs</span><br><span class="line">    objects: 198  objects, 3.2 KiB</span><br><span class="line">    usage:   4.1 GiB used, 46 GiB / 50 GiB avail</span><br><span class="line">    pgs:     48 active+clean</span><br></pre></td></tr></table></figure></h2><h2 id="创建OBJECT-GATEWAY"><a href="#创建OBJECT-GATEWAY" class="headerlink" title="创建OBJECT GATEWAY"></a>创建OBJECT GATEWAY</h2><p>注意到<code>OBJECT GATEWAY</code>不需要是mon节点或者osd节点。</p>
<p>首先，要在节点上安装相关的包，可以使用官网推荐的<code>ceph-deploy install --rgw &lt;gateway-node1&gt; [&lt;gateway-node2&gt; ...]</code>来进行安装，
但是这里由于指定版本、epel包下载容易失败等问题，还是推荐直接使用本地yum源来进行ceph和ceph-radosgw的安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y ceph-13.2.5 ceph-radosgw-13.2.5</span></span><br></pre></td></tr></table></figure>
<p>第二步，将节点设为<strong>admin</strong>节点，我这里直接使用了集群中的node1节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[deploy]$</span><span class="bash"> ceph-deploy admin node1</span></span><br></pre></td></tr></table></figure>
<p>第三步，创建<code>GATEWAY INSTANCE</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[deploy]$</span><span class="bash"> ceph-deploy rgw create node1</span></span><br></pre></td></tr></table></figure>
<p>服务的默认端口为7480，查看当前打开端口，可以看到服务成功建立起来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[node1]$</span><span class="bash"> netstat -nlpt</span></span><br><span class="line"></span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 192.168.31.203:6789     0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp        0      0 192.168.31.203:6800     0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp        0      0 192.168.31.203:6801     0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp        0      0 192.168.31.203:6802     0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp        0      0 192.168.31.203:6803     0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp        0      0 192.168.31.203:6804     0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp        0      0 0.0.0.0:7480            0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      -                   </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      -                   </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN      -                   </span><br></pre></td></tr></table></figure>
<p>查看当前pool，应该可以看到相关的pool被创建：</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph osd pool ls</span></span><br><span class="line"></span><br><span class="line">default.rgw.meta</span><br><span class="line">.rgw.root</span><br><span class="line">default.rgw.control</span><br><span class="line">default.rgw.log</span><br><span class="line">default.rgw.buckets.index</span><br><span class="line">default.rgw.buckets.data</span><br></pre></td></tr></table></figure></h2><h2 id="创建RADOSGW-USER"><a href="#创建RADOSGW-USER" class="headerlink" title="创建RADOSGW USER"></a>创建RADOSGW USER</h2><p>s3是一个Web服务接口，自然的，就需要相应的访问权限来与它交互，所以在使用它之前，需要创建用户。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[node1]$</span><span class="bash"> sudo radosgw-admin user create --uid=<span class="string">&quot;testuser&quot;</span> --display-name=<span class="string">&quot;First User&quot;</span></span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        &quot;user_id&quot;: &quot;testuser&quot;,</span><br><span class="line">        &quot;display_name&quot;: &quot;First User&quot;,</span><br><span class="line">        &quot;email&quot;: &quot;&quot;,</span><br><span class="line">        &quot;suspended&quot;: 0,</span><br><span class="line">        &quot;max_buckets&quot;: 1000,</span><br><span class="line">        &quot;subusers&quot;: [],</span><br><span class="line">        &quot;keys&quot;: [&#123;</span><br><span class="line">                &quot;user&quot;: &quot;testuser&quot;,</span><br><span class="line">                &quot;access_key&quot;: &quot;I0PJDPCIYZ665MW88W9R&quot;,</span><br><span class="line">                &quot;secret_key&quot;: &quot;dxaXZ8U90SXydYzyS5ivamEP20hkLSUViiaR+ZDA&quot;</span><br><span class="line">        &#125;],</span><br><span class="line">        &quot;swift_keys&quot;: [],</span><br><span class="line">        &quot;caps&quot;: [],</span><br><span class="line">        &quot;op_mask&quot;: &quot;read, write, delete&quot;,</span><br><span class="line">        &quot;default_placement&quot;: &quot;&quot;,</span><br><span class="line">        &quot;placement_tags&quot;: [],</span><br><span class="line">        &quot;bucket_quota&quot;: &#123;</span><br><span class="line">                &quot;enabled&quot;: false,</span><br><span class="line">                &quot;max_size_kb&quot;: -1,</span><br><span class="line">                &quot;max_objects&quot;: -1</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;user_quota&quot;: &#123;</span><br><span class="line">                &quot;enabled&quot;: false,</span><br><span class="line">                &quot;max_size_kb&quot;: -1,</span><br><span class="line">                &quot;max_objects&quot;: -1</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;temp_url_keys&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一长串的输出中，别的在现阶段不用管，记住<strong>access_key</strong>和<strong>secret_key</strong>就行。</p>
<p>想再查询<strong>access_key</strong>和<strong>secret_key</strong>，可以使用以下命令：</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 查询有哪些用户</span><br><span class="line"><span class="meta">[node1]$</span><span class="bash"> sudo radosgw-admin user list</span></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &quot;testuser&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 查询用户信息</span><br><span class="line"><span class="meta">[node1]$</span><span class="bash"> sudo radosgw-admin user info --uid=testuser</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &quot;keys&quot;: [&#123;</span><br><span class="line">                &quot;user&quot;: &quot;testuser&quot;,</span><br><span class="line">                &quot;access_key&quot;: &quot;I0PJDPCIYZ665MW88W9R&quot;,</span><br><span class="line">                &quot;secret_key&quot;: &quot;dxaXZ8U90SXydYzyS5ivamEP20hkLSUViiaR+ZDA&quot;</span><br><span class="line">        &#125;],</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></h2><h2 id="使用S3-Browser（非必须）"><a href="#使用S3-Browser（非必须）" class="headerlink" title="使用S3 Browser（非必须）"></a>使用<code>S3 Browser</code>（非必须）</h2><p>使用<code>S3 Browser</code>来浏览存储，以证明现在服务运行正常，连接正常。</p>
<p><a href="https://s3browser.com/">下载S3 Browser</a></p>
<p>运行S3 Browser，它会让你输入你的S3账户：</p>
<p><img src="/images/linux/ceph/s3-browser-1.png" alt="image" title="s3-browser-1"></p>
<p>然后将上面的信息都填上，如下：</p>
<p><img src="/images/linux/ceph/s3-browser-2.png" alt="image" title="s3-browser-2"></p>
<p>连接成功之后，就可以看到当前的bucket情况，也可以使用它进行创建、删除、上传以及下载等：</p>
<p><img src="/images/linux/ceph/s3-browser-3.png" alt="image" title="s3-browser-3"></p>
<p>到目前为止，算是完成了ceph集群方面的准备工作，下面就是写代码方面了。</p>
<hr>
<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>我这里使用的是<strong>idea+java</strong>。</p>
<p>首先创建maven工程（处理依赖会简单很多）：</p>
<p><img src="/images/linux/ceph/s3-maven-1.png" alt="image" title="s3-maven-1"></p>
<p>（注：这里略过了idea中maven配置的相关内容。）</p>
<p>修改pom.xml文件，添加依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.amazonaws/aws-java-sdk-s3 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.amazonaws<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aws-java-sdk-s3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11.597<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来最重要的就是参考官方给的<a href="https://github.com/awsdocs/aws-doc-sdk-examples/tree/master/java/example_code/s3/src/main/java">代码样例</a>了。</p>
<p>最后我写的类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> s3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.amazonaws.auth.AWSStaticCredentialsProvider;</span><br><span class="line"><span class="keyword">import</span> com.amazonaws.auth.BasicAWSCredentials;</span><br><span class="line"><span class="keyword">import</span> com.amazonaws.client.builder.AwsClientBuilder;</span><br><span class="line"><span class="keyword">import</span> com.amazonaws.services.s3.AmazonS3;</span><br><span class="line"><span class="keyword">import</span> com.amazonaws.services.s3.AmazonS3ClientBuilder;</span><br><span class="line"><span class="keyword">import</span> com.amazonaws.services.s3.model.*;</span><br><span class="line"><span class="keyword">import</span> com.amazonaws.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * S3操作类，完成一些基本的操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v0.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">S3Template</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ORIGINAL_FOLDER = <span class="string">&quot;video/original&quot;</span>; <span class="comment">// 原始文件目录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DOWNLOAD_FOLDER = <span class="string">&quot;video/download&quot;</span>; <span class="comment">// 下载文件目录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRANSCODING_FOLDER = <span class="string">&quot;video/transcoding&quot;</span>; <span class="comment">// 转码文件目录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AmazonS3 s3Client = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyLogger log = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">S3Template</span><span class="params">(String endPoint, String accessKey, String secretKey)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.s3Client = AmazonS3ClientBuilder.standard()</span><br><span class="line">                .withCredentials(<span class="keyword">new</span> AWSStaticCredentialsProvider(<span class="keyword">new</span> BasicAWSCredentials(accessKey, secretKey)))</span><br><span class="line">                .withEndpointConfiguration(<span class="keyword">new</span> AwsClientBuilder.EndpointConfiguration(endPoint, <span class="string">&quot;&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">         log = <span class="keyword">new</span> MyLogger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listBuckets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Bucket&gt; buckets = s3Client.listBuckets();</span><br><span class="line">        <span class="keyword">for</span> (Bucket bucket : buckets) &#123;</span><br><span class="line">            log.info(bucket.getName() + <span class="string">&quot;\t&quot;</span> +</span><br><span class="line">                    StringUtils.fromDate(bucket.getCreationDate()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBucket</span><span class="params">(String bucketName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s3Client.doesBucketExistV2(bucketName)) &#123;</span><br><span class="line">            s3Client.createBucket(<span class="keyword">new</span> CreateBucketRequest(bucketName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Verify that the bucket was created by retrieving it and checking its location.</span></span><br><span class="line">        String bucketLocation = s3Client.getBucketLocation(<span class="keyword">new</span> GetBucketLocationRequest(bucketName));</span><br><span class="line">        log.info(<span class="string">&quot;Bucket location: &quot;</span> + bucketLocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBucket</span><span class="params">(String bucketName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s3Client.doesBucketExistV2(bucketName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Bucket &quot;</span> + bucketName + <span class="string">&quot; does not exist.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ObjectListing objectListing = s3Client.listObjects(bucketName);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Iterator&lt;S3ObjectSummary&gt; objIter = objectListing.getObjectSummaries().iterator();</span><br><span class="line">            <span class="keyword">while</span> (objIter.hasNext()) &#123;</span><br><span class="line">                s3Client.deleteObject(bucketName, objIter.next().getKey());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (objectListing.isTruncated()) &#123;</span><br><span class="line">                objectListing = s3Client.listNextBatchOfObjects(objectListing);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        VersionListing versionList = s3Client.listVersions(<span class="keyword">new</span> ListVersionsRequest().withBucketName(bucketName));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Iterator&lt;S3VersionSummary&gt; versionIter = versionList.getVersionSummaries().iterator();</span><br><span class="line">            <span class="keyword">while</span> (versionIter.hasNext()) &#123;</span><br><span class="line">                S3VersionSummary vs = versionIter.next();</span><br><span class="line">                s3Client.deleteVersion(bucketName, vs.getKey(), vs.getVersionId());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (versionList.isTruncated()) &#123;</span><br><span class="line">                versionList = s3Client.listNextBatchOfVersions(versionList);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s3Client.deleteBucket(bucketName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downFile</span><span class="params">(String bucketName, String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Downloading object &quot;</span> + key);</span><br><span class="line">        S3Object fullObject = <span class="keyword">null</span>;</span><br><span class="line">        fullObject = s3Client.getObject(<span class="keyword">new</span> GetObjectRequest(bucketName, key));</span><br><span class="line">        storeFile(fullObject.getObjectContent(), key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadFile</span><span class="params">(String bucketName, String fileObjKeyName, String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( s3Client.doesObjectExist(bucketName, fileObjKeyName) ) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;The File &quot;</span> + fileName + <span class="string">&quot; already exists.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Upload a file as a new object with ContentType and title specified.</span></span><br><span class="line">        log.info(<span class="string">&quot;Upload object &quot;</span> + fileName);</span><br><span class="line">        PutObjectRequest request = <span class="keyword">new</span> PutObjectRequest(bucketName, fileObjKeyName, <span class="keyword">new</span> File(ORIGINAL_FOLDER + <span class="string">&quot;/&quot;</span> + fileName));</span><br><span class="line">        ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">        metadata.setContentType(<span class="string">&quot;plain/video&quot;</span>);</span><br><span class="line">        metadata.addUserMetadata(<span class="string">&quot;x-amz-meta-title&quot;</span>, <span class="string">&quot;someTitle&quot;</span>);</span><br><span class="line">        request.setMetadata(metadata);</span><br><span class="line">        s3Client.putObject(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">storeFile</span><span class="params">(InputStream input, String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Store File &quot;</span> + fileName);</span><br><span class="line">        <span class="comment">// Read the text input stream one line at a time and display each line.</span></span><br><span class="line">        BufferedInputStream reader = <span class="keyword">new</span> BufferedInputStream(input);</span><br><span class="line">        BufferedOutputStream writer = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(DOWNLOAD_FOLDER + <span class="string">&quot;/&quot;</span> + fileName));</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = reader.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            writer.write(buff, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功上传文件到ceph并将其下载下来：</p>
<p><img src="/images/linux/ceph/s3-maven-2.png" alt="image" title="s3-maven-2"></p>
<p>基本操作练习结束。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.ceph.com/docs/master/install/install-ceph-gateway/">INSTALL CEPH OBJECT GATEWAY</a></p>
<p><a href="https://github.com/awsdocs/aws-doc-sdk-examples/tree/master/java/example_code/s3/src/main/java">aws-doc-sdk-examples</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>ceph</tag>
        <tag>s3</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph-mimic-13.2.5中CephFS的初步使用</title>
    <url>/2019/08/05/2019-08-05-ceph-fs-use/</url>
    <content><![CDATA[<hr>
<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><p>有一个<strong>HEALTH_OK</strong>的ceph集群，并且还有剩余的存储空间。</p>
<p>这里是我所搭建的集群：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph -s</span></span><br><span class="line"></span><br><span class="line">  cluster:</span><br><span class="line">    id:     a20b153c-c907-41bb-a5b2-753a40e2085c</span><br><span class="line">    health: HEALTH_WARN</span><br><span class="line">            clock skew detected on mon.node2</span><br><span class="line"> </span><br><span class="line">  services:</span><br><span class="line">    mon: 4 daemons, quorum node1,node2,node3,node4</span><br><span class="line">    mgr: node2(active), standbys: node3, node1, node4</span><br><span class="line">    osd: 4 osds: 4 up, 4 in</span><br><span class="line">    rgw: 1 daemon active</span><br><span class="line"> </span><br><span class="line">  data:</span><br><span class="line">    pools:   6 pools, 48 pgs</span><br><span class="line">    objects: 492  objects, 1.1 GiB</span><br><span class="line">    usage:   7.5 GiB used, 42 GiB / 50 GiB avail</span><br><span class="line">    pgs:     48 active+clean</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><h2 id="创建mds-METADATA-SERVER"><a href="#创建mds-METADATA-SERVER" class="headerlink" title="创建mds(METADATA SERVER)"></a>创建mds(METADATA SERVER)</h2><p>要使用CephFS，至少需要有一个mds，可以使用ceph-deploy工具进行创建：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[deploy]$</span><span class="bash"> ceph-deploy mds create node1</span></span><br></pre></td></tr></table></figure>
<p>查看mds状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[node1]$</span><span class="bash"> sudo ceph mds <span class="built_in">stat</span></span></span><br><span class="line"></span><br><span class="line">, 1 up:standby</span><br></pre></td></tr></table></figure>
<p>可以看到mds创建成功了。</p>
<hr>
<h2 id="创建CEPH-FILESYSTEM"><a href="#创建CEPH-FILESYSTEM" class="headerlink" title="创建CEPH FILESYSTEM"></a>创建CEPH FILESYSTEM</h2><p>根据官方文档所述<code>A Ceph filesystem requires at least two RADOS pools, one for data and one for metadata.</code>，
这里需要创建两个pool。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[node1]$</span><span class="bash"> ceph osd pool create cephfs_data 16</span></span><br><span class="line"></span><br><span class="line">pool &#x27;cephfs_data&#x27; created</span><br><span class="line"></span><br><span class="line"><span class="meta">[node1]$</span><span class="bash"> ceph osd pool create cephfs_metadata 16</span></span><br><span class="line"></span><br><span class="line">pool &#x27;cephfs_metadata&#x27; created</span><br></pre></td></tr></table></figure>
<p>然后直接就可以进行CephFS的创建：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[node1]$</span><span class="bash"> ceph fs new cephfs cephfs_metadata cephfs_data</span></span><br><span class="line"><span class="meta">[node1]$</span><span class="bash"> ceph fs ls</span></span><br><span class="line"></span><br><span class="line">name: cephfs, metadata pool: cephfs_metadata, data pools: [cephfs_data ]</span><br></pre></td></tr></table></figure>
<p>此时<code>sudo ceph mds stat</code>命令和<code>sudo ceph -s</code>的输出就发生了变化：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[node1]$</span><span class="bash"> sudo ceph mds <span class="built_in">stat</span></span></span><br><span class="line"></span><br><span class="line">cephfs-1/1/1 up  &#123;0=node1=up:active&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">[node1]$</span><span class="bash"> sudo ceph -s</span></span><br><span class="line"></span><br><span class="line">  cluster:</span><br><span class="line">    id:     a20b153c-c907-41bb-a5b2-753a40e2085c</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"> </span><br><span class="line">  services:</span><br><span class="line">    mon: 4 daemons, quorum node1,node2,node3,node4</span><br><span class="line">    mgr: node2(active), standbys: node3, node1, node4</span><br><span class="line">    mds: cephfs-1/1/1 up  &#123;0=node1=up:active&#125;   // 增加了mds的状态</span><br><span class="line">    osd: 4 osds: 4 up, 4 in</span><br><span class="line">    rgw: 1 daemon active</span><br><span class="line"> </span><br><span class="line">  data:</span><br><span class="line">    pools:   8 pools, 112 pgs</span><br><span class="line">    objects: 514  objects, 1.1 GiB</span><br><span class="line">    usage:   7.5 GiB used, 42 GiB / 50 GiB avail</span><br><span class="line">    pgs:     112 active+clean</span><br></pre></td></tr></table></figure>
<p>注：集群中可以同时创建多个CephFS，这时候就会有默认FS、优先级等设置上的问题。</p>
<hr>
<h2 id="挂载CephFS"><a href="#挂载CephFS" class="headerlink" title="挂载CephFS"></a>挂载CephFS</h2><p>挂载CephFS有几种不同的方式，直接挂载、fuse、fstab。</p>
<p>这里一一进行叙述，但是详细的内核态用户态什么的就先不分析了。</p>
<p>在哪台机器上执行都可以，无所谓。</p>
<hr>
<h3 id="直接挂载CephFS"><a href="#直接挂载CephFS" class="headerlink" title="直接挂载CephFS"></a>直接挂载CephFS</h3><p>很简单，直接使用mount命令挂载就完事了，<strong>注意端口是6789，密钥去ceph.client.admin.keyring里看，不要在要挂载的目录下去执行挂载！</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir /mnt/mycephfs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mount -t ceph 192.168.31.203:6789:/ /mnt/mycephfs -o name=admin,secret=AQBxGTVdnr4PAhAAd4KqF0802IwTk0wVzw0cZA==</span></span><br></pre></td></tr></table></figure>
<p>复制一个文件进去试试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 复制文件进去</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir /mnt/mycephfs/<span class="built_in">test</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp 11.mp4 /mnt/mycephfs/<span class="built_in">test</span>/</span></span><br><span class="line"></span><br><span class="line">// 卸载看是不是都没了</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo umount /mnt/mycephfs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ll /mnt/mycephfs/</span></span><br><span class="line"></span><br><span class="line">total 0</span><br><span class="line"></span><br><span class="line">// 重新挂载</span><br><span class="line">// 查看文件</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mount -t ceph 192.168.31.203:6789:/ /mnt/mycephfs -o name=admin,secret=AQBxGTVdnr4PAhAAd4KqF0802IwTk0wVzw0cZA==</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ll /mnt/mycephfs/<span class="built_in">test</span>/</span></span><br><span class="line"></span><br><span class="line">total 196753</span><br><span class="line">-rw-r--r-- 1 root root 201474919 Aug  5 10:03 11.mp4</span><br></pre></td></tr></table></figure>
<p>可以看到文件成功的存入了CephFS中。</p>
<hr>
<h3 id="使用ceph-fuse进行挂载"><a href="#使用ceph-fuse进行挂载" class="headerlink" title="使用ceph-fuse进行挂载"></a>使用ceph-fuse进行挂载</h3><p>按照官方文档所说，把密钥和conf拷贝到要执行挂载的机器上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[client]$</span><span class="bash"> sudo scp ming@192.168.31.203:/etc/ceph/ceph.client.admin.keyring /etc/ceph/ceph.client.admin.keyring</span></span><br><span class="line"><span class="meta">[client]$</span><span class="bash"> sudo scp ming@192.168.31.203:/etc/ceph/ceph.conf /etc/ceph/ceph.conf</span></span><br></pre></td></tr></table></figure>
<p>要注意的是，现在需要使用的<code>ceph-fuse</code>命令是还没有按照的，需要手动按照一下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[client]$</span><span class="bash"> sudo yum install -y ceph-fuse</span></span><br></pre></td></tr></table></figure>
<p>进行挂载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[client]$</span><span class="bash"> sudo mkdir /home/ming/cephfs</span></span><br><span class="line"><span class="meta">[client]$</span><span class="bash"> sudo ceph-fuse -m 192.168.31.203:6789 /home/ming/cephfs</span></span><br><span class="line"></span><br><span class="line">ceph-fuse[1607]: starting ceph client</span><br><span class="line">2019-08-05 10:21:37.388 7f7f411bec00 -1 init, newargv = 0x55b21236d6e0 newargc=7</span><br><span class="line">ceph-fuse[1607]: starting fuse</span><br><span class="line"></span><br><span class="line"><span class="meta">[client]$</span><span class="bash"> ll cephfs/<span class="built_in">test</span>/</span></span><br><span class="line"></span><br><span class="line">total 196753</span><br><span class="line">-rw-r--r-- 1 root root 201474919 Aug  5 10:03 11.mp4</span><br></pre></td></tr></table></figure>
<p>可以看到成功的进行了挂载，并且也看到了已有的文件。</p>
<p>下面进行卸载，注意到卸载所使用的命令与挂载不同：</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo fusermount -u cephfs/</span></span><br></pre></td></tr></table></figure></h2><h3 id="使用fstab进行挂载"><a href="#使用fstab进行挂载" class="headerlink" title="使用fstab进行挂载"></a>使用fstab进行挂载</h3><p>也就是在/etc/fstab文件中进行配置，这样在开机时就会自动进行挂载。</p>
<p>首先，将密钥保存到一个文件里面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/ceph/secret.key</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cat /etc/ceph/secret.key</span></span><br><span class="line"></span><br><span class="line">AQBxGTVdnr4PAhAAd4KqF0802IwTk0wVzw0cZA==</span><br></pre></td></tr></table></figure>
<p>修改<code>/etc/fstab</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/fstab</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cat /etc/fstab</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">/dev/mapper/centos-root /                       xfs     defaults        0 0</span><br><span class="line">UUID=37492c10-b6e6-4905-99ad-36207abe5b00 /boot                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-swap swap                    swap    defaults        0 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ceph fs</span></span><br><span class="line">192.168.31.203:6789:/  /mnt/mycephfs  ceph  name=admin,secretfile=/etc/ceph/secret.key,noatime,_netdev  0  2</span><br></pre></td></tr></table></figure>
<p>重启虚拟机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo reboot</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ll /mnt/mycephfs</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 1 root root 1 Aug  5 10:03 test</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ll /mnt/mycephfs/<span class="built_in">test</span></span></span><br><span class="line">total 196753</span><br><span class="line">-rw-r--r-- 1 root root 201474919 Aug  5 10:03 11.mp4</span><br></pre></td></tr></table></figure>
<p>可以看到完成了开机自动挂载。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.ceph.com/docs/master/cephfs/">CEPH FILESYSTEM</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>ceph</tag>
        <tag>cephfs</tag>
        <tag>nfs</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph+samba的简单使用</title>
    <url>/2019/08/06/2019-08-06-ceph-samba/</url>
    <content><![CDATA[<hr>
<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><p>有一个<strong>HEALTH_OK</strong>的ceph集群，还有剩余的存储空间，
并且创建了CephFS。</p>
<p>这里是我所搭建的集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph -s</span></span><br><span class="line"></span><br><span class="line">  cluster:</span><br><span class="line">    id:     51e9f534-b15a-4273-953c-9b56e9312510</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"> </span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum node1,node2,node3</span><br><span class="line">    mgr: node1(active), standbys: node2, node3</span><br><span class="line">    mds: cephfs-1/1/1 up  &#123;0=node1=up:active&#125;</span><br><span class="line">    osd: 6 osds: 6 up, 6 in</span><br><span class="line"> </span><br><span class="line">  data:</span><br><span class="line">    pools:   2 pools, 64 pgs</span><br><span class="line">    objects: 316  objects, 1.1 GiB</span><br><span class="line">    usage:   23 GiB used, 6.0 TiB / 6.0 TiB avail</span><br><span class="line">    pgs:     64 active+clean</span><br></pre></td></tr></table></figure>
<p>一台linux主机（简称smb服务器），能够与Ceph集群通信，用于开启smb服务。（当然也可以是Ceph集群中的某一节点，
我这里使用的就是Ceph集群中的node1）</p>
<p>一台windows主机，能够直接ping通smb服务器（一定要直接ping通最好，也就是同一个局域网下，
因为windows使用smb服务的时候，端口是默认定死的，你端口映射是没用的）。</p>
<hr>
<h2 id="搭建smb服务器"><a href="#搭建smb服务器" class="headerlink" title="搭建smb服务器"></a>搭建smb服务器</h2><p>首先尝试搭建smb服务器，这里和ceph暂时没有关系。</p>
<p>第一步，在作为smb服务器的linux主机上安装samba：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y samba samba-client</span></span><br></pre></td></tr></table></figure>
<p>修改<code>smb.conf</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/samba/smb.conf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cat /etc/samba/smb.conf</span></span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">workgroup = WORKGROUP </span><br><span class="line">netbios name = long</span><br><span class="line">server string = Linux Samba test</span><br><span class="line">security = user</span><br><span class="line">        </span><br><span class="line">[samba]</span><br><span class="line">path = /smb/samba</span><br><span class="line">writeable = yes</span><br><span class="line">browseable = yes</span><br><span class="line">guest ok = yes</span><br><span class="line"></span><br><span class="line">// 检查配置文件正确性</span><br><span class="line"><span class="meta">$</span><span class="bash"> testparm</span></span><br><span class="line"></span><br><span class="line">Load smb config files from /etc/samba/smb.conf</span><br><span class="line">rlimit_max: increasing rlimit_max (1024) to minimum Windows limit (16384)</span><br><span class="line">Processing section &quot;[samba]&quot;</span><br><span class="line">Loaded services file OK.</span><br><span class="line">Server role: ROLE_STANDALONE</span><br><span class="line"></span><br><span class="line">Press enter to see a dump of your service definitions</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Global parameters</span></span><br><span class="line">[global]</span><br><span class="line">	netbios name = LONG</span><br><span class="line">	security = USER</span><br><span class="line">	server string = Linux Samba test</span><br><span class="line">	idmap config * : backend = tdb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[samba]</span><br><span class="line">	guest ok = Yes</span><br><span class="line">	path = /smb/samba</span><br><span class="line">	read only = No</span><br></pre></td></tr></table></figure>
<p>注意这里的<code>workgroup</code>和<code>netbios name</code>字段填写的是windows主机上所显示的工作组和用户名，
可以在windows主机上通过<code>我的电脑-&gt;属性</code>，进行查看。</p>
<p><code>path</code>字段即共享文件夹位置，这里将它创建出来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir -p /smb/samba</span></span><br></pre></td></tr></table></figure>
<p>将共享文件夹的用户和组改为nobody，权限改为777：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 确定nobody的组名用户名都叫nobody</span><br><span class="line"><span class="meta">$</span><span class="bash"> id nobody</span></span><br><span class="line">uid=99(nobody) gid=99(nobody) groups=99(nobody)</span><br><span class="line"></span><br><span class="line">// 设置权限</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chown -R nobody:nobody /smb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod -R 777 /smb</span></span><br></pre></td></tr></table></figure>
<p>启动smb服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> smb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start smb</span></span><br></pre></td></tr></table></figure>
<p>本机测试服务是否成功启动，注意因为共享文件夹设置的<code>guest ok</code>，所以这里不用输入密码也可以连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo smbclient -L \\192.168.90.233</span></span><br><span class="line"></span><br><span class="line">Enter WORKGROUP\cluster&#x27;s password: </span><br><span class="line">Anonymous login successful</span><br><span class="line"></span><br><span class="line">	Sharename       Type      Comment</span><br><span class="line">	---------       ----      -------</span><br><span class="line">	samba           Disk      </span><br><span class="line"><span class="meta">	IPC$</span><span class="bash">            IPC       IPC Service (Linux Samba <span class="built_in">test</span>)</span></span><br><span class="line">Reconnecting with SMB1 for workgroup listing.</span><br><span class="line">Anonymous login successful</span><br><span class="line"></span><br><span class="line">	Server               Comment</span><br><span class="line">	---------            -------</span><br><span class="line"></span><br><span class="line">	Workgroup            Master</span><br><span class="line">	---------            -------</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> smbclient //192.168.90.233/samba</span></span><br><span class="line"></span><br><span class="line">Enter WORKGROUP\cluster&#x27;s password: </span><br><span class="line">Anonymous login successful</span><br><span class="line">Try &quot;help&quot; to get a list of possible commands.</span><br><span class="line">smb: \&gt; ls</span><br><span class="line">  .                                   D        0  Mon Aug  5 17:57:17 2019</span><br><span class="line">  ..                                 DR        0  Mon Aug  5 17:47:05 2019</span><br><span class="line">  test                                D        0  Mon Aug  5 17:50:02 2019</span><br><span class="line">  public                              D        0  Mon Aug  5 17:57:25 2019</span><br><span class="line"></span><br><span class="line">		2030415872 blocks of size 1024. 2029215744 blocks available</span><br><span class="line">smb: \&gt; </span><br></pre></td></tr></table></figure>
<p>ok，smb服务配置成功。</p>
<hr>
<h2 id="使用windows访问CephFS"><a href="#使用windows访问CephFS" class="headerlink" title="使用windows访问CephFS"></a>使用windows访问CephFS</h2><p>通过上面的步骤，显而易见，只要将CephFS挂载到smb服务所共享的目录下即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mount -t ceph 192.168.90.233:6789:/ /smb/samba -o name=admin,secret=AQCSvDZdqDJ+LRAAwl2YpecB2kvb7Rmp4nGJXQ==</span></span><br></pre></td></tr></table></figure>
<p>挂载之后，就相当于将CephFS共享了出来。</p>
<p>这里可以创建一个用户来访问共享：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo adduser smbuser</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo smbpasswd -a smbuser</span></span><br></pre></td></tr></table></figure>
<p>在windows中打开文件资源管理器（其实就是任意文件夹）：</p>
<p><img src="/images/linux/centos/practice/samba-1.png" alt="image" title="文件资源管理器"></p>
<p>在路径栏输入smb服务器位置：</p>
<p><img src="/images/linux/centos/practice/samba-2.png" alt="image" title="输入smb服务器位置"></p>
<p>回车，输入刚创建的用户名和密码，即可：</p>
<p><img src="/images/linux/centos/practice/samba-3.png" alt="image" title="成功连接"></p>
<p>创建文件：</p>
<p><img src="/images/linux/centos/practice/samba-4.png" alt="image" title="创建文件"></p>
<p>修改文件内容并成功保存：</p>
<p><img src="/images/linux/centos/practice/samba-5.png" alt="image" title="修改文件内容并成功保存"></p>
<p>到这里，就完成了使用windows来对CephFS进行访问。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/vevenlcf/article/details/82350250">Centos7 配置samba服务</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>ceph</tag>
        <tag>cephfs</tag>
        <tag>nfs</tag>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树(Segment Tree)使用记录</title>
    <url>/2019/08/16/2019-08-16-segment-tree/</url>
    <content><![CDATA[<hr>
<h2 id="线段树代码形式"><a href="#线段树代码形式" class="headerlink" title="线段树代码形式"></a>线段树代码形式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] table;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，通常线段树输入一个数组，同时维护自身的一个<code>table</code>数组。
提供<code>query</code>方法来完成对一个区间$[left, right]$的查询操作（最大值、最小值、求和等），
提供<code>update</code>方法来完成对输入数组某一位置的修改。</p>
<p>比如对于子数组最大值的查询，假设数组长度为$N$，查询$M$次，那么<strong>暴力</strong>方法查询的复杂度就为$O(MN)$，
而使用<strong>线段树</strong>则可以将每次查询的复杂度降到$log(n)$，那么总的复杂度就能降到$O(Mlog(N))$。</p>
<p>所以在某些时候，线段树是一个十分有用的数据结构。</p>
<hr>
<h2 id="线段树结构形式"><a href="#线段树结构形式" class="headerlink" title="线段树结构形式"></a>线段树结构形式</h2><hr>
<h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><p>线段树其实就是一颗<strong>满二叉树</strong>，注意到这是一个十分重要的性质（使得可以使用数组快速建树），
它可以推出<strong>“假设叶节点个数为$n$，那么非叶节点的个数一定是 $n - 1$ ”</strong>，
那么同时也就表明总的节点数为 $n + (n - 1) = 2n - 1$ ，<strong>总的节点个数一定是奇数</strong>。</p>
<p>（这里使用的满二叉树定义为：除了叶子结点之外的每一个结点都有两个孩子结点。）</p>
<p><a href="https://blog.csdn.net/qq_22642239/article/details/80774013">完美二叉树, 完全二叉树和完满二叉树</a></p>
<p>下面可以简单的证明一下推论“<strong>假设叶节点个数为$n$，那么非叶节点的个数一定是 $n - 1$ </strong>”：</p>
<ul>
<li>假设总结点树为$n$，非叶节点数为$n_1$，叶节点数为$n_2$，那么$n = n_1 + n_2$。</li>
<li>由二叉树的性质，分支数（边数）为$n - 1$。</li>
<li>由非叶节点都有两个儿子，分支数（边数）也可以计算为$2n_1$。</li>
</ul>
<p>那么：</p>
<script type="math/tex; mode=display">
n - 1 = 2n_1 \\
n = 2n_1 - 1</script><p>可以推出：</p>
<script type="math/tex; mode=display">
n = n_1 + n_2 \\
2n_1 - 1 = n_1 + n_2 \\
n_1 - 1 = n_2</script><p>推论得证。</p>
<hr>
<h3 id="线段树数据结构"><a href="#线段树数据结构" class="headerlink" title="线段树数据结构"></a>线段树数据结构</h3><p>线段树通常使用一个数组<code>T</code>来进行存储，根节点在<code>T[1]</code>的位置（<code>T[0]</code>不使用），
一个节点<code>T[i]</code>的左儿子为<code>T[2i]</code>，右儿子为<code>T[2i+1]</code>，父节点为<code>T[i/2]</code>。</p>
<p>对于最大值来说，每个节点维护以这个节点为根的子树的最大值，所有输入的数据都存放在叶节点。</p>
<p><strong>建树</strong>：</p>
<p>复杂度：$O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeMax</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegmentTreeMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = arr.length;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="keyword">int</span>[n*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j = <span class="number">0</span>; i &lt; table.length; i++, j++) &#123;</span><br><span class="line">            table[i] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            table[i] = Math.max(table[left(i)], table[right(i)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建树时就使用了上面的性质：<strong>假设叶节点个数为$n$，那么非叶节点的个数一定是 $n - 1$ </strong>。所以这里直接申请一个<code>2n</code>大小的数组，
然后从1到n-1为作为非叶节点，n到2n-1作为叶节点。</p>
<p>对于<code>[1, 2, 3, 4, 5, 6]</code>来说，它建立的数组为<code>[0, 6, 6, 2, 4, 6, 1, 2, 3, 4, 5, 6]</code>（注意索引0不使用），形状为：</p>
<div align="center"><img src="/images/algorithm/SegmentTree_1.png"
style="zoom:70%" title="树的形状" /></div>

<p><strong>更新：</strong></p>
<p>复杂度：$O(log(n))$</p>
<p>更新很简单，更新叶节点后再迭代更新父节点即可：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    idx += n; </span><br><span class="line">    table[idx] = num;</span><br><span class="line">    idx = parent(idx);</span><br><span class="line">    <span class="keyword">while</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        table[idx] = Math.max(table[left(idx)], table[right(idx)]);</span><br><span class="line">        idx = parent(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="线段树的查询"><a href="#线段树的查询" class="headerlink" title="线段树的查询"></a>线段树的查询</h2><p>复杂度：$O(log(n))$</p>
<p>线段树的查询才是线段树的精髓所在，其实二叉树这种分治的思想并不是一个难以想到的方法，
但是分治后的子问题结果的合并才是这里比较重要的地方。</p>
<p>线段树的结构已经将问题划分到了一个个子树之上，但是在进行区间查询时，区间可能跨越多颗子树：</p>
<div align="center"><img src="/images/algorithm/SegmentTree_2.png"
style="zoom:70%" title="跨区间查询" /></div>

<p>例如上图，它查询原数组中<code>[3, 5]</code>区间（树中的节点9、10、11）中的最大元素，很明显的，9号节点单独在一颗子树之中。</p>
<p>首先需要注意到上面线段树数据结构中所说“一个节点<code>T[i]</code>的左儿子为<code>T[2i]</code>，右儿子为<code>T[2i+1]</code>”，
那么所有左儿子的节点序号都是偶数，而右儿子的节点序号则都是奇数。</p>
<p>那么对于一个查询区间<code>[L, R]</code>（L不等于R）：</p>
<ul>
<li>对于区间的左边界L，如果它是偶数，那么它是父节点的<strong>左</strong>儿子，那么它的兄弟节点L+1（父节点的右儿子）也属于这个区间之内，那么对于最大值，应该直接向上询问它的父节点。</li>
<li>对于区间的左边界L，如果它是奇数，那么它是父节点的<strong>右</strong>儿子，那么它的兄弟节点L-1（父节点的左儿子）肯定不属于这个区间之内，那么对于最大值，直接询问节点l，不能向上询问它的父节点。</li>
</ul>
<p>对应以上结论：</p>
<ul>
<li>当左边界L为偶数时：<code>L = parent(L)</code>。</li>
<li>当左边界L为奇数时：<code>max = Math.max(max, L)</code>。这里完成了对L这个点的查询，那么就可以对区间进行缩小，即：<code>L = L + 1</code>（注意到L变成了偶数）。</li>
</ul>
<p>右边界的处理同理左边界。</p>
<p>可以看到这是一个不断<strong>收缩</strong>区间左右边界的过程，并从叶节点逐渐向上走，实际代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    l += n;</span><br><span class="line">    r += n;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( l &lt;= r ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (l &amp; <span class="number">1</span>) == <span class="number">1</span> ) &#123;</span><br><span class="line">            max = Math.max(max, table[l]);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( (r &amp; <span class="number">1</span>) != <span class="number">1</span> ) &#123;</span><br><span class="line">            max = Math.max(max, table[r]);</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        l &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        r &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码在不断缩小区间的过程中，并且对于更新后的<code>L&#39;</code>、<code>R&#39;</code>，能够保证 $[L’, R’] \in [L, R]$ ，也不会遗漏任何区间内的元素。</p>
<hr>
<h2 id="线段树代码"><a href="#线段树代码" class="headerlink" title="线段树代码"></a>线段树代码</h2><p>区间最大值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeMax</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegmentTreeMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = arr.length;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="keyword">int</span>[n*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j = <span class="number">0</span>; i &lt; table.length; i++, j++) &#123;</span><br><span class="line">            table[i] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            table[i] = Math.max(table[left(i)], table[right(i)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        idx += n; </span><br><span class="line">        table[idx] = num;</span><br><span class="line">        idx = parent(idx);</span><br><span class="line">        <span class="keyword">while</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            table[idx] = Math.max(table[left(idx)], table[right(idx)]);</span><br><span class="line">            idx = parent(idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        l += n;</span><br><span class="line">        r += n;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( l &lt;= r ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (l &amp; <span class="number">1</span>) == <span class="number">1</span> ) &#123;</span><br><span class="line">                max = Math.max(max, table[l]);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( (r &amp; <span class="number">1</span>) != <span class="number">1</span> ) &#123;</span><br><span class="line">                max = Math.max(max, table[r]);</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            l &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            r &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idx &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (idx &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idx &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是基本的代码形式，可以依据它来修改为各种不同的用途。</p>
<hr>
<h2 id="Leetcode-1157"><a href="#Leetcode-1157" class="headerlink" title="Leetcode 1157"></a>Leetcode 1157</h2><p><a href="https://leetcode.com/problems/online-majority-element-in-subarray/">Leetcode 1157</a></p>
<p>题目大意是给定一个数组，提供以下功能：</p>
<ul>
<li>查询一个区间内的<code>majority-element</code>，也就是这个数的出现次数大于给定的<code>threshold</code>，注意<code>threshold</code>一定大于这个区间的一半大小，
这样即能保证一个区间里面最多只存在一个<code>majority-element</code>。</li>
</ul>
<p>注意到这个题目最关键的思想点在于：</p>
<p><strong>一个区间（区间大小<code>N</code>）中的一个数<code>A</code>，它在区间内的出现次数大于<code>N/2</code>，那么无论将这个区间切分为几个小区间，
这些小区间中，必定至少存在一个小区间t（区间大小<code>n</code>），<code>A</code>在小区间t中的出现次数大于<code>n/2</code></strong>。</p>
<p>这个证明使用<strong>反证</strong>即可：</p>
<p>假设区间$T$，大小为$N$，其中数$A$出现次数$A_T$大于$\frac{N}{2}$。</p>
<p>现在将区间$T$划分为小区间$\{ T_1, T_2, T_3, … , T_m \}$，区间大小为$\{ n_1, n_2, n_3, … , n_m \}$，$A$的出现次数为：</p>
<script type="math/tex; mode=display">\{ A_{T_1}, A_{T_2}, ..., A_{T_m} \}</script><p>如果所有的小区间中，A的出现都不到区间的一半：</p>
<script type="math/tex; mode=display">
A_{T_i} \leqslant \frac{n_i}{2}，对于任意 \  i \in \{1,2,...,m\}</script><p>那么：</p>
<script type="math/tex; mode=display">
A_{T_1} + A_{T_2} + ... + A_{T_m} \leqslant \frac{n_1}{2} + \frac{n_2}{2} + ... + \frac{n_m}{2}  \\
A_T \leqslant \frac{N}{2}</script><p>显然与假设中的 $A_T$大于$\frac{N}{2}$ 相矛盾。</p>
<p>一旦想通了这个<strong>Punchline</strong>，就可以开始使用线段树来做这个题了，线段树中每个节点存储以它为根的子树中最多的元素，
那么一个区间内的最多的元素，就类似于求这个区间内的最大元素，只不过最大元素比的是大小，而这里比的是在子区间中出现的次数多少。</p>
<p>注意到一个查询区间可能由多个子树组成，这就类似与多个子区间，那么这个<code>majority-element</code>一定会出现在某课子树的根节点上。</p>
<p>当然这里还有另一个重点：<strong>如何快速查询一个数在一个子区间内出现多少次？</strong>如果使用遍历，那么是$O(n)$的复杂度。</p>
<p>一个巧妙的方法是将这个数的所有索引存下来形成一个List，通过二分查找来查询子区间的左右边界在List中出现的位置，
相减即可知道子区间中这个数的数量，复杂度$O(log(n))$。</p>
<p>最后代码如下：</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MajorityChecker</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; numIdxs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MajorityChecker</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = arr.length;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="keyword">int</span>[n*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j = <span class="number">0</span>; i &lt; table.length; i++, j++) &#123;</span><br><span class="line">            table[i] = arr[j];</span><br><span class="line">            List&lt;Integer&gt; idxs = numIdxs.get(arr[j]);</span><br><span class="line">            <span class="keyword">if</span> ( idxs == <span class="keyword">null</span> ) &#123;</span><br><span class="line">                idxs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                numIdxs.put(arr[j], idxs);</span><br><span class="line">            &#125;</span><br><span class="line">            idxs.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = left(i), r = right(i);</span><br><span class="line">            table[i] = countRange(l, r, table[l]) &gt; countRange(l, r, table[r]) ? table[l] : table[r];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; idxs = numIdxs.get(num);</span><br><span class="line">        <span class="keyword">int</span> idx1 = Collections.binarySearch(idxs, l);</span><br><span class="line">        <span class="keyword">int</span> idx2 = Collections.binarySearch(idxs, r);</span><br><span class="line">        <span class="keyword">if</span> (idx1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            idx1 = -(idx1 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            idx2 = -(idx2 + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx2 - idx1 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        l += n;</span><br><span class="line">        r += n;</span><br><span class="line">        <span class="keyword">int</span> ll = l, rr = r;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( l &lt;= r ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (l &amp; <span class="number">1</span>) == <span class="number">1</span> ) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = countRange(ll, rr, table[l]);</span><br><span class="line">                <span class="keyword">if</span> (tmp &gt; max) &#123;</span><br><span class="line">                    max = tmp;</span><br><span class="line">                    res = table[l];</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( (r &amp; <span class="number">1</span>) != <span class="number">1</span> ) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = countRange(ll, rr, table[r]);</span><br><span class="line">                <span class="keyword">if</span> (tmp &gt; max) &#123;</span><br><span class="line">                    max = tmp;</span><br><span class="line">                    res = table[r];</span><br><span class="line">                &#125;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            l &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            r &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max &gt;= threshold ? res : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idx &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (idx &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="进一步"><a href="#进一步" class="headerlink" title="进一步"></a>进一步</h2><p><a href="http://longrm.com/2019/08/18/2019-08-21-segment-tree/">线段树(Segment Tree)进阶使用记录(HDU3397)</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>云改讲坛和部门业务培训记录</title>
    <url>/2019/08/23/2019-08-23-cloud-workgroup/</url>
    <content><![CDATA[<hr>
<h1 id="云"><a href="#云" class="headerlink" title="云"></a>云</h1><p>下面围绕三个部分进行记录:</p>
<ol>
<li>云是什么？</li>
<li>云的当前市场状态。</li>
<li>云的未来变化趋势。</li>
</ol>
<hr>
<h2 id="云是什么？"><a href="#云是什么？" class="headerlink" title="云是什么？"></a>云是什么？</h2><p>云起源于虚拟化技术。虚拟化技术实现了把一台物理机虚拟成多台服务器的能力，由于这个能力，那么就可以在一台物理机上虚拟出多个虚拟机来同时提供给多个用户使用，它们共享物理机的资源。既然这样，就可以将多台物理机统一管理起来，这样就可以在同一时间提供出更多的虚拟机来给用户使用。更进一步，可以为用户提供配套的管理系统，方便用户使用，这样就形成了一朵云。</p>
<p>从内部来看，云是一个个服务器组成的。从外部来看，云是一个具有强大的计算能力、存储能力和网络能力的整体。</p>
<hr>
<h3 id="云的类别划分"><a href="#云的类别划分" class="headerlink" title="云的类别划分"></a>云的类别划分</h3><p><img src="/images/report/cloud_1.png" alt="image" title="云的类别划分"></p>
<p>一般业界通过云的共享程度来对云的类别进行划分，通常划分为公有云、专属云和私有云。从图中可以看到它们的共享程度逐渐降低，公有云几乎全部都是与他人共享的，而私有云几乎全都是独享的。</p>
<p>混合云，从名字就可以看出，它是几种云的混合，也许某个用户一部分业务需要部署到私有云，而另一部分业务放在公有云就可以（毕竟私有云要比公有云贵），那么混合云就可以帮他解决这个问题。</p>
<p>不同的云的类别总是适合不同的用户，不同的类别也就相当于不同的产品类型。</p>
<hr>
<h3 id="三类服务形态"><a href="#三类服务形态" class="headerlink" title="三类服务形态"></a>三类服务形态</h3><p>谈云的时候，常常会说I层、P层和S层，即Iaas、PaaS和SaaS，这也就是云的三类服务形态。</p>
<p><img src="/images/report/cloud_2.png" alt="image" title="三层对比"></p>
<p><strong>IaaS</strong>：基础设施即服务。服务的功能就类似于用户自己租了一台或者多台物理服务器，至于这些服务器用户想要怎么操作和管理，这里都不关心。当然硬件的管理不需要用户操心。</p>
<p><strong>PaaS</strong>：平台即服务。在I层的基础上，提供了操作系统、中间件以及运行库等，也就是说其它的东西都准备好了，用户直接往上面部署应用就行。</p>
<p><strong>SaaS</strong>：软件即服务。在PaaS的基础上，甚至连软件都以及部署好了，用户相当于买了一个已经正常运行了的软件，直接使用就行。</p>
<hr>
<h3 id="云的商业模式"><a href="#云的商业模式" class="headerlink" title="云的商业模式"></a>云的商业模式</h3><p>云既然是一件商品，那么它就需要吸引到客户，需要能够赚钱。</p>
<p>吸引客户的原因：</p>
<ol>
<li>快捷，低门槛。对一个小公司或初创公司，相比于直接买几台云主机，维护一个机房费时也费力。</li>
<li>按需，低成本。需要增加计算能力的时候，多买几台云主机或者扩容就行，不需要的时候再退掉，不仅节约钱，而且方便。</li>
</ol>
<p>能够赚钱的条件和原因：</p>
<ol>
<li>到达一定规模是前提。第一，每台机器的平均管理成本就会降低。第二，能够更好的复用和超售，同一台机器，不同的时间可以提供给不同的客户使用，同一个服务，也可以卖给更多的用户。</li>
<li>交叉补贴和价值填充。在卖A服务的同时，将服务B一同卖出，或是卖服务B时，将服务A一同卖出，也就是将商品绑在一起卖。</li>
</ol>
<p>当然，实际上到现在为止，各家的公有云和私有云都不赚钱或者不怎么赚钱，对于公有云来说，赚钱的关键在于规模；对于私有云，它的商业模式就决定了大部分操作留给了用户，而且还不能超售，所以难以赚钱。</p>
<hr>
<h2 id="云的当前市场状态"><a href="#云的当前市场状态" class="headerlink" title="云的当前市场状态"></a>云的当前市场状态</h2><p><img src="/images/report/cloud_3.png" alt="image" title="公有云市场状态"></p>
<p>云计算的市场最开始是百家争鸣，但是到今年为止，市场格局逐渐清晰。正如上面所说，云要获得盈利的一个重要前提在于规模，那么规模正是一个此消彼长的东西。在图2-1中可以看到，阿里云占领了整个市场的近半壁江山，而紧随其后的就是腾讯云和天翼云。</p>
<p>这里引用《中国公有云服务市场（2018下半年）跟踪》中所述，当前的市场状态如下：</p>
<ol>
<li>云产品迭代创新快：2018年公有云产品发布主要围绕高性能计算、异构计算、容器和无服务器、机器学习和机器人应用、IoT平台、自研云原生数据库、混合云七大关键词展开。</li>
<li>云与智能的强融合：智能云、云智能已然成为主要公有云服务商的未来战略，不仅体现在组织结构调整上，还体现在产品和服务研发上。基于云上的一体化的、使用便捷的AI服务能力成为公有云服务商比拼的重要方向。</li>
<li>混合云成发展常态：企业用户的多样化需求、公有云服务商的多元化发展，使得混合云部署、管理和运维等逐渐发展为一个初具规模的专业化市场，并对越来越多传统的信息技术服务商、增值开发商等体现出强烈的吸引力。</li>
<li>行业探索逐渐落地：虽然中国互联网行业的云计算应用已经相对成熟，但广大的非互联网行业对公有云的探索才开始不久。阿里、腾讯、华为、百度、浪潮等纷纷结合自身优势，明确了重点行业纵深发展战略，并借力合作生态布局不断拓展细分行业市场。</li>
</ol>
<hr>
<h2 id="云的未来变化趋势"><a href="#云的未来变化趋势" class="headerlink" title="云的未来变化趋势"></a>云的未来变化趋势</h2><p>首先，云本身从关注基础设施层逐渐过渡到开发部署运维，首先随着云越来越成熟，关注点逐渐从下层向上转移是一件很自然的事，其次正如上面所说的“交叉补贴和价值填充”，更多的增值服务才能赚到钱。</p>
<p>其次，现在迅速发展的IoT，以及马上就要广泛使用的5G，它们的结合正好需要“边缘计算”的能力。目前各家云厂商都已经开始了这方面的布局。</p>
<p>混合云、多云管理将成为主流。预计到2021年，使用云的组织中的75%将部署多云或混合云模型，所以一定要注意这方面产品的规划与发展。</p>
<p>云与大数据的结合成为新常态。云能够解决传统大数据的一些痛点，例如汇聚难、整合难和标记难等，云的数据分析能力和AI能力正好能够解决这些问题。</p>
<p>ABC的全面融合。ABC即AI、大数据和云计算，现在其实ABC已经不是一个割裂的不同概念了，通常将它们三个放在一起来讨论，由大数据和云计算所支撑起来的AI服务会是一个未来的卖点。</p>
<hr>
<h1 id="部门业务培训"><a href="#部门业务培训" class="headerlink" title="部门业务培训"></a>部门业务培训</h1><p>我所在的组：媒体存储组。</p>
<p>部门目前的主要业务：存储业务（也包含视频点播转码等）。</p>
<p>所包含的能力：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---- 存储能力（Ceph集群）</span><br><span class="line">---- 文件上传（S3，CephFS，iSCSI）</span><br><span class="line">		---- 普通文件上传</span><br><span class="line">		---- 视频文件上传</span><br><span class="line">		---- 视频转码（FFmpeg）</span><br><span class="line">---- 文件下载（S3，CephFS，iSCSI）</span><br><span class="line">	---- 普通文件下载</span><br><span class="line">	---- 视频文件点播（nginx）</span><br></pre></td></tr></table></figure>
<p>下面从底向上来记录培训的内容：</p>
<ol>
<li>Linux相关。</li>
<li>Ceph相关。</li>
<li>视频转码与点播。</li>
<li>TCP/IP中的TCP部分。</li>
</ol>
<p>所有得培训记录都在下面（我竟然写了12篇博客…）：</p>
<p><a href="http://longrm.com/2019/07/11/2019-07-12-linux-base-practice_1/">linux基础练习-1</a></p>
<p><a href="http://longrm.com/2019/07/15/2019-07-15-linux-base-practice_2/">linux基础练习-2</a></p>
<p><a href="http://longrm.com/2019/07/18/2019-07-18-ceph-install/">centos7上的ceph指定版本安装方法</a></p>
<p><a href="http://longrm.com/2019/07/19/2019-07-19-ceph-osd-create-remove/">ceph-13.2.5删除osd，新建osd</a></p>
<p><a href="http://longrm.com/2019/07/22/2019-07-22-ceph-mon-add-destroy/">ceph-13.2.5添加mon，删除mon（ceph-deploy）</a></p>
<p><a href="http://longrm.com/2019/07/23/2019-07-23-centos-lvm-create-extend/">centos7中lvm分区的创建与扩展</a></p>
<p><a href="http://longrm.com/2019/08/02/2019-08-02-ceph-s3-use/">ceph-mimic-13.2.5中s3的初步使用</a></p>
<p><a href="http://longrm.com/2019/08/05/2019-08-05-ceph-fs-use/">ceph-mimic-13.2.5中CephFS的初步使用</a></p>
<p><a href="http://longrm.com/2019/08/06/2019-08-06-ceph-samba/">ceph+samba的简单使用</a></p>
<p><a href="http://longrm.com/2019/08/06/2019-08-06-ceph-iscsi/">ceph+iscsi的简单使用</a></p>
<p><a href="http://longrm.com/2019/08/08/2019-08-08-ffmpeg-practice/">练习使用FFmpeg将视频转码为hls，并添加水印</a></p>
<p><a href="http://longrm.com/2019/08/14/2019-08-14-TCP-IP-19-20-21/">TCP/IP详解卷1：协议 第19、20、21章笔记</a></p>
]]></content>
      <categories>
        <category>company</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title>rsyslog + Logrotate进行日志记录并切割压缩</title>
    <url>/2019/09/26/2019-09-26-rsyslog-logrotate/</url>
    <content><![CDATA[<hr>
<h1 id="目标描述"><a href="#目标描述" class="headerlink" title="目标描述"></a>目标描述</h1><p>Golang程序将日志写入到rsyslog的LOCAL0中。</p>
<p>所以这里要使用rsyslog记录来自LOCAL0的日志，几点需求：</p>
<ol>
<li>日志存储在<code>/xxx/程序名/程序名.log</code>下。</li>
<li>要对日志进行切割，压缩。</li>
</ol>
<p>这里主要需要研究的功能就是：</p>
<ol>
<li><code>rsyslog</code>的日志动态路径。</li>
<li><code>Logrotate</code>的定期日志切割。</li>
<li><code>Logrotate</code>的日志压缩。</li>
</ol>
<p>另外：</p>
<p>这里系统为<strong>Centos7</strong>，不涉及远程日志记录。</p>
<p>关于rsyslog和Logrotate的介绍网上有很多：</p>
<p><a href="https://blog.csdn.net/qq_34556414/article/details/81610534">Linux rsyslog服务</a></p>
<p><a href="http://blog.itpub.net/31559985/viewspace-2286286/">Rsyslog日志系统</a></p>
<p><a href="https://www.cnblogs.com/clsn/p/8428257.html">日志切割之Logrotate</a></p>
<p><a href="https://www.jianshu.com/p/ec7f1626a3d3">高效的log工具：Logrotate</a></p>
<hr>
<h1 id="rsyslog的配置"><a href="#rsyslog的配置" class="headerlink" title="rsyslog的配置"></a>rsyslog的配置</h1><p>rsyslog版本(centos7)：8.24.0-41 </p>
<hr>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>rsyslog的配置文件位于<code>/etc/rsyslog.conf</code>，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> Log all the mail messages <span class="keyword">in</span> one place.</span></span><br><span class="line">mail.*                                                  -/var/log/maillog</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Log cron stuff</span></span><br><span class="line">cron.*                                                  /var/log/cron</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Everybody gets emergency messages</span></span><br><span class="line">*.emerg                                                 :omusrmsg:*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Save news errors of level crit and higher <span class="keyword">in</span> a special file.</span></span><br><span class="line">uucp,news.crit                                          /var/log/spooler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Save boot messages also to boot.log</span></span><br><span class="line">local7.*                                                /var/log/boot.log</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上面的配置中，所使用的<code>*</code>就表示通配，例如<code>mail.*</code>就表示来自<code>mail</code>的所有级别日志都记录到
<code>-/var/log/maillog</code>中。<code>*.emerg</code>则表示所有<code>emerg</code>级别以上的日志（其实<code>emerg</code>已经是最高级别）都发送给所有正在登陆的用户。</p>
<p>rsyslog有三种配置格式<code>basic</code>、<code>advanced</code>和<code>obsolete legacy</code>，它们可以在同一个配置文件中混用，但是官方建议尽量避免使用<code>obsolete legacy</code>配置格式，
因为这个不健康，官方原话：<code>Do not use obsolete legacy format. It will make your life miserable.</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> basic</span></span><br><span class="line">mail.info /var/log/mail.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> advanced</span></span><br><span class="line">mail.info action(type=&quot;omfile&quot; File=&quot;/var/log/mail.log&quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> legacy（下面例子的含义和上面不一样，它定义一个Template）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 总之一般带着 $ 的语句格式都是 legacy</span></span><br><span class="line"><span class="meta">$</span><span class="bash">template DynFile,<span class="string">&quot;/var/log/%HOSTNAME%/%programname%.log&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>这里如果要让自己的程序使用rsyslog来记录日志，那么就可以使用<code>LOCAL0~6</code>这些<strong>facility</strong>来进行我们的自定义日志记录，</p>
<hr>
<h2 id="配置日志动态路径"><a href="#配置日志动态路径" class="headerlink" title="配置日志动态路径"></a>配置日志动态路径</h2><p>例如一条在rsyslog接收到一条日志之后，希望它能将根据日志附带的tag信息，
将日志打印到 /logdir/tag/tag.log 文件，这就是动态日志路径。</p>
<p>要达到这个目的，使用rsyslog配置中的<strong>Templates</strong>语法结构即可。</p>
<p><a href="https://www.rsyslog.com/doc/master/configuration/templates.html">Templates</a></p>
<p>这里可以使用<code>Templates</code>来定义一段字符串，字符串中可以带有变量，这样就可以达到日志记录位置随日志的tag信息而变化的目的。</p>
<p>修改 /etc/rsyslog.conf :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">template(name=&quot;MyDynFile&quot; type=&quot;string&quot; string=&quot;/var/log/%programname%/%programname%.log&quot;)</span><br><span class="line"></span><br><span class="line">local0.*   action(type=&quot;omfile&quot; dynaFile=&quot;MyDynFile&quot;)</span><br></pre></td></tr></table></figure>
<p>上面的配置中，首先定义了一个<strong>string</strong>类型的Template，然后将local0的所有日志输入到这个路径下的日志文件中，</p>
<p>这里的<code>%programname%</code>即表示：</p>
<blockquote>
<p>the “static” part of the tag, as defined by BSD syslogd. For example, when TAG is “named[12345]”, programname is “named”.</p>
</blockquote>
<p>也就是说这里将日志保存到<code>/var/log/%programname%/%programname%.log</code>路径之下，更多的字段可以参考<a href="https://www.rsyslog.com/doc/master/configuration/properties.html">rsyslog Properties</a>。</p>
<p><strong>测试配置：</strong></p>
<p>首先使用命令看配置是否有语法错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ &#x2F;usr&#x2F;sbin&#x2F;rsyslogd -f &#x2F;etc&#x2F;rsyslog.conf -N1</span><br></pre></td></tr></table></figure>
<p>重启rsyslog服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart rsyslog</span></span><br></pre></td></tr></table></figure>
<p>测试配置是否达到预期：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> logger -t <span class="built_in">test</span> -p local0.info <span class="string">&quot;hello world&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /var/<span class="built_in">log</span>/<span class="built_in">test</span>/test.log</span></span><br><span class="line"></span><br><span class="line">Sep 23 11:38:32 node1 test: hello world</span><br></pre></td></tr></table></figure>
<p>可以看到这里动态日志路径配置成功。</p>
<hr>
<h1 id="Logrotate-配置"><a href="#Logrotate-配置" class="headerlink" title="Logrotate 配置"></a>Logrotate 配置</h1><p>上面完成了使用rsyslog来进行日志记录，但是如果不对日志进行切割压缩，日志的大小就会无限增长，不仅将来不好查询，而且占存储空间，
这里可以使用Logrotate来进行日志的切割与压缩。</p>
<p>Logrotate并不是一个一直运行的linux程序，它的自动运行是linux的计划任务cron来实现的，位于<code>/etc/cron.daily/logrotate</code>，
它每天执行一次。</p>
<p>而Logrotate的配置文件则位于<code>/etc/logrotate.conf</code>，这个配置文件里面又包含了目录<code>/etc/logrotate.d/</code>下的所有配置文件，
所有通常在<code>/etc/logrotate.d/</code>目录下来添加自定义的配置文件。</p>
<p><strong>切割日志</strong>：</p>
<ul>
<li>方法一：将原日志文件重命名，重新创建新的日志文件，通知使用此日志的进程使用新的日志文件。对应Logrotate中的<code>create</code>。</li>
<li>方法二：先将原日志文件复制，然后截断原文件，这样不需要通知使用此日志的进程，但两个操作之间有短暂的时间间隙，可能会丢失日志。对应Logrotate中的<code>copytruncate</code>。</li>
<li>方法三：只复制原日志文件。对应Logrotate中的<code>copy</code>。</li>
</ul>
<p>这里之所以有三种切割日志的方法，原因在于当一个程序获取到一个文件句柄并向里面写入数据时，即使此时文件名发生了变化，
也不会影响之前的文件句柄的使用，程序仍然可以通过这个文件句柄写入数据到此文件中，如果不对原程序发出通知，让其重新获取文件句柄，
那么这个日志文件的大小就会继续增长。</p>
<p><strong>压缩日志</strong>：经过日志切割，原日志文件已经重命名，已经没有进程再继续使用它，这时便可以进行任意的操作，想要压缩就可以直接进行压缩。</p>
<p><strong>rotate</strong>：保留日志文件的数量（轮转数量）。例如rotate为3，切割出来日志文件为<code>log.1</code>、<code>log.2</code>和<code>log.3</code>，则下一次再进行切割时，
会将<code>log.3</code>删除，<code>log.2</code>重命名为<code>log.3</code>，<code>log.1</code>重命名为<code>log.2</code>，新切割出来的日志文件命名为<code>log.1</code>。</p>
<hr>
<h2 id="Logrotate的具体配置。"><a href="#Logrotate的具体配置。" class="headerlink" title="Logrotate的具体配置。"></a>Logrotate的具体配置。</h2><p>这里添加一个新的配置文件到<code>/etc/logrotate.d/</code>目录下，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/var/log/*/*.log &#123;</span><br><span class="line">    create 0644 root root   // 新创建日志文件的权限</span><br><span class="line">    daily                   // 每天执行一次</span><br><span class="line">    rotate 65535            // 轮转数量 65535，基本等于存储所有日志</span><br><span class="line">    size 1M                 // 超过1M才进行切割</span><br><span class="line">    dateext                 // 使用日期作为后缀</span><br><span class="line">    dateformat -%Y%m%d.%s   // 定义日期后缀的格式</span><br><span class="line">    missingok               // 没有找到日志文件也OK</span><br><span class="line">    notifempty              // not ifempty 如过日志文件为空，则不切割</span><br><span class="line">    compress                // 切割后进行压缩</span><br><span class="line">    sharedscripts           // 脚本只执行一次</span><br><span class="line">    postrotate              // 脚本，用于通知rsyslog使用新的日志文件</span><br><span class="line">        /bin/kill -HUP `cat /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || true</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先配置的路径为<code>/var/log/*/*.log</code>，因为上面rsyslog将LOCAL0的日志记录到了<code>/var/log/%programname%/%programname%.log</code>，
这样便能够通配到所有LOCAL0的日志文件。</p>
<p>注意到这里的最后几句配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postrotate              // 脚本，用于通知rsyslog使用新的日志文件</span><br><span class="line">    /bin/kill -HUP `cat /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || true</span><br><span class="line">endscript</span><br></pre></td></tr></table></figure>
<p>其中夹在<code>postrotate</code>和<code>endscript</code>中间的就是脚本，<code>postrotate</code>表示脚本在rotate之后运行，也就是此时已经将原日志文件重命名，
并且创建了新日志文件，但是还没有对原日志文件进行压缩。脚本中使用<code>kill -HUP</code>来通知rsyslog使用新日志文件，脚本执行完毕后，
Logrotate将对原日志文件使用gzip进行压缩。</p>
<p><strong>这里切割出来的日志文件将保存在与原日志文件同一目录下</strong>，如果想要将切割出来的日志文件保存到别的目录，可以添加下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">olddir   &#x2F;var&#x2F;log&#x2F;old</span><br></pre></td></tr></table></figure>
<p>这样切割下来的日志文件就会存储在<code>/var/log/old</code>目录之下（old目录需要手动创建）。</p>
<hr>
<h2 id="Logrotate-日志压缩"><a href="#Logrotate-日志压缩" class="headerlink" title="Logrotate 日志压缩"></a>Logrotate 日志压缩</h2><p>默认情况下，Logrotate使用gzip进行压缩，当然也可以配置其它的压缩工具。</p>
<p>如果要使用<code>bzip2</code>来进行压缩，则可以使用下面的配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">compress</span><br><span class="line">compresscmd  /usr/bin/bzip2</span><br><span class="line">compressext  .bz2</span><br><span class="line">compressoptions -9</span><br></pre></td></tr></table></figure>
<p>那么在压缩日志时，就会使用<code>/usr/bin/bzip2 -9</code>来进行压缩。</p>
<p>使用bzip2可以达到更大的压缩比，但是在压缩过程中也会消耗更多的CPU。</p>
<p>同理也可以配置成其它的压缩工具。</p>
<hr>
<h2 id="Logrotate-定期执行"><a href="#Logrotate-定期执行" class="headerlink" title="Logrotate 定期执行"></a>Logrotate 定期执行</h2><p>Logrotate通过cron来定期运行，默认配置在<code>/etc/cron.daily/logrotate</code>，也就是默认每天执行一次。</p>
<p>使用下面命令可以让Logrotate立即执行某一配置，而不用等待计划任务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 立即执行syslog配置</span><br><span class="line"><span class="meta">$</span><span class="bash"> logrotate /etc/logrotate.d/syslog</span></span><br><span class="line"></span><br><span class="line">// 使用debug模式执行，并不改变和生成任何日志文件</span><br><span class="line"><span class="meta">$</span><span class="bash"> logrotate -d /etc/logrotate.d/syslog</span></span><br><span class="line"></span><br><span class="line">// 强制执行，忽略size参数</span><br><span class="line"><span class="meta">$</span><span class="bash"> logrotate -f /etc/logrotate.d/syslog</span></span><br></pre></td></tr></table></figure>
<p>如果想要更灵活的执行时间配置，就可以在cron中来添加，例如想要Logrotate每分钟执行一次，则可以在<code>/etc/crontab</code>中进行配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/crontab</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/crontab</span></span><br><span class="line"></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> For details see man 4 crontabs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Example of job definition:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  |  |</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> *  *  *  *  * user-name  <span class="built_in">command</span> to be executed</span></span><br><span class="line">*/1  *  *  *  *   root    logrotate /etc/logrotate.d/syslog</span><br></pre></td></tr></table></figure>
<p>这样就可以使得Logrotate每分钟执行一次。</p>
<hr>
<h1 id="配置总结"><a href="#配置总结" class="headerlink" title="配置总结"></a>配置总结</h1><p><strong>rsyslog：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">umask</span> 0000</span></span><br><span class="line">template(name=&quot;MyDynFile&quot; type=&quot;string&quot; string=&quot;/data1/log/%programname%/%programname%.log&quot;)</span><br><span class="line">local0.*     action(type=&quot;omfile&quot; dynaFile=&quot;MyDynFile&quot; dirCreateMode=&quot;0755&quot; fileCreateMode=&quot;0644&quot; ioBufferSize=&quot;64K&quot;)</span><br></pre></td></tr></table></figure>
<p>这里的<code>umask</code>配合<code>dirCreateMode</code>和<code>fileCreateMode</code>来使用，这样便可指定创建出来的文件夹与文件的默认权限。</p>
<p><strong>Logrotate：</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/data1/log/*/*.log &#123;</span><br><span class="line">    create 0644 root root</span><br><span class="line">    daily</span><br><span class="line">    rotate 65535</span><br><span class="line">    size 1M</span><br><span class="line">    dateext</span><br><span class="line">    dateformat -%Y%m%d.%s</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    compress</span><br><span class="line">    sharedscripts</span><br><span class="line">    postrotate</span><br><span class="line">        /bin/kill -HUP `cat /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || true</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="补充：docker内使用rsyslog-Logrotate"><a href="#补充：docker内使用rsyslog-Logrotate" class="headerlink" title="补充：docker内使用rsyslog + Logrotate"></a>补充：docker内使用rsyslog + Logrotate</h1><p>今天要在docker中配置rsyslog + Logrotate，发现centos7的docker中没有自带rsyslog和cron，并且没有systemd，所以不能通过systemctl来操作服务。</p>
<p>首先需要安装rsyslog和cron：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install -y rsyslog cronie</span></span><br></pre></td></tr></table></figure>
<p><strong>非常重要的一点在于：</strong>rsyslog 默认通过 journal 读取日志信息，但CentOS镜像默认并未安装systemd和journald。</p>
<p>首先kill掉正在运行的rsyslog进程，然后修改配置：</p>
<ul>
<li>注释<code>$ModLoad imjournal</code></li>
<li>注释<code>$IMJournalStateFile imjournal.state</code></li>
<li>将<code>$OmitLocalLogging on</code>改为<code>$OmitLocalLogging off</code></li>
<li>将journal的配置删除：<code>rm -rf /etc/rsyslog.d/listen.conf</code></li>
</ul>
<p>启动rsyslog：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rsyslogd</span><br></pre></td></tr></table></figure>
<p>启动cron：</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># crond</span><br></pre></td></tr></table></figure></h2><h1 id="补充：修改rsyslog的日志记录格式"><a href="#补充：修改rsyslog的日志记录格式" class="headerlink" title="补充：修改rsyslog的日志记录格式"></a>补充：修改rsyslog的日志记录格式</h1><p>首先可以看到默认的rsyslog的格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Sep 30 17:21:49 localhost test: Hello World!!!</span><br></pre></td></tr></table></figure>
<p>它所对应的配置格式是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">template(name=&quot;FileFormat&quot; type=&quot;string&quot;</span><br><span class="line">         string= &quot;%TIMESTAMP% %HOSTNAME% %syslogtag%%msg:::sp-if-no-1st-sp%%msg:::drop-last-lf%\n&quot;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>可以看到其实有点儿丑，为了把它变得好看一点，需要新建一个template来定义它的格式。</p>
<p>官方文档中这部分定义的字段都可以使用:</p>
<ul>
<li><a href="https://www.rsyslog.com/doc/master/configuration/properties.html">rsyslog Properties</a></li>
<li><a href="https://www.rsyslog.com/doc/master/configuration/property_replacer.html#property-options">The Property Replacer</a></li>
</ul>
<p>这里定义的<code>template</code>如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">template(name=&quot;MyOutFmt&quot; type=&quot;list&quot;) &#123;</span><br><span class="line">    constant(value=&quot;[&quot;)</span><br><span class="line">    property(name=&quot;syslogseverity-text&quot;)</span><br><span class="line">    constant(value=&quot;]&quot;)</span><br><span class="line"></span><br><span class="line">    constant(value=&quot;[&quot;)</span><br><span class="line">    property(name=&quot;timereported&quot; dateformat=&quot;year&quot;)</span><br><span class="line">    constant(value=&quot;-&quot;)</span><br><span class="line">    property(name=&quot;timereported&quot; dateformat=&quot;month&quot;)</span><br><span class="line">    constant(value=&quot;-&quot;)</span><br><span class="line">    property(name=&quot;timereported&quot; dateformat=&quot;day&quot;)</span><br><span class="line">    constant(value=&quot; &quot;)</span><br><span class="line">    property(name=&quot;timereported&quot; dateformat=&quot;hour&quot;)</span><br><span class="line">    constant(value=&quot;:&quot;)</span><br><span class="line">    property(name=&quot;timereported&quot; dateformat=&quot;minute&quot;)</span><br><span class="line">    constant(value=&quot;:&quot;)</span><br><span class="line">    property(name=&quot;timereported&quot; dateformat=&quot;second&quot;)</span><br><span class="line">    constant(value=&quot; &quot;)</span><br><span class="line">    property(name=&quot;timereported&quot; dateformat=&quot;tzoffsdirection&quot;)</span><br><span class="line">    property(name=&quot;timereported&quot; dateformat=&quot;tzoffshour&quot;)</span><br><span class="line">    property(name=&quot;timereported&quot; dateformat=&quot;tzoffsmin&quot;)</span><br><span class="line">    constant(value=&quot;]&quot;)</span><br><span class="line"></span><br><span class="line">    constant(value=&quot;[&quot;)</span><br><span class="line">    property(name=&quot;programname&quot; position.from=&quot;1&quot; position.to=&quot;32&quot;)</span><br><span class="line">    constant(value=&quot;]&quot;)</span><br><span class="line">    constant(value=&quot;: &quot;)</span><br><span class="line">    property(name=&quot;msg&quot;)</span><br><span class="line">    constant(value=&quot;\n&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>配置输出文件的<code>template</code>为<code>MyOutFmt</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">local0.*   action(type=&quot;omfile&quot; dynaFile=&quot;MyDynFile&quot; template=&quot;MyOutFmt&quot;  dirCreateMode=&quot;0755&quot; fileCreateMode=&quot;0644&quot; ioBufferSize=&quot;64K&quot;)</span><br></pre></td></tr></table></figure>
<p>测试效果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> logger -t <span class="built_in">test</span> -p local0.info <span class="string">&#x27;Hello World!!!&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> logger -t <span class="built_in">test</span> -p local0.warning <span class="string">&#x27;Hello World!!!&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> logger -t <span class="built_in">test</span> -p local0.err <span class="string">&#x27;Hello World!!!&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> tail -n3 /data1/<span class="built_in">log</span>/<span class="built_in">test</span>/test.log</span></span><br><span class="line"></span><br><span class="line">[warning][2019-09-30 18:13:25 +0800][test]: Hello World!!!</span><br><span class="line">[err][2019-09-30 18:13:31 +0800][test]: Hello World!!!</span><br><span class="line">[err][2019-09-30 18:14:19 +0800][test]: Hello World!!!</span><br></pre></td></tr></table></figure>
<p>ok，顺眼多了。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.rsyslog.com/">The rocket-fast Syslog Server</a></p>
<p><a href="https://linux.die.net/man/8/logrotate">logrotate(8) - Linux man page</a></p>
<p><a href="http://www.mamicode.com/info-detail-2685573.html">docker容器中使用rsyslogd</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>rsyslog</tag>
        <tag>logrotate</tag>
      </tags>
  </entry>
  <entry>
    <title>srs带ffmpeg的安装</title>
    <url>/2019/09/18/2019-09-18-srs-ffmpeg/</url>
    <content><![CDATA[<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>主要记录一下如何成功在centos7下面编译安装带ffmpeg的srs，其中有一些小坑。</p>
<p>这里srs版本为<code>2.0.263</code>。</p>
<hr>
<h1 id="下载编译srs"><a href="#下载编译srs" class="headerlink" title="下载编译srs"></a>下载编译srs</h1><p>直接看github，<a href="https://github.com/ossrs/srs">https://github.com/ossrs/srs</a></p>
<p>很简单的几步：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/ossrs/srs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> srs/trunk</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure &amp;&amp; make</span></span><br></pre></td></tr></table></figure>
<p>那么上面就完成了srs的编译，但是没有带ffmpeg。</p>
<hr>
<h1 id="带ffmpeg"><a href="#带ffmpeg" class="headerlink" title="带ffmpeg"></a>带ffmpeg</h1><p>srs自带了ffmpeg，但是在编译的时候需要加上<code>--with-ffmpeg</code>，也就是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --with-ffmpeg &amp;&amp; make</span><br></pre></td></tr></table></figure>
<p>其中可能会报几个错，这里说一下我遇到的。</p>
<p><strong>问题一：</strong></p>
<p><strong>Found no assembler</strong>，提示缺少<strong>nasm</strong>。</p>
<p>去下一个安装就行，<a href="http://www.linuxfromscratch.org/blfs/view/8.2/general/nasm.html">NASM-2.13.03</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://www.nasm.us/pub/nasm/releasebuilds/2.13.03/nasm-2.13.03.tar.xz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -xf nasm-2.13.03.tar.xz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv nasm-2.13.03 nasm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> nasm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=/usr &amp;&amp; make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make install</span></span><br></pre></td></tr></table></figure>
<p><strong>问题二：</strong></p>
<p><strong>speex not found using pkg-config</strong></p>
<p>提示找不到<code>speex</code>。</p>
<p>但是其实<code>speex</code>就在<code>srs/trunk/objs/ffmpeg.src/speex-1.2rc1/</code>下面，可以看到其中有<code>speex.pc</code>就没错。那么设置一下路径即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PKG_CONFIG_PATH=/xxx/srs/trunk/objs/ffmpeg.src/speex-1.2rc1/</span></span><br></pre></td></tr></table></figure>
<p>然后这个问题就解决了。</p>
<p><strong>问题三：</strong></p>
<p><strong>bzlib requested but not found</strong></p>
<p>提示找不到<code>bzlib</code>，那么安装一下就行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y bzip2-devel.x86_64</span></span><br></pre></td></tr></table></figure>
<p>解决上面三个问题，应该就能成功编译带ffmpeg的srs了。</p>
]]></content>
      <categories>
        <category>live</category>
      </categories>
      <tags>
        <tag>live</tag>
        <tag>srs</tag>
      </tags>
  </entry>
  <entry>
    <title>golang中unsafe.Pointer的入门使用</title>
    <url>/2019/09/30/2019-09-30-golang-unsafe_pointer/</url>
    <content><![CDATA[<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在做<a href="https://leetcode.com/problems/remove-duplicate-letters/">316. Remove Duplicate Letters</a>遇到了[]byte转string的问题，
发现可以通过<code>unsafe.Pointer</code>来完成转换，由此产生了对golang中指针操作的兴趣。</p>
<hr>
<h1 id="byte转string"><a href="#byte转string" class="headerlink" title="[]byte转string"></a>[]byte转string</h1><p><strong>首先不通过指针直接转：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="keyword">byte</span> = []<span class="keyword">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="keyword">string</span>(b)</span><br><span class="line">    fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>abc</p>
</blockquote>
<p>可以看到直接转是可以的，但是直接转整个[]byte会被<strong>复制</strong>一遍再给到string中，不是最高效率的做法。</p>
<p><strong>通过指针来转：</strong></p>
<p>注意如果直接转指针，go语言是不允许的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b []<span class="keyword">byte</span> = []<span class="keyword">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> str *<span class="keyword">string</span> = (*<span class="keyword">string</span>)(&amp;b)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Cannot convert expression of type <em>[]byte to type </em>string</p>
</blockquote>
<p>要想进行指针转换，需要使用unsafe.Pointer来中继：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="keyword">byte</span> = []<span class="keyword">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span> = *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">    fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>abc</p>
</blockquote>
<p>上面的代码先将[]byte的指针转化为unsafe包中的ArbitraryType类型，然后就可以转化为任意别的类型的指针，
这里就将它转化为<code>*string</code>类型的指针。</p>
<p>因为string和[]byte的底层的c语言结构为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        byte*   str;</span><br><span class="line">        intgo   len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>	<span class="title">Slice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	byte*	<span class="built_in">array</span>;</span><br><span class="line">	uintgo	len;</span><br><span class="line">	uintgo	cap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以可以直接从切片[]byte转到string也毫无违和感。</p>
<p>这样string与切片[]byte<strong>共用一片内存</strong>，本来go的string是不可变的，这里<strong>竟然</strong>可以使得string内容可变：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="keyword">byte</span> = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    b[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    b[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> str *<span class="keyword">string</span> = (*<span class="keyword">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">    fmt.Println(*str)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 直接append</span></span><br><span class="line">    <span class="comment">// b = append(b, &#x27;d&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先修改len，再赋值</span></span><br><span class="line">    <span class="keyword">var</span> bp *<span class="keyword">int</span> = (*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;b)) + unsafe.Sizeof(<span class="number">0</span>)))</span><br><span class="line">    *bp = <span class="number">4</span></span><br><span class="line">    b[<span class="number">3</span>] = <span class="string">&#x27;d&#x27;</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(*str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>abc<br>abcd</p>
</blockquote>
<hr>
<h1 id="string转-byte"><a href="#string转-byte" class="headerlink" title="string转[]byte"></a>string转[]byte</h1><p>同理可以直接转，也可以通过指针转：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="keyword">var</span> b []<span class="keyword">byte</span> = ([]<span class="keyword">byte</span>)(str)</span><br><span class="line">    fmt.Println(b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> buf []<span class="keyword">byte</span> = *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;str))</span><br><span class="line">    fmt.Println(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[97 98 99]<br>[97 98 99]</p>
</blockquote>
<p>注意到通过指针转化得到的[]byte切片是不能进行值得修的，因为str是不可修改的。</p>
<p>这里的buf的cap值是不确定的，因为string结构中只有两个属性，没有cap，有一种<strong>骚操作</strong>来转换：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    xx := *(*[<span class="number">2</span>]<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;str))</span><br><span class="line">    <span class="keyword">var</span> buf []<span class="keyword">byte</span> = *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;[<span class="number">3</span>]<span class="keyword">uintptr</span>&#123;xx[<span class="number">0</span>], xx[<span class="number">1</span>], xx[<span class="number">1</span>]&#125;))</span><br><span class="line">    fmt.Println(buf)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p %d %d\n&quot;</span>, buf, <span class="built_in">len</span>(buf), <span class="built_in">cap</span>(buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[97 98 99]<br>0x4c66e4 3 3</p>
</blockquote>
<p>这里把string当作一个<code>[2]uintptr</code>，通过它新建一个<code>[3]uintptr</code>，这样就得到了一个len和cap都为3的[]byte切片。</p>
<hr>
<h1 id="struct赋值"><a href="#struct赋值" class="headerlink" title="struct赋值"></a>struct赋值</h1><p>例子如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> V <span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="keyword">int32</span></span><br><span class="line">    j <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> v *V = <span class="built_in">new</span>(V)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i *<span class="keyword">int32</span> = (*<span class="keyword">int32</span>)(unsafe.Pointer(v))</span><br><span class="line">    *i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> j *<span class="keyword">int64</span> = (*<span class="keyword">int64</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(v)) + unsafe.Offsetof(v.j)))</span><br><span class="line">    *j = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(*v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>{1 2}</p>
</blockquote>
<p>需要注意到go的struct与c语言一样有<strong>对齐机制</strong>，对于结构体V，它明显是按照<code>int64</code>也就是8字节对齐，
所以上面的代码取j的位置换一种写法也是一样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> j *<span class="keyword">int64</span> = (*<span class="keyword">int64</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(v)) + <span class="keyword">uintptr</span>(<span class="number">8</span>)))</span><br></pre></td></tr></table></figure>
<p>另外struct使用的是一块连续内存，可以看到下面的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> V <span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="keyword">int32</span></span><br><span class="line">    j <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> v *V = <span class="built_in">new</span>(V)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> i *<span class="keyword">int32</span> = (*<span class="keyword">int32</span>)(unsafe.Pointer(v))</span><br><span class="line">    *i = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> k *<span class="keyword">int64</span> = (*<span class="keyword">int64</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(v)) + <span class="keyword">uintptr</span>(<span class="number">4</span>)))</span><br><span class="line">    *k = <span class="number">3</span> &lt;&lt; <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(*v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>{1 3}</p>
</blockquote>
<p>这里的 i，j，k 在内存中的位置是这样的：</p>
<p><img src="/images/golang/unsafe_point-1.png" alt="image" title="i，j，k内存布局"></p>
<p>所以<code>*k = 3 &lt;&lt; 32</code>，这句话相当于把第9个字节变成了<code>1100 0000</code>，需要注意到这里是<strong>小端序</strong>（数据的低字节保存在内存的低地址）。
所以j的值就变成了3。</p>
<hr>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>srs中ffmpeg的按需转码实现方法</title>
    <url>/2019/10/29/2019-10-29-srs_ffmpeg_transcode_as_needed/</url>
    <content><![CDATA[<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>使用srs来进行直播流转码时，如果直接配置了转码，则无论有无客户端在拉取转码流，转码都会进行。
需要注意到，转码是一件<strong>非常消耗CPU资源</strong>的事情，所以实现按需转码（只有在转码流被拉取时，才进行转码）是一件非常值得的事情。</p>
<hr>
<h1 id="srs的FFmpeg转码时的推拉流逻辑"><a href="#srs的FFmpeg转码时的推拉流逻辑" class="headerlink" title="srs的FFmpeg转码时的推拉流逻辑"></a>srs的FFmpeg转码时的推拉流逻辑</h1><p>在srs的vhost中，可以配置transcode来使用FFmpeg对流进行转码。</p>
<p>例如下面配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen              1935;</span><br><span class="line">vhost www.transcode.com &#123;</span><br><span class="line">    transcode &#123;</span><br><span class="line">        enabled     on;</span><br><span class="line">        ffmpeg      .&#x2F;objs&#x2F;ffmpeg&#x2F;bin&#x2F;ffmpeg;</span><br><span class="line">        engine ff &#123;</span><br><span class="line">            enabled         on;</span><br><span class="line">            vcodec          copy;</span><br><span class="line">            acodec          copy;</span><br><span class="line">            output          rtmp:&#x2F;&#x2F;127.0.0.1:[port]&#x2F;[app]?vhost&#x3D;[vhost]&#x2F;[stream]_[engine];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设一路流推送到<code>rtmp://www.transcode.com/testapp/teststream</code>，上面所配置的ffmpeg立即就会对这路流进行转码（即使没有人拉流），
因为它转码的逻辑是<code>拉流到FFmpeg-&gt;转码-&gt;推流到output所定义的地方</code>。</p>
<p>那么上面配置中的写法就表示：</p>
<ol>
<li>从 <code>rtmp://127.0.0.1:1935/testapp?vhost=www.transcode.com/teststream</code> 拉流。</li>
<li>转码。</li>
<li>推流到 <code>rtmp://127.0.0.1:1935/testapp?vhost=www.transcode.com/teststream_ff</code></li>
</ol>
<p>也就是转码后反推了一路流到 <code>www.transcode.com</code>这个vhost下面（由于output可以自定义，所以实际上想推到哪里都可以）。</p>
<p><strong>所以转码一旦开始，就会不断拉流，转码，推流，与有没有人在拉流没有关系，它会持续占用CPU资源。</strong></p>
<hr>
<h1 id="如何实现srs可控的FFmpeg转码"><a href="#如何实现srs可控的FFmpeg转码" class="headerlink" title="如何实现srs可控的FFmpeg转码"></a>如何实现srs可控的FFmpeg转码</h1><p><strong>首先</strong>，如果在一个vhost下同时配置 remote 和 transcode，则会出来不先拉原始流就无法拉取转码流的问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vhost lrm.test.com &#123;</span><br><span class="line">    mode             remote;</span><br><span class="line">    origin           192.168.90.229:2019;</span><br><span class="line">    transcode &#123;</span><br><span class="line">        enabled     on;</span><br><span class="line">        ffmpeg      .&#x2F;objs&#x2F;ffmpeg&#x2F;bin&#x2F;ffmpeg;</span><br><span class="line">        engine ff &#123;</span><br><span class="line">            enabled         on;</span><br><span class="line">            vfilter &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            vcodec          libx264;</span><br><span class="line">            vbitrate        3500;</span><br><span class="line">            vfps            60;</span><br><span class="line">            vwidth          1920;</span><br><span class="line">            vheight         1080;</span><br><span class="line">            vthreads        2;</span><br><span class="line">            vprofile        baseline;</span><br><span class="line">            vpreset         superfast;</span><br><span class="line">            vparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            acodec          libfdk_aac;</span><br><span class="line">            abitrate        45;</span><br><span class="line">            asample_rate    44100;</span><br><span class="line">            achannels       2;</span><br><span class="line">            aparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            output          rtmp:&#x2F;&#x2F;127.0.0.1:[port]&#x2F;[app]?vhost&#x3D;[vhost]&#x2F;[stream]_[engine];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面的配置，如果不先拉取<code>rtmp://lrm.test.com/app/streamname</code>的未转码流，则无法拉取<code>rtmp://lrm.test.com/app/streamname_ff</code>的转码流，
并且只要转码一旦<strong>开始</strong>，就<strong>不会停止</strong>。</p>
<p>所以，如果想要实现可控转码，则只能通过需要转码时，再下发转码配置来实现，只通过srs本身来控制貌似不行。</p>
<p><strong>按需转码实现思路：</strong></p>
<ol>
<li>如何知道有用户拉流：<code>用户拉流触发srs的HTTPCallBack</code> -&gt; <code>开启转码</code>。</li>
<li>如何开启转码：在用于转码的srs节点上<code>下发ingest配置从origin拉取原始流</code> -&gt; <code>进行转码后将转码流推回origin</code>。</li>
</ol>
<p>所以这里的关键在于两点：使用<strong>HTTPCallBack</strong>来获知拉流信息;使用<strong>ingest</strong>来拉取原流进行转码，转码操作不会影响srs集群的任何配置。</p>
<p><strong>ingest配置一：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vhost lrm.test.com &#123;</span><br><span class="line">    ingest livestream &#123;</span><br><span class="line">        enabled      on;</span><br><span class="line">        input &#123;</span><br><span class="line">            type    stream;</span><br><span class="line">            url     rtmp:&#x2F;&#x2F;192.168.90.229:2019&#x2F;persist?vhost&#x3D;lrm.test.com&#x2F;long;</span><br><span class="line">        &#125;</span><br><span class="line">        ffmpeg      .&#x2F;objs&#x2F;ffmpeg&#x2F;bin&#x2F;ffmpeg;</span><br><span class="line">        engine 720_60 &#123;</span><br><span class="line">            enabled         on;</span><br><span class="line">            vfilter &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            vcodec          libx264;</span><br><span class="line">            vbitrate        3500;</span><br><span class="line">            vfps            60;</span><br><span class="line">            vwidth          0;</span><br><span class="line">            vheight         0;</span><br><span class="line">            vthreads        12;</span><br><span class="line">            vprofile        main;</span><br><span class="line">            vpreset         fast;</span><br><span class="line">            vparams &#123;</span><br><span class="line">                   maxrate:v     3500k;</span><br><span class="line">                   minrate:v     3500k;</span><br><span class="line">                   bufsize:v     3500k;</span><br><span class="line">            &#125;</span><br><span class="line">            acodec          libfdk_aac;</span><br><span class="line">            abitrate        50;</span><br><span class="line">            asample_rate    44100;</span><br><span class="line">            achannels       2;</span><br><span class="line">            aparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            output          rtmp:&#x2F;&#x2F;192.168.90.229:2019&#x2F;persist?vhost&#x3D;lrm.test.com&#x2F;long_720_60;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ingest配置二：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vhost lrm.test.com &#123;</span><br><span class="line">    ingest livestream &#123;</span><br><span class="line">        enabled      on;</span><br><span class="line">        input &#123;</span><br><span class="line">            type    stream;</span><br><span class="line">            url     rtmp:&#x2F;&#x2F;192.168.90.229:2019&#x2F;persist?vhost&#x3D;lrm.test.com&#x2F;long;</span><br><span class="line">        &#125;</span><br><span class="line">        ffmpeg      .&#x2F;objs&#x2F;ffmpeg&#x2F;bin&#x2F;ffmpeg;</span><br><span class="line">        engine 1 &#123;</span><br><span class="line">            enabled         off;</span><br><span class="line">            output          rtmp:&#x2F;&#x2F;127.0.0.1:2019&#x2F;persist?vhost&#x3D;www.transcode.com&#x2F;long;</span><br><span class="line">        &#125;</span><br><span class="line">	    engine 2 &#123;</span><br><span class="line">	    enabled         off;</span><br><span class="line">            output          rtmp:&#x2F;&#x2F;127.0.0.1:2019&#x2F;persist?vhost&#x3D;www.transcode2.com&#x2F;long;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vhost www.transcode.com &#123;</span><br><span class="line">    transcode &#123;</span><br><span class="line">    	enabled      off;</span><br><span class="line">	    ffmpeg      .&#x2F;objs&#x2F;ffmpeg&#x2F;bin&#x2F;ffmpeg;</span><br><span class="line">        engine 720_60 &#123;</span><br><span class="line">            enabled         on;</span><br><span class="line">            vfilter &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            vcodec          libx264;</span><br><span class="line">            vbitrate        3500;</span><br><span class="line">            vfps            60;</span><br><span class="line">            vwidth          0;</span><br><span class="line">            vheight         0;</span><br><span class="line">            vthreads        12;</span><br><span class="line">            vprofile        main;</span><br><span class="line">            vpreset         fast;</span><br><span class="line">            vparams &#123;</span><br><span class="line">		maxrate:v     3500k;</span><br><span class="line">		minrate:v     3500k;</span><br><span class="line">                bufsize:v     3500k;</span><br><span class="line">            &#125;</span><br><span class="line">            acodec          libfdk_aac;</span><br><span class="line">            abitrate        50;</span><br><span class="line">            asample_rate    44100;</span><br><span class="line">            achannels       2;</span><br><span class="line">            aparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            output          rtmp:&#x2F;&#x2F;192.168.90.229:2019&#x2F;persist?vhost&#x3D;lrm.test.com&#x2F;long_720_60;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vhost www.transcode2.com &#123;</span><br><span class="line">    transcode &#123;</span><br><span class="line">        enabled      on;</span><br><span class="line">        ffmpeg      .&#x2F;objs&#x2F;ffmpeg&#x2F;bin&#x2F;ffmpeg;</span><br><span class="line">        engine 720_60_1 &#123;</span><br><span class="line">            enabled         on;</span><br><span class="line">            vfilter &#123;</span><br><span class="line">                filter_complex  &#39;scale&#x3D;1280:-1&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            vcodec          libx264;</span><br><span class="line">            vbitrate        3500;</span><br><span class="line">            vfps            60;</span><br><span class="line">            vwidth          0;</span><br><span class="line">            vheight         0;</span><br><span class="line">            vthreads        12;</span><br><span class="line">            vprofile        main;</span><br><span class="line">            vpreset         fast;</span><br><span class="line">            vparams &#123;</span><br><span class="line">                maxrate:v     3500k;</span><br><span class="line">                minrate:v     3500k;</span><br><span class="line">                bufsize:v     3500k;</span><br><span class="line">            &#125;</span><br><span class="line">            acodec          libfdk_aac;</span><br><span class="line">            abitrate        50;</span><br><span class="line">            asample_rate    44100;</span><br><span class="line">            achannels       2;</span><br><span class="line">            aparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            output          rtmp:&#x2F;&#x2F;192.168.90.229:2019&#x2F;persist?vhost&#x3D;lrm.test.com&#x2F;long_720_60_1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然两种方式其实可以达到一样的效果（方式一中也可以添加多个engine），哪种方便用哪一种。</p>
<hr>
]]></content>
      <categories>
        <category>live</category>
      </categories>
      <tags>
        <tag>live</tag>
        <tag>srs</tag>
      </tags>
  </entry>
  <entry>
    <title>golang通过CMD来调用FFmpeg</title>
    <url>/2019/11/12/2019-11-12-golang_cmd_ffmpeg/</url>
    <content><![CDATA[<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在golang中调用FFmpeg，一种方法是使用cgo来使用FFmpeg，这样就可以在go程序里面编写转码语句，进行错误处理等，
但是这样的方法貌似有点复杂，或许得不偿失。</p>
<p>这里使用CMD来直接调用FFmpeg进行转码，在使用较多的复杂参数的情况下，可能反而简单许多。</p>
<hr>
<h1 id="使用记录"><a href="#使用记录" class="headerlink" title="使用记录"></a>使用记录</h1><p><strong>调用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd :&#x3D; exec.Command(&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, param)</span><br><span class="line">cmd.SysProcAttr &#x3D; &amp;syscall.SysProcAttr&#123;Setpgid: true&#125;</span><br><span class="line">cmd.start()</span><br></pre></td></tr></table></figure>
<p>这里的<code>param</code>就是整个FFmpeg转码语句，例如<code>/usr/bin/ffmpeg -i 1.mp4 1.flv</code>。</p>
<p>这里使用<code>Setpgid</code>来设置进程组pid，这样在后面kill时直接杀掉整个进程组，无残留。</p>
<p>另外<code>cmd.start()</code>表示非阻塞，转码开始后就放在后台（因为直播相关，所以会一直转码），等待结束命令。</p>
<p><strong>转码日志记录：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stdout, err :&#x3D; os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY, 0644)</span><br><span class="line">cmd.Stderr &#x3D; stdout</span><br></pre></td></tr></table></figure>
<p>注意ffmpeg使用的日志输出是<strong>Stderr</strong>，<strong>err</strong>…</p>
<p><strong>停止：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">err :&#x3D; syscall.Kill(-cmd.Process.Pid, syscall.SIGKILL)</span><br></pre></td></tr></table></figure>
<p>加上一个负号，直接杀掉整个进程组。</p>
<p><strong>PS：一定要在kill之后调用<code>cmd.Wait()</code>，否则会变成僵尸进程。</strong></p>
<hr>
<p><strong>完整代码：</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Exec</span><span class="params">(param, logFile <span class="keyword">string</span>)</span> <span class="params">(*exec.Cmd, error)</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, param)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;Setpgid: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">	logOut, err := os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY, <span class="number">0644</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将标准输出和标准错误都写到log中</span></span><br><span class="line">	cmd.Stdout = logOut</span><br><span class="line">	cmd.Stderr = logOut</span><br><span class="line"></span><br><span class="line">	log.Info(<span class="string">&quot;Exce cmd: %s&quot;</span>, param)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		_ = logOut.Close()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">KillCmd</span><span class="params">(cmd *exec.Cmd)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> cmd == <span class="literal">nil</span> || cmd.Process == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;process not found or already stopped&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Info(<span class="string">&quot;Kill CMD. pid: %d&quot;</span>, cmd.Process.Pid)</span><br><span class="line"></span><br><span class="line">	err := syscall.Kill(-cmd.Process.Pid, syscall.SIGKILL)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不wait，则会产生僵尸进程</span></span><br><span class="line">	<span class="keyword">go</span> cmd.Wait() <span class="comment">// 为了不阻塞，另外起一个线程去Wait</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="2019-12-30修改记录"><a href="#2019-12-30修改记录" class="headerlink" title="2019-12-30修改记录"></a>2019-12-30修改记录</h1><p>实际使用的时候发现出现了defunct进程，也就是僵尸进程，重新看了一下<code>cmd.Start()</code>的使用方法，
发现自己没有调用<code>cmd.Wait()</code>。</p>
<hr>
<h1 id="2020-01-20修改记录"><a href="#2020-01-20修改记录" class="headerlink" title="2020-01-20修改记录"></a>2020-01-20修改记录</h1><p>最近在使用FFmpeg来将rtmp流录制成ts文件，发现了一系列问题：</p>
<ul>
<li>首先，在FFmpeg进程运行过程中，如果使用<strong>SIGKILL</strong>（也就是-9信号）来将其杀死，那么这就相当于FFmpeg异常结束，它在结束时不会进行任何后处理。
那么FFmpeg所录制的最后一片ts（由于只录制了一部分，没有达到设置的ts时长），就不能得到正确的处理，m3u8文件中也不会对他进行记录。
这里正确的做法是使用<strong>SIGTERM</strong>信号（或者SIGINT）来使FFmpeg进程停止，FFmpeg收到这个信号，会将最后一片时长不足的ts片也保存下来，并写进m3u8文件中。</li>
<li>第二，在拉取rtmp流的时候，我是先停止rtmp流，然后再发送<strong>SIGTERM</strong>信号给FFmpeg，但是我发现<strong>FFmpeg进程并没有结束！</strong>这个问题困扰了很久，
终于在一瞬间想到了，原来是FFmpeg因为拉不到新数据而阻塞了！所以连信号都接收不到了！为了让FFmpeg不会无限阻塞，可以设置一个<code>rw_timeout</code>参数，
来让FFmpeg阻塞一段时间后超时，从而接收到信号。</li>
</ul>
<p>所以这里总结一下就是：1.使用SIGTERM信号来使得FFmpeg正常结束。2.使用<code>rw_timeout</code>参数来防止FFmpeg无限阻塞。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/1f3ec2f00b03">Go语言中Kill子进程的正确姿势</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>live</tag>
        <tag>golang</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>使用FFmpeg来进行固定时间间隔截图（rtmp直播流）</title>
    <url>/2019/12/19/2019-11-27-ffmpeg-screenshot/</url>
    <content><![CDATA[<hr>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><strong>如何对一个直播流不停的进行截图？</strong></p>
<p>对直播流进行截图是一件十分平常的事情，因为实际中需要通过截图来对视频内容进行审核。</p>
<p>一个简单的需求就是每隔一个固定时间间隔来从直播流中截取一张图片（jpeg或者png）。</p>
<p>这里总结一下如何使用FFmpeg工具来完成这件事。有两种使用方法，简单的就是直接通过CMD来调用FFmpeg进行截图，
复杂的就是用C语言来调用FFmpeg。</p>
<ul>
<li>使用CMD调用FFmpeg：简单，稳定，但是低效。</li>
<li>使用C语言调用FFmpeg：复杂，但是非常高效。</li>
</ul>
<hr>
<h1 id="使用CMD调用FFmpeg来截图"><a href="#使用CMD调用FFmpeg来截图" class="headerlink" title="使用CMD调用FFmpeg来截图"></a>使用CMD调用FFmpeg来截图</h1><hr>
<h2 id="在固定时间点的截取一张图"><a href="#在固定时间点的截取一张图" class="headerlink" title="在固定时间点的截取一张图"></a>在固定时间点的截取一张图</h2><p>先来最简单的，如何截取一个视频流的第一张图：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://192.168.90.43:2019/live/long -frames:v 1 ./snap/1.png</span></span><br></pre></td></tr></table></figure>
<p>这里直接使用<code>-frames:v 1</code>参数就可以完成，截图一张图片后，便会结束。</p>
<p>考虑在一个时间节点截取一张图：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -ss 00:00:10 -i .\1080_60.flv -frames:v 1 ./snap/1.png</span></span><br></pre></td></tr></table></figure>
<p>增加<code>-ss 00:00:10</code>参数，这里截取10秒处的一张图。</p>
<hr>
<h2 id="建立for循环来达到固定时间间隔截图"><a href="#建立for循环来达到固定时间间隔截图" class="headerlink" title="建立for循环来达到固定时间间隔截图"></a>建立for循环来达到固定时间间隔截图</h2><p>那么为了简单的达到固定时间间隔截图，可以使用for循环来完成，隔一段时间截一单张图：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for((;;)); do \</span><br><span class="line">    ffmpeg -i rtmp://192.168.90.43:2019/live/long -strftime 1 -frames:v 1 ./snap/%H-%M-%S.png \</span><br><span class="line">    sleep 10; \</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>这个方法十分简单，但是问题在于每次都要拉一次流，创建一次连接，虽然也不占多少CPU，但是感觉有毒。</p>
<hr>
<h2 id="使用帧率控制来达到固定时间间隔截取一张图"><a href="#使用帧率控制来达到固定时间间隔截取一张图" class="headerlink" title="使用帧率控制来达到固定时间间隔截取一张图"></a>使用帧率控制来达到固定时间间隔截取一张图</h2><p>一条命令完成，可以通过控制帧率来达到，将帧率设置在<code>0.1</code>，也就是每10秒1帧：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://192.168.90.43:2019/live/long -vf fps=0.1 ./snap/%00d.png</span></span><br></pre></td></tr></table></figure>
<p>如果想要调整图片分辨率可以同时<code>scale</code>来完成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i rtmp://192.168.90.43:2019/live/long \</span></span><br><span class="line"><span class="bash">    -filter_complex <span class="string">&quot;[0:v]fps=0.1[a];[a]scale=-1:720[out]&quot;</span> -map <span class="string">&quot;[out]&quot;</span> -an ./snap/%00d.png</span></span><br></pre></td></tr></table></figure>
<p>这样的方法的确可以达到固定时间间隔截图，但是问题在于FFmpeg会一直进行解码，CPU占用很高，且非常没有必要。</p>
<p><strong>另外还有通过<code>Select</code>滤镜来选择frame来进行截图，但是实际上不仅很难用，而且也会持续解码，占用CPU。</strong></p>
<hr>
<h2 id="（曲线救国）先保存成TS文件，再从TS文件上截图"><a href="#（曲线救国）先保存成TS文件，再从TS文件上截图" class="headerlink" title="（曲线救国）先保存成TS文件，再从TS文件上截图"></a>（曲线救国）先保存成TS文件，再从TS文件上截图</h2><p>上面的方法中，使用for循环来截图相对来说是最健康的，因为它基本不占啥CPU，但是每次重新创建远程连接也挺耗资源的。</p>
<p>那么可以先通过一个FFmpeg进程来拉取流，并保存成为本地的TS文件，然后再进行for循环来对TS文件进行截图，
这样就能免得每次创建远程连接。</p>
<p>下面是一个简单的Shell脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">input=&quot;&quot;</span><br><span class="line">interval=5</span><br><span class="line">outdir=&quot;./screens&quot;</span><br><span class="line">segmdir=&quot;tmp&quot;</span><br><span class="line">height=-1</span><br><span class="line">outfmt=&quot;jpg&quot;</span><br><span class="line">invalid=false</span><br><span class="line"></span><br><span class="line">while getopts &quot;:i:t:d:h:f:&quot; opt</span><br><span class="line">do</span><br><span class="line">    case $opt in</span><br><span class="line">        i)</span><br><span class="line">        input=$OPTARG</span><br><span class="line">        ;;</span><br><span class="line">        t)</span><br><span class="line">        interval=$OPTARG</span><br><span class="line">        ;;</span><br><span class="line">        d)</span><br><span class="line">        outdir=$OPTARG</span><br><span class="line">        ;;</span><br><span class="line">        h)</span><br><span class="line">        height=$OPTARG</span><br><span class="line">        ;;</span><br><span class="line">        f)</span><br><span class="line">        outfmt=$OPTARG</span><br><span class="line">        ;;</span><br><span class="line">        ?)</span><br><span class="line">        invalid=true</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">if [ &quot;$input&quot; == &quot;&quot; ] ; then invalid=true ; fi</span><br><span class="line"></span><br><span class="line">if [[ &quot;$outfmt&quot; != &quot;jpg&quot; &amp;&amp; &quot;$outfmt&quot; != &quot;png&quot; ]] ; then invalid=true ; fi</span><br><span class="line"></span><br><span class="line">if [ $invalid == true ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;Invalid input&quot; </span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;input = $input&quot;</span><br><span class="line">echo &quot;interval = $interval&quot;</span><br><span class="line">echo &quot;outdir = $outdir&quot;</span><br><span class="line">echo &quot;screen fmt = $outfmt&quot;</span><br><span class="line">echo &quot;screenshot height = $height&quot;</span><br><span class="line"></span><br><span class="line">if [ ! -d &quot;$outdir&quot; ] ; then mkdir -p $outdir ; fi</span><br><span class="line">segmdir=&quot;$outdir/$segmdir&quot;</span><br><span class="line">if [ ! -d &quot;$segmdir&quot; ] ; then mkdir -p $segmdir ; fi</span><br><span class="line"></span><br><span class="line">trap &quot; echo &quot;&quot; ; echo &quot;exit...&quot; ; rm -r $segmdir ; exit &quot; SIGHUP SIGINT SIGQUIT</span><br><span class="line"></span><br><span class="line">ffmpeg -i $input -f segment -segment_list $segmdir/list \</span><br><span class="line">       -segment_list_size 3 -segment_time $interval -segment_wrap 3 \</span><br><span class="line">       -codec copy $segmdir/%01d.mp4 \</span><br><span class="line">       &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">sleep `expr $interval / 2`</span><br><span class="line"></span><br><span class="line">idx=1</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    seg=`cat $segmdir/list | awk &#x27;END &#123;print&#125;&#x27;`</span><br><span class="line">    if [ &quot;$seg&quot; != &quot;&quot; ]</span><br><span class="line">    then</span><br><span class="line">	echo &quot;$seg $idx.$outfmt&quot;</span><br><span class="line">        if [ &quot;$outfmt&quot; == &quot;png&quot; ] ; then</span><br><span class="line">            ffmpeg -i $segmdir/$seg -vf &quot;scale=-1:$height&quot; -c:v png -an -frames:v 1 -y $outdir/$idx.$outfmt &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">        elif [ &quot;$outfmt&quot; == &quot;jpg&quot; ] ; then </span><br><span class="line">            ffmpeg -i $segmdir/$seg -vf &quot;scale=-1:$height&quot; -f image2 -q:v 2 -an -frames:v 1 -y $outdir/$idx.$outfmt &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">        fi</span><br><span class="line">        let idx++</span><br><span class="line">    fi</span><br><span class="line">    sleep $interval</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个方法虽然每次都要重新开启线程，关闭线程，而且还相当于在进行录制，但是基本避免了最大的开销（解码，建立远程连接）。</p>
<hr>
<h1 id="使用C语言调用FFmpeg"><a href="#使用C语言调用FFmpeg" class="headerlink" title="使用C语言调用FFmpeg"></a>使用C语言调用FFmpeg</h1><p>很明显，上面的方法虽然进化得越来越好，但是始终是不完美的。</p>
<p>要想达到完美，看来只能通过C语言来调用FFmpeg，这样就能将整个编解码过程控制在自己手里。</p>
<p><a href="http://longrm.com/2019/12/23/2019-12-23-ffmpeg-screenshot-2/">使用C语言调用FFmpeg来进行固定时间间隔截图(rtmp直播流)</a></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ffmpeg.org/documentation.html">FFmpeg Documentation</a></p>
]]></content>
      <categories>
        <category>media</category>
      </categories>
      <tags>
        <tag>live</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>cgo+ffmpeg+windows的简单使用</title>
    <url>/2020/06/02/2020-06-02-cgo+ffmpeg+windows/</url>
    <content><![CDATA[<hr>
<h1 id="cgo-ffmpeg-windows的简单使用"><a href="#cgo-ffmpeg-windows的简单使用" class="headerlink" title="cgo+ffmpeg+windows的简单使用"></a>cgo+ffmpeg+windows的简单使用</h1><p>最近想试试用go来直接调用ffmpeg是什么效果，但是第一步编译就花费了一点时间，这里记录一下这个过程。</p>
<hr>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>首先需要有c的编译环境，这个直接去安装一个<strong>64位的MinGW</strong>就可以了。</p>
<p>然后就是ffmpeg的编译环境配置，这个网上可以看到各个各样的说法，这里找了一个最简单明确的方法：</p>
<ol>
<li>首先去<a href="https://ffmpeg.zeranoe.com/builds/">ffmpeg官网</a>下载一个dev版本的ffmpeg和一个share版本的ffmpeg。</li>
<li>将dev版本解压到某个路径下，例如这里解压到<code>D:/ffmpeg/</code>下面。这个路径下应该有<code>D:/ffmpeg/lib</code>和<code>D:/ffmpeg/include</code>。</li>
<li>将share版本的bin文件夹解压到某个路径下，这里为了方便放在<code>D:/ffmpeg/bin</code>下面。</li>
</ol>
<p>到这里其实就完成了配置，需要的其实就是ffmpeg的<strong>静态链接库</strong>和<strong>动态链接库</strong>：</p>
<ul>
<li><code>D:/ffmpeg/include</code>下面放的只是头文件。</li>
<li><code>D:/ffmpeg/lib</code>就是静态链接库，但是里面没有代码，起的链接作用，可以帮助完成编译。</li>
<li><code>D:/ffmpeg/bin</code>下面的<strong>dll文件</strong>则是动态链接库，是代码真正的所在，运行程序必需要有，但是编译时则不需要。</li>
</ul>
<p>所以在<strong>编译</strong>代码时，需要指定<strong>include</strong>和<strong>lib</strong>的位置，需要在go的代码中指定；在<strong>运行</strong>代码时，要在运行环境中能够找到相关的<strong>dll</strong>文件，则需要在windows环境变量中配置。</p>
<hr>
<p>在cgo的代码的<strong>头部注释</strong>中加入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#cgo CFLAGS: -ID:/ffmpeg/include</span></span><br><span class="line"><span class="comment">#cgo LDFLAGS: -LD:/ffmpeg/lib/ -llibavformat  -llibavcodec -llibavutil -llibavdevice -llibavfilter -llibswresample -llibswscale</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>D:/ffmpeg/include</code>和<code>D:/ffmpeg/lib/</code>就指定了头文件和静态链接库的位置。</p>
<p>然后需要在系统环境变量的<strong>path</strong>中加入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:/ffmpeg/bin</span><br></pre></td></tr></table></figure>
<p>这样就完成了编译+运行的环境配置。</p>
<hr>
<h2 id="简单代码测试"><a href="#简单代码测试" class="headerlink" title="简单代码测试"></a>简单代码测试</h2><p>这里使用goland来编译运行代码，如下图：</p>
<p><img src="/images/golang/cgo-goland-project.png" alt="image" title="工程目录"></p>
<p>这里代码都放在了<code>333</code>这个目录。</p>
<p>其中<code>main.go</code>内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 引用的C头文件需要在注释中声明，紧接着注释需要有import &quot;C&quot;，且这一行和注释之间不能有空格</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#cgo CFLAGS: -ID:/ffmpeg/include</span></span><br><span class="line"><span class="comment">#cgo LDFLAGS: -LD:/ffmpeg/lib/ -llibavformat  -llibavcodec -llibavutil -llibavdevice -llibavfilter -llibswresample -llibswscale</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &quot;FTest.h&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;please use like this: \n$ %s &lt;inputUrl&gt; &lt;outputUrl&gt;\n&quot;</span>, os.Args[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用C.CString创建的字符串需要手动释放。</span></span><br><span class="line">    inputUrl := <span class="string">&quot;rtmp://xxx.cn/xxx/xxx&quot;</span></span><br><span class="line">    outputUrl1 := <span class="string">&quot;aaa&quot;</span></span><br><span class="line">    outputUrl2 := <span class="string">&quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> SnapShotGo(inputUrl, outputUrl1)</span><br><span class="line">    <span class="keyword">go</span> SnapShotGo(inputUrl, outputUrl2)</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second*<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SnapShotGo</span><span class="params">(inputUrl, outputUrl <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用C.CString创建的字符串需要手动释放。</span></span><br><span class="line">    inputUrlC := C.CString(inputUrl)</span><br><span class="line">    outputUrlC := C.CString(outputUrl)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> C.free(unsafe.Pointer(inputUrlC))</span><br><span class="line">    <span class="keyword">defer</span> C.free(unsafe.Pointer(outputUrlC))</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ret := C.SnapShotRun(inputUrlC, outputUrlC)</span><br><span class="line">    fmt.Println(<span class="string">&quot;ret = &quot;</span>, ret)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是一个简单的测试程序，通过调用c的<code>SnapShotRun</code>函数来对rtmp直播流进行截图，并且同一时间运行了两个go程。</p>
<p>使用目录的方式进行编译运行：</p>
<p><img src="/images/golang/project-build-config.png" alt="image" title="build配置"></p>
<p>成功运行代码：</p>
<p><img src="/images/golang/project-run-success.png" alt="image" title="运行成功"></p>
<hr>
<p>但是这里有一个小问题，c代码中的打印在goland中不能实时显示，只有在结束程序的时候才会一瞬间全部打印出来，但是如果把编译得到可执行程序放到cmd执行就不会出现这个问题。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/zdsoft1/article/details/82454505">golang直接调用ffmpeg预编译类库(windows)的配置方法</a></p>
<p><a href="http://yangxikun.com/golang/2018/03/09/golang-cgo.html?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com">golang cgo 开发小结</a></p>
<p><a href="https://www.cnblogs.com/tobycnblogs/p/9977944.html">golang cgo 使用总结</a></p>
]]></content>
      <categories>
        <category>media</category>
      </categories>
      <tags>
        <tag>live</tag>
        <tag>golang</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>cgo+ffmpeg+linux的简单使用</title>
    <url>/2020/08/20/2020-08-20-cgo+ffmpeg+linux/</url>
    <content><![CDATA[<hr>
<h1 id="cgo-ffmpeg-linux的简单使用"><a href="#cgo-ffmpeg-linux的简单使用" class="headerlink" title="cgo+ffmpeg+linux的简单使用"></a>cgo+ffmpeg+linux的简单使用</h1><p><a href="http://longrm.com/2020/06/02/2020-06-02-cgo+ffmpeg+windows/">cgo+ffmpeg+windows的简单使用</a></p>
<p>上面一篇说了如何在windows搭建开发环境，这一篇讨论一下linux的情况。</p>
<hr>
<h1 id="环境所需"><a href="#环境所需" class="headerlink" title="环境所需"></a>环境所需</h1><p>和windows一样，在linux上面编译运行ffmpeg程序，一样需要ffmpeg静态库和动态库。</p>
<p>所以需要在linux上去编译ffmpeg（带动态库的）。</p>
<p>另外，为了支持x264，先去编译一个x264。</p>
<hr>
<h2 id="x264编译"><a href="#x264编译" class="headerlink" title="x264编译"></a>x264编译</h2><p>先去下载一个x264的编译器<a href="http://www.videolan.org/developers/x264.html">http://www.videolan.org/developers/x264.html</a>，</p>
<p>使用下面命令编译（<code>make install</code>需要sudo权限）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --enable-static --enable-shared </span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>如果提示没有<code>yasm</code>，则装一个就行。</p>
<hr>
<h2 id="ffmpeg编译"><a href="#ffmpeg编译" class="headerlink" title="ffmpeg编译"></a>ffmpeg编译</h2><p>[<a href="https://ffmpeg.org/download.html#releases]https://ffmpeg.org/download.html#releases">https://ffmpeg.org/download.html#releases]https://ffmpeg.org/download.html#releases</a></p>
<p>去ffmpeg官网下载一个自己需要版本的ffmpeg，我这里下载的4.3.1。</p>
<p>这里编译成动态库：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure  --enable-shared --disable-static --enable-libx264 --enable-gpl --extra-cflags=-I/usr/local/include --extra-ldflags=-L/usr/local/lib  --enable-pthreads</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></h2><h2 id="添加一下动态链接库"><a href="#添加一下动态链接库" class="headerlink" title="添加一下动态链接库"></a>添加一下动态链接库</h2><p>去<code>/etc/ld.so.conf.d/</code>下面创建一个新文件，把ffmpeg动态链接库路径加进去就行。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/ld.so.conf.d/ffmpeg-4.3.1.conf</span><br><span class="line"></span><br><span class="line">cat /etc/ld.so.conf.d/ffmpeg-4.3.1.conf</span><br><span class="line">/usr/local/lib</span><br><span class="line"></span><br><span class="line">// 执行</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure></h2><h1 id="cgo编译"><a href="#cgo编译" class="headerlink" title="cgo编译"></a>cgo编译</h1><p>可以将go代码中改为如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#cgo windows CFLAGS: -ID:/ffmpeg/include</span></span><br><span class="line"><span class="comment">#cgo windows LDFLAGS: -LD:/ffmpeg/lib -llibavformat  -llibavcodec -llibavutil -llibavdevice -llibavfilter -llibswresample -llibswscale</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#cgo linux CFLAGS: -I/usr/local/include</span></span><br><span class="line"><span class="comment">#cgo linux LDFLAGS: -L/usr/local/lib -lavformat  -lavcodec -lavutil -lavdevice -lavfilter -lswresample -lswscale</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &quot;snapshot-v3.h&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在其中加入windows和linux，编译时会自动对环境进行识别。</p>
<p>直接在项目文件夹下面执行<code>go build</code>即可。</p>
<hr>
<h1 id="纯c代码编译"><a href="#纯c代码编译" class="headerlink" title="纯c代码编译"></a>纯c代码编译</h1><p>有可能需要调试代码，这时候可能只想编译一些纯c的测试文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc snapshot-v2.c -o snapshot -I/usr/local/include -L/usr/local/lib -lavformat  -lavcodec -lavutil -lavdevice -lavfilter -lswresample -lswscale</span><br></pre></td></tr></table></figure>
<p>也可以把这句话放到makefile里面，以后每次编译直接make：</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat makefile</span><br><span class="line"></span><br><span class="line">snapshot: snapshot-v2.c</span><br><span class="line">	gcc snapshot-v2.c -o snapshot -I&#x2F;usr&#x2F;local&#x2F;include -L&#x2F;usr&#x2F;local&#x2F;lib -lavformat  -lavcodec -lavutil -lavdevice -lavfilter -lswresample -lswscale</span><br></pre></td></tr></table></figure></h2>]]></content>
      <categories>
        <category>media</category>
      </categories>
      <tags>
        <tag>live</tag>
        <tag>golang</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>中国城市之间的球面距离计算</title>
    <url>/2020/07/27/2020-07-27-china-citys-distance/</url>
    <content><![CDATA[<hr>
<h2 id="经纬度数据"><a href="#经纬度数据" class="headerlink" title="经纬度数据"></a>经纬度数据</h2><p>很明显，要就算城市之间的球面距离，那就需要确定各个城市在地球上所处的位置，也就是经纬度。</p>
<p>这里最简单的方式就是去<strong>百度地图开放平台</strong>里面去下载一份<code>百度地图城市名称-中心点经纬度（cityCenter）关系对照文本</code>，</p>
<p><a href="http://lbsyun.baidu.com/index.php?title=open/dev-res">http://lbsyun.baidu.com/index.php?title=open/dev-res</a></p>
<p>这里面应该包含了中国绝大部分城市的经纬度数据，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;municipalities:[&#123;n:&quot;北京&quot;,g:&quot;116.395645,39.929986|12&quot;&#125;,</span><br><span class="line">&#123;n:&quot;上海&quot;,g:&quot;121.487899,31.249162|12&quot;&#125;,</span><br><span class="line">&#123;n:&quot;天津&quot;,g:&quot;117.210813,39.14393|12&quot;&#125;,</span><br><span class="line">&#123;n:&quot;重庆&quot;,g:&quot;106.530635,29.544606|12&quot;&#125;],</span><br><span class="line">provinces:[&#123;n:&quot;安徽&quot;,g:&quot;117.216005,31.859252|8&quot;,</span><br><span class="line">cities:[&#123;n:&quot;合肥&quot;,g:&quot;117.282699,31.866942|12&quot;&#125;,</span><br><span class="line">&#123;n:&quot;安庆&quot;,g:&quot;117.058739,30.537898|13&quot;&#125;,</span><br><span class="line">&#123;n:&quot;蚌埠&quot;,g:&quot;117.35708,32.929499|13&quot;&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>长得跟json差不多，但是又不是json，因为这里所有键值都没有加上引号<code>&quot;</code>，为了方便解析，
可以直接使用文本编辑器来把这些键值替换为带有引号的形式。</p>
<p>解析后，将每个所有城市的经纬度解析出来，重新格式化为json，得到如下文件：</p>
<div>
<a href="/images/files/CityDistance/ChinaCityCoordinate.json">ChinaCityCoordinate.json（39.2 KB）</a>
</div>

<hr>
<h2 id="城市间距离计算"><a href="#城市间距离计算" class="headerlink" title="城市间距离计算"></a>城市间距离计算</h2><p>球面距离有很多种计算方法，这里就不考虑地球实际是个椭圆体的问题了，直接使用<strong>Haversine</strong>算法比较简单。</p>
<p>这里也是参考网上别人写的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Haversine 算法：通过两地经纬度计算两地的球面距离（正球体，非椭圆）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EarthRadius <span class="keyword">float64</span> = <span class="number">6371.0</span> <span class="comment">//km 地球半径 平均值，千米</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DegToRadians</span><span class="params">(degrees <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (degrees * math.Pi) / <span class="number">180</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDistanceFromLatLonInKm</span><span class="params">(lat1, lon1, lat2, lon2 <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dLat = DegToRadians(lat2-lat1)</span><br><span class="line">    <span class="keyword">var</span> dLon = DegToRadians(lon2-lon1)</span><br><span class="line">    <span class="keyword">var</span> a = math.Sin(dLat/<span class="number">2</span>) * math.Sin(dLat/<span class="number">2</span>) + math.Cos(DegToRadians(lat1)) * math.Cos(DegToRadians(lat2)) *</span><br><span class="line">            math.Sin(dLon/<span class="number">2</span>) * math.Sin(dLon/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c = math.Atan2(math.Sqrt(a), math.Sqrt(<span class="number">1</span>-a))</span><br><span class="line">    <span class="keyword">var</span> d = <span class="number">2</span> * EarthRadius * c</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样简单的两两计算，就可以得到中国各个城市之间的距离：</p>
<div>
<a href="/images/files/CityDistance/CityDisMatrix.json">CityDisMatrix.json（4.73MB）</a>
</div>


<p>在实际使用的情况中，如果不想浪费内存，可以考虑使用坐标实时计算，浪费点CPU。</p>
<hr>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>cgo+ffmpeg+截图 的简单尝试</title>
    <url>/2020/08/26/2020-08-26-cgo+ffmpeg+snapshot/</url>
    <content><![CDATA[<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>首先这里的截图是针对视频流而言的，通常是rtmp的流。</p>
<p>命令行截图：<a href="http://longrm.com/2019/12/19/2019-11-27-ffmpeg-screenshot/">使用FFmpeg来进行固定时间间隔截图（rtmp直播流）</a></p>
<p>一般情况下，会通过go代码调用命令行（CMD）来使用ffmpeg进行截图，但是这样的问题在于每一个截图任务都是一个<strong>独立的进程</strong>，
如果要同时对几千路流进行截图，那么<strong>进程间的开销</strong>会直接占用大半的CPU资源。</p>
<p>使用命令行调用ffmpeg的另一个问题在于，由于是另外一个独立的进程在进行截图，所以go程序无法直接知道截图的情况，整个截图过程都是<strong>异步</strong>的。
go程序无法知道什么时候ffmpeg完成了一张截图。简单的方法只能定期扫描ffmpeg产生的list文件来判断是否有新的截图产生，就挺恶心的。</p>
<p><strong>使用<code>cgo+ffmpeg+截图</code>的方式来解决上述问题，做到以下几点</strong>：</p>
<ol>
<li>每一个截图任务都运行在一个<strong>go程</strong>中，而不是进程。</li>
<li>一张截图完成时，可以直接进行回调。</li>
<li>可以实时控制截图任务的开始和结束。</li>
<li>go代码与c代码使用同一个日志打印函数，日志将用同样的格式打印到同样的地方。</li>
<li>单个截图任务的CPU消耗基本与直接命令行截图相同。</li>
</ol>
<p>这样的方式也会有一定<strong>坏处</strong>：</p>
<ol>
<li>会增加一定CPU开销。go与c之间的函数调用还是会带来一定额外开销的。</li>
<li>一个截图任务发生panic，如果不处理，会导致整个程序崩溃。</li>
</ol>
<hr>
<h1 id="如何调用c函数来进行截图"><a href="#如何调用c函数来进行截图" class="headerlink" title="如何调用c函数来进行截图"></a>如何调用c函数来进行截图</h1><p><strong>首先，c没有类的概念，都是基于结构体和函数调用。</strong></p>
<p>这里尝试了<strong>两种路线</strong>来调用c函数进行截图：</p>
<hr>
<p><strong>路线1：</strong></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CSnapshot <span class="keyword">struct</span> &#123;</span><br><span class="line">	pToCStruct *C.SnapShot <span class="comment">// 指向 c 结构体的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCSnapshot</span><span class="params">()</span> *<span class="title">CSnapshot</span></span> &#123;</span><br><span class="line">	cs.pToCStruct = C.InitSnapshotStruct()</span><br><span class="line">    <span class="keyword">return</span> cs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始截图</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *CSnapshot)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	C.SnapShotStructRun(cs.pToCStruct)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止截图</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *CSnapshot)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	C.SnapShotStructStop(cs.pToCStruct)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先进行结构体初始化，得到一个结构体指针，然后将指针传入<code>Run</code>或<code>Stop</code>函数来控制截图任务的开始与结束。</p>
<hr>
<p><strong>路线2：</strong></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *CSnapshot)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	taskIdC := C.CString(cs.taskId)</span><br><span class="line">	ret := C.SnapShotStructRun(taskIdC) <span class="comment">// 阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *CSnapshot)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	taskIdC := C.CString(cs.taskId)</span><br><span class="line">	C.StopTaskForGo(taskIdC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用<code>Run</code>函数运行截图任务，传入一个taskId对任务进行标识，且这个函数会阻塞。
传入taskId到<code>Stop</code>函数来停止任务。</p>
<p>这个过程中，go内存中并不保存任何c中的变量。</p>
<hr>
<p>在实际调试过程，发现第一种方式会出现奇怪的<strong>问题</strong>，结构体经过几次函数传递之后，struct内的string变成了乱码，貌似是char*指针地址直接变了。
这个问题最后也没看懂，应该是比较底层的问题。</p>
<p>后来就选择了第二种方式，虽然简陋，但是不会有问题。</p>
<hr>
<h1 id="c函数如何将截图回调给go"><a href="#c函数如何将截图回调给go" class="headerlink" title="c函数如何将截图回调给go"></a>c函数如何将截图回调给go</h1><p>在使用cgo的时候，go也没有办法把一个成员函数直接传递给c来进行调用，所以简单的使用一个全局函数来给c进行调用：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//export SnapshotCallBackForC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SnapshotCallBackForC</span><span class="params">(taskId, filePath <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 用于c语言回调，貌似只能这么猥琐的来写了</span></span><br><span class="line">    <span class="comment">// 截图成功则调用这个函数来通知go</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;taskId %s, filePath %s\n&quot;</span>, taskId, filePath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="如何让c函数日志打印到go的日志函数中"><a href="#如何让c函数日志打印到go的日志函数中" class="headerlink" title="如何让c函数日志打印到go的日志函数中"></a>如何让c函数日志打印到go的日志函数中</h1><p>统一日志打印，整个程序调试起来会简单很多。</p>
<p>首先go将日志函数export一下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export InfoForC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InfoForC</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> loglevel &gt; LevelInfo &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger.Info(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在c中进行一下包装，可以十分方便的直接使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LogDebug(fmt, ...) GoDebug(__FILE__, __FUNCTION__, __LINE__, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LogInfo(fmt, ...) GoInfo(__FILE__, __FUNCTION__, __LINE__, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LogWarn(fmt, ...) GoWarn(__FILE__, __FUNCTION__, __LINE__, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LogError(fmt, ...) GoError(__FILE__, __FUNCTION__, __LINE__, fmt, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GoInfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">const</span> <span class="keyword">char</span>* func, <span class="keyword">int</span> line, <span class="keyword">char</span>* fmt, ...)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">char</span> buf[MSG_MAX_LEN];</span><br><span class="line">	i = <span class="built_in">snprintf</span>(buf, MSG_MAX_LEN, <span class="string">&quot;[%s][%s:%d] &quot;</span>, file, func, line);</span><br><span class="line">	va_list arglist;</span><br><span class="line">	va_start(arglist, fmt);</span><br><span class="line">	j = vsnprintf(&amp;buf[i], MSG_MAX_LEN - i, fmt, arglist);</span><br><span class="line">	va_end(arglist);</span><br><span class="line"></span><br><span class="line">	GoString go_str = &#123; p: buf, n : i + j &#125;;</span><br><span class="line">	InfoForC(go_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以在c中使用go的日志打印函数，可以将文件名、函数名和行数都打印出来，对于调试十分友好。</p>
<hr>
<h1 id="go如何立即停止c中运行的截图任务"><a href="#go如何立即停止c中运行的截图任务" class="headerlink" title="go如何立即停止c中运行的截图任务"></a>go如何立即停止c中运行的截图任务</h1><p>截图任务运行在另一个go程之中，这里通过简单的修改c的全局变量来改变截图任务的状态，让它在检测到时停止运行。</p>
<p>go函数调用c函数来修改c函数状态：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *CSnapshot)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	taskIdC := C.CString(cs.taskId)</span><br><span class="line">	<span class="keyword">defer</span> C.free(unsafe.Pointer(taskIdC))</span><br><span class="line"></span><br><span class="line">	C.StopTaskForGo(taskIdC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c函数将任务状态存入一个map之中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTaskState</span><span class="params">(<span class="keyword">char</span>* taskId, <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;taskMapMute);</span><br><span class="line">	map_set(&amp;taskStateMap, taskId, state);</span><br><span class="line">	pthread_mutex_unlock(&amp;taskMapMute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StopTaskForGo</span><span class="params">(<span class="keyword">char</span>* taskId)</span> </span>&#123;</span><br><span class="line">	setTaskState(taskId, STOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每解码一个frame，就去检测一下task的状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getTaskState</span><span class="params">(<span class="keyword">char</span>* taskId)</span> </span>&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;taskMapMute);</span><br><span class="line">	<span class="keyword">int</span>* val = map_get(&amp;taskStateMap, taskId);</span><br><span class="line">	pthread_mutex_unlock(&amp;taskMapMute);</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTaskStateRunning</span><span class="params">(<span class="keyword">char</span>* taskId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* state = getTaskState(taskId);</span><br><span class="line">	<span class="keyword">if</span> (state == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *state == RUNNING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (av_read_frame(ss-&gt;ifmt_ctx, ss-&gt;dePkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isTaskStateRunning(ss-&gt;taskId)) &#123;</span><br><span class="line">        LogWarn(<span class="string">&quot;------------- task %s state is stopped, break the loop -------------&quot;</span>, ss-&gt;taskId);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何防止av_read_frame出现阻塞</strong>：</p>
<p>如何什么都不设置，那么一旦直播流没了，也就是<code>av_read_frame</code>获取不到更多的数据的时候，它就会阻塞在哪里，
如果这时候想要结束这个任务，上面的全局变量就没用了。</p>
<p>为此，得在结束任务的时候，让<code>av_read_frame</code>也跳出阻塞。这里可以使用<code>interrupt_callback</code>来达到这个目的。</p>
<p>在ffmpeg的<code>AVFormatContext</code>结构体中，存在一个<code>AVIOInterruptCB</code>结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVFormatContext</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Custom interrupt callbacks for the I/O layer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * demuxing: set by the user before avformat_open_input().</span></span><br><span class="line"><span class="comment">     * muxing: set by the user before avformat_write_header()</span></span><br><span class="line"><span class="comment">     * (mainly useful for AVFMT_NOFILE formats). The callback</span></span><br><span class="line"><span class="comment">     * should also be passed to avio_open2() if it&#x27;s used to</span></span><br><span class="line"><span class="comment">     * open the file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVIOInterruptCB interrupt_callback;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback for checking whether to abort blocking functions.</span></span><br><span class="line"><span class="comment"> * AVERROR_EXIT is returned in this case by the interrupted</span></span><br><span class="line"><span class="comment"> * function. During blocking operations, callback is called with</span></span><br><span class="line"><span class="comment"> * opaque as parameter. If the callback returns 1, the</span></span><br><span class="line"><span class="comment"> * blocking operation will be aborted.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * No members can be added to this struct without a major bump, if</span></span><br><span class="line"><span class="comment"> * new elements have been added after this struct in AVFormatContext</span></span><br><span class="line"><span class="comment"> * or AVIOContext.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVIOInterruptCB</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*callback)(<span class="keyword">void</span>*);</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">&#125; AVIOInterruptCB;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所以这里设置一个回调函数，在任务状态为<code>Stop</code>的时候返回1即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTaskStateRunning</span><span class="params">(<span class="keyword">char</span>* taskId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* state = getTaskState(taskId);</span><br><span class="line">	<span class="keyword">if</span> (state == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *state == RUNNING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">interruptCallBack</span><span class="params">(<span class="keyword">void</span>* taskId)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isTaskStateRunning((<span class="keyword">char</span>*)taskId)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ss-&gt;ifmt_ctx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">ss-&gt;ifmt_ctx-&gt;interrupt_callback.callback = interruptCallBack;</span><br><span class="line">ss-&gt;ifmt_ctx-&gt;interrupt_callback.opaque = ss-&gt;taskId;</span><br></pre></td></tr></table></figure>
<p>通过上面的方法，就可以通过go立即停止正在运行的c截图任务。</p>
<hr>
<h1 id="如何自定义ffmpeg的打印函数"><a href="#如何自定义ffmpeg的打印函数" class="headerlink" title="如何自定义ffmpeg的打印函数"></a>如何自定义ffmpeg的打印函数</h1><p>直接可以通过<code>av_log_set_callback</code>函数来自定义日志函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initFFLogCallBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;ffLogInitMute);</span><br><span class="line">	<span class="keyword">if</span> (!ffLogInit) &#123;</span><br><span class="line">		ffLogInit = <span class="number">1</span>;</span><br><span class="line">		av_log_set_callback(LogForFF);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;ffLogInitMute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">FF_LOG_LEVEL</span> &#123;</span></span><br><span class="line">	FF_ERROR,</span><br><span class="line">	FF_WARN,</span><br><span class="line">	FF_INFO,</span><br><span class="line">	FF_DEBUG,</span><br><span class="line">&#125; FF_LOG_LEVEL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetFFLogLevel</span><span class="params">(<span class="keyword">enum</span> FF_LOG_LEVEL level)</span> </span>&#123;</span><br><span class="line">	ff_log_level = level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LogForFF</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">int</span> level, <span class="keyword">const</span> <span class="keyword">char</span>* fmt, va_list vl)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (level &gt;= AV_LOG_DEBUG) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ff_log_level &gt;= FF_DEBUG) &#123;</span><br><span class="line">			LogDebug(fmt, vl);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (level &gt;= AV_LOG_INFO) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ff_log_level &gt;= FF_INFO) &#123;</span><br><span class="line">			LogInfo(fmt, vl);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (level &gt;= AV_LOG_WARNING) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ff_log_level &gt;= FF_WARN) &#123;</span><br><span class="line">			LogWarn(fmt, vl);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (level &gt;= AV_LOG_QUIET) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ff_log_level &gt;= FF_ERROR) &#123;</span><br><span class="line">			LogError(fmt, vl);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		LogError(fmt, vl);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这样可以使得ffmpeg也使用go的日志函数来进行打印，但是通常情况下ffmpeg的日志实在太多了，根本没法看，所以不太建议使用。</p>
<hr>
<h1 id="如何优化cgo的运行效率"><a href="#如何优化cgo的运行效率" class="headerlink" title="如何优化cgo的运行效率"></a>如何优化cgo的运行效率</h1><p>在写这个代码的过程中，经过反复测试，发现要<strong>尽量减少go和c之间的相互调用</strong>。</p>
<p>最开始，任务状态检测时，之间让c调用go的函数来进行检测，这样每一次收到一个packet，就会调用一下go的函数。
结果CPU使用率增加了近一倍多（相比于直接纯c语言截图）。</p>
<p>后来就改成了上面的方式，c中使用一个全局的map来存储任务的状态，每一次收到一个packet，直接去检测这个全局变量，而不是调用go函数，
CPU使用率就回到了正常的水平。</p>
<hr>
]]></content>
      <categories>
        <category>media</category>
      </categories>
      <tags>
        <tag>live</tag>
        <tag>golang</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>webrtc学习笔记-手动建立DataChannel</title>
    <url>/2020/11/24/2020-11-24-webrtc-datachannel-manually/</url>
    <content><![CDATA[<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>例子来自一个golang的webrtc项目<a href="https://github.com/pion/webrtc">https://github.com/pion/webrtc</a>，这个项目提供了webrtc的go语言实现。</p>
<hr>
<h1 id="DataChannel"><a href="#DataChannel" class="headerlink" title="DataChannel"></a>DataChannel</h1><p><a href="https://webrtcforthecurious.com/docs/06-data-communication/">Data Communication</a></p>
<p>DataChannel使用<strong>SCTP</strong>来传输数据，提供可靠传输，确保数据有序发送。</p>
<p>DataChannel可以发送文本或者二进制数据，意思就是发送什么数据都可以。</p>
<hr>
<h1 id="DataChannel的连接建立过程"><a href="#DataChannel的连接建立过程" class="headerlink" title="DataChannel的连接建立过程"></a>DataChannel的连接建立过程</h1><p>下面这张图来自博客<a href="https://blog.csdn.net/ice_ly000/article/details/103204327">WebRTC源码分析——呼叫建立过程之三(创建PeerConnection)</a>:</p>
<p><img src="/images/media/webrtc/webrtc-connect.png" alt="image" title="连接建立过程"></p>
<p>这张图可以清晰的看出整个连接建立的过程，其中除了两个客户端之外，还有两个重要的角色<strong>Signal-Server</strong>和<strong>Stun-Server</strong>：</p>
<ul>
<li><strong>Signal-Server</strong>，信令服务器。两个客户端要首先连上信令服务器，这样才能互相知道对方的存在，而且在P2P的连接真正建立成功之前，两端的数据交互全部依靠信令服务器来传输。</li>
<li><strong>Stun-Server</strong>，stun服务器。客户端需要去询问它来得到自己的NAT地址，这样最后两端才能进行直接连接。</li>
</ul>
<p>这里主要关注这个地方：</p>
<ol>
<li>caller调用<code>SetLocalDescription</code>，然后发送<strong>offer</strong>到callee（经过信令服务器）。</li>
<li>callee收到<strong>offer</strong>，先调用<code>SetRemoteDescription</code>，然后生成<strong>answer</strong>，同样的<code>SetLocalDescription</code>，最后发送<strong>answer</strong>到caller（经过信令服务器）。</li>
</ol>
<hr>
<h1 id="手动建立DataChannel代码"><a href="#手动建立DataChannel代码" class="headerlink" title="手动建立DataChannel代码"></a>手动建立DataChannel代码</h1><p>代码就是webrtc项目下自带的例子，简单改了几行，让两边都可以互相发送消息。</p>
<p>caller:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/pion/webrtc/v3&quot;</span></span><br><span class="line">	<span class="string">&quot;myWebrtc1/signal&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configure and create a new PeerConnection.</span></span><br><span class="line">	config := webrtc.Configuration&#123;</span><br><span class="line">		ICEServers: []webrtc.ICEServer&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				URLs: []<span class="keyword">string</span>&#123;<span class="string">&quot;stun:stun.l.google.com:19302&quot;</span>&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以设置日志级别</span></span><br><span class="line">	<span class="comment">//err := os.Setenv(&quot;PION_LOG_INFO&quot;, &quot;ALL&quot;)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	panic(err)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	pc, err := webrtc.NewPeerConnection(config)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create DataChannel.</span></span><br><span class="line">	sendChannel, err := pc.CreateDataChannel(<span class="string">&quot;foo&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	sendChannel.OnClose(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;sendChannel has closed&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	sendChannel.OnOpen(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;sendChannel has opened&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	sendChannel.OnMessage(<span class="function"><span class="keyword">func</span><span class="params">(msg webrtc.DataChannelMessage)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Message from DataChannel %s payload %s\n&quot;</span>, sendChannel.Label(), <span class="keyword">string</span>(msg.Data))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add handlers for setting up the connection.</span></span><br><span class="line">	pc.OnICEConnectionStateChange(<span class="function"><span class="keyword">func</span><span class="params">(state webrtc.ICEConnectionState)</span></span> &#123;</span><br><span class="line">		fmt.Println(state)</span><br><span class="line">	&#125;)</span><br><span class="line">	pc.OnICECandidate(<span class="function"><span class="keyword">func</span><span class="params">(candidate *webrtc.ICECandidate)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> candidate != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(signal.Encode(*pc.LocalDescription()))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create offer</span></span><br><span class="line">	offer, err := pc.CreateOffer(<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := pc.SetLocalDescription(offer); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置对面的 Description</span></span><br><span class="line">	answer := webrtc.SessionDescription&#123;&#125;</span><br><span class="line">	signal.Decode(signal.MustReadStdin(), &amp;answer)</span><br><span class="line"></span><br><span class="line">	err = pc.SetRemoteDescription(answer)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送消息</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			message := signal.MustReadStdin()</span><br><span class="line">			<span class="keyword">if</span> err := sendChannel.SendText(message); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stay alive</span></span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>callee:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/pion/webrtc/v3&quot;</span></span><br><span class="line">	<span class="string">&quot;myWebrtc1/signal&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	config := webrtc.Configuration&#123;</span><br><span class="line">		ICEServers: []webrtc.ICEServer&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				URLs: []<span class="keyword">string</span>&#123;<span class="string">&quot;stun:stun.l.google.com:19302&quot;</span>&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以设置日志级别</span></span><br><span class="line">	<span class="comment">//err := os.Setenv(&quot;PION_LOG_INFO&quot;, &quot;ALL&quot;)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	panic(err)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	peerConnection, err := webrtc.NewPeerConnection(config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	peerConnection.OnICEConnectionStateChange(<span class="function"><span class="keyword">func</span><span class="params">(connectionState webrtc.ICEConnectionState)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;ICE Connection State has changed: %s\n&quot;</span>, connectionState.String())</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	peerConnection.OnDataChannel(<span class="function"><span class="keyword">func</span><span class="params">(d *webrtc.DataChannel)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;New DataChannel %s %d\n&quot;</span>, d.Label(), d.ID())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register channel opening handling</span></span><br><span class="line">		d.OnOpen(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Data channel &#x27;%s&#x27;-&#x27;%d&#x27; open.\n&quot;</span>, d.Label(), d.ID())</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register text message handling</span></span><br><span class="line">		d.OnMessage(<span class="function"><span class="keyword">func</span><span class="params">(msg webrtc.DataChannelMessage)</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Message from DataChannel &#x27;%s&#x27;: &#x27;%s&#x27;\n&quot;</span>, d.Label(), <span class="keyword">string</span>(msg.Data))</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送消息</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				message := signal.MustReadStdin()</span><br><span class="line">				<span class="keyword">if</span> err := d.SendText(message); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="built_in">panic</span>(err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	offer := webrtc.SessionDescription&#123;&#125;</span><br><span class="line">	signal.Decode(signal.MustReadStdin(), &amp;offer)</span><br><span class="line"></span><br><span class="line">	err = peerConnection.SetRemoteDescription(offer)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create an answer</span></span><br><span class="line">	answer, err := peerConnection.CreateAnswer(<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create channel that is blocked until ICE Gathering is complete</span></span><br><span class="line">	gatherComplete := webrtc.GatheringCompletePromise(peerConnection)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sets the LocalDescription, and starts our UDP listeners</span></span><br><span class="line">	err = peerConnection.SetLocalDescription(answer)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block until ICE Gathering is complete, disabling trickle ICE</span></span><br><span class="line">	<span class="comment">// we do this because we only can exchange one signaling message</span></span><br><span class="line">	<span class="comment">// in a production application you should exchange ICE Candidates via OnICECandidate</span></span><br><span class="line">	&lt;-gatherComplete</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Output the answer in base64 so we can paste it in browser</span></span><br><span class="line">	fmt.Println(signal.Encode(*peerConnection.LocalDescription()))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block forever</span></span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的辅助函数也是例子里面的：</p>
<ul>
<li><code>MustReadStdin()</code>从输入读入一行数据。</li>
<li><code>Encode()</code>和<code>Decode()</code>，将一个对象先进行marshall或者unmarshall，然后编解码成base64格式。</li>
</ul>
<hr>
<p>注意到上面对连接过程的描述中，除了caller和callee，还有两个重要角色<strong>stun</strong>和<strong>信令服务器</strong>。</p>
<p>这里<strong>stun</strong>可以直接使用公开的服务器<code>stun:stun.l.google.com:19302</code>，也可以自己搭建一个。</p>
<p><strong>信令服务器则就是人，也就是人工手动操作：</strong></p>
<ol>
<li>启动caller，将输出的<code>Description</code>复制下来。</li>
<li>启动callee，将caller的<code>Description</code>输入进去。</li>
<li>callee输出<code>Description</code>，同样的复制下来。</li>
<li>将callee的<code>Description</code>输入到caller。</li>
<li>连接建立成功，两边可以开始互相发送消息。</li>
</ol>
<hr>
<h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><p>有时候在完成两边的<code>Description</code>交换之后，会卡住，然后连接建立超时，目前未研究出原因。</p>
<hr>
]]></content>
      <categories>
        <category>media</category>
      </categories>
      <tags>
        <tag>live</tag>
        <tag>golang</tag>
        <tag>webrtc</tag>
      </tags>
  </entry>
  <entry>
    <title>webrtc学习笔记-使用js编写并调用摄像头同时进行码率统计</title>
    <url>/2020/12/28/2020-12-28-webrtc-stream-test/</url>
    <content><![CDATA[<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>之前使用pion的那个golang写的webrtc库的时候，总觉得有些问题，于是决定从原生的js接口学，毕竟这个成熟得多。</p>
<p>这里的代码同样很简单，主要展示了如下两点内容：</p>
<ul>
<li>如何调用摄像头，添加音视频track。</li>
<li>如何调整音视频编码偏好。比如使用H264。</li>
<li>如何统计当前实时的音视频码率。</li>
</ul>
<p>代码：<a href="https://github.com/isadamu/webrtcstreamtest">https://github.com/isadamu/webrtcstreamtest</a></p>
<hr>
<h1 id="如何调用摄像头，添加音视频track"><a href="#如何调用摄像头，添加音视频track" class="headerlink" title="如何调用摄像头，添加音视频track"></a>如何调用摄像头，添加音视频track</h1><p>有很多以前的博客中，使用的方法都是过时的，很多不能用，这里可以参考官方文档<a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia">MediaDevices.getUserMedia()</a>。</p>
<p>可以使用如下语法来调用摄像头，并把stream添加到PeerConnection中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">navigator.mediaDevices.getUserMedia(&#123; <span class="attr">video</span>: <span class="literal">true</span>, <span class="attr">audio</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">stream</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;video1&#x27;</span>).srcObject = stream;</span><br><span class="line"></span><br><span class="line">        stream.getTracks().forEach(<span class="function"><span class="params">track</span> =&gt;</span> pc.addTrack(track, stream));</span><br><span class="line"></span><br><span class="line">    &#125;).catch(log);</span><br></pre></td></tr></table></figure>
<p>这里的<code>video1</code>是一个简单的html标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;video1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span> <span class="attr">autoplay</span> <span class="attr">muted</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里使用<code>addTrack</code>将流添加到连接中，用法可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addTrack">RTCPeerConnection.addTrack()</a>。
它有两个参数<code>track</code>和<code>stream</code>，其中<code>track</code>我理解为轨道，可以是音轨，也可以是视频轨道。<code>stream</code>则代表这个轨道属于哪一条流，
webrtc会自动的将同一个<code>stream</code>下的<code>track</code>绑定到一起，无论是本地还是远端。</p>
<p>另一端则使用<code>ontrack</code>来处理<code>addTrack</code>所添加的轨道：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> videoElem = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;video2&#x27;</span>);</span><br><span class="line">pc.ontrack = <span class="function"><span class="params">ev</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.streams &amp;&amp; ev.streams[<span class="number">0</span>]) &#123;</span><br><span class="line">        videoElem.srcObject = ev.streams[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一次调用<code>addTrack</code>都会触发一次<code>ontrack</code>，其中的event结构参考文档<a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCTrackEvent">RTCTrackEvent</a>，
因为这里我们知道只有一个<code>stream</code>，所以判断<code>stream[0]</code>就可以了。</p>
<hr>
<h1 id="如何调整音视频编码偏好，比如使用H264"><a href="#如何调整音视频编码偏好，比如使用H264" class="headerlink" title="如何调整音视频编码偏好，比如使用H264"></a>如何调整音视频编码偏好，比如使用H264</h1><p>上面虽然添加了音视频，可是没有任何环节对编码进行了控制，显然我们不知道这里的音视频使用的都是什么编码。</p>
<p>查看建立连接时的<strong>SDP</strong>描述符，可以看到其中有如下两段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m&#x3D;audio 9 UDP&#x2F;TLS&#x2F;RTP&#x2F;SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126</span><br><span class="line">a&#x3D;rtpmap:111 opus&#x2F;48000&#x2F;2</span><br><span class="line">a&#x3D;rtpmap:103 ISAC&#x2F;16000</span><br><span class="line">a&#x3D;rtpmap:104 ISAC&#x2F;32000</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">m&#x3D;video 9 UDP&#x2F;TLS&#x2F;RTP&#x2F;SAVPF 96 97 98 99 100 101 102 121 127 120 125 107 108 109 124 119 123 118 114 115 116</span><br><span class="line">a&#x3D;rtpmap:96 VP8&#x2F;90000</span><br><span class="line">a&#x3D;rtpmap:97 rtx&#x2F;90000</span><br><span class="line">a&#x3D;rtpmap:98 VP9&#x2F;90000</span><br><span class="line">...</span><br><span class="line">a&#x3D;rtpmap:102 H264&#x2F;90000</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中后面跟着的数字序列，其实就代变着编码格式，每一个数字代变着一种编码。</p>
<p>webrtc两端传递offer和answer的过程中，其实就对编码进行了协商，上面的编码序列就代表自己所支持的编码，顺序可以理解为优先级。
这里由于是本地测试，所以两端所支持的编码格式一样，所以肯定协商的结果就是音频使用<code>opus</code>，视频使用<code>VP8</code>。</p>
<p>调整编码序列的方法参考文档<a href="https://developer.mozilla.org/en-US/docs/Web/Media/Formats/WebRTC_codecs">Codecs used by WebRTC</a>，
如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于修改视频的编码优先顺序</span></span><br><span class="line"><span class="comment">// 这里的mimeType可以通过 RTCRtpSender.getCapabilities().codecs 来查询</span></span><br><span class="line"><span class="comment">// 格式为 &quot;video/H264&quot; 形式的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeVideoCodec</span>(<span class="params">mimeType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> transceivers = pc.getTransceivers();</span><br><span class="line"></span><br><span class="line">    transceivers.forEach(<span class="function"><span class="params">transceiver</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> kind = transceiver.sender.track.kind;</span><br><span class="line">        <span class="keyword">if</span> (kind === <span class="string">&quot;video&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> sendCodecs = RTCRtpSender.getCapabilities(kind).codecs;</span><br><span class="line">            <span class="keyword">let</span> recvCodecs = RTCRtpReceiver.getCapabilities(kind).codecs;</span><br><span class="line"></span><br><span class="line">            sendCodecs = preferCodec(sendCodecs, mimeType);</span><br><span class="line">            recvCodecs = preferCodec(recvCodecs, mimeType);</span><br><span class="line"></span><br><span class="line">            transceiver.setCodecPreferences([...sendCodecs, ...recvCodecs]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将偏好的编码格式放到数组前，其它编码格式放到数组后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preferCodec</span>(<span class="params">codecs, mimeType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> otherCodecs = [];</span><br><span class="line">    <span class="keyword">let</span> sortedCodecs = [];</span><br><span class="line"></span><br><span class="line">    codecs.forEach(<span class="function"><span class="params">codec</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (codec.mimeType === mimeType) &#123;</span><br><span class="line">            sortedCodecs.push(codec);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            otherCodecs.push(codec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    sortedCodecs = sortedCodecs.concat(otherCodecs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console.log(sortedCodecs);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sortedCodecs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要在offer创建之前修改编码顺序即可（发送方在发出answer之前修改应该也是可以的），就能改变连接的默认编码偏好。</p>
<p>可以观察到SDP中的视频编码序列变为：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m&#x3D;video 9 UDP&#x2F;TLS&#x2F;RTP&#x2F;SAVPF 102 104 106 108 96 98 100 114 116 110 112 97 99 101 103 105 107 109 111 113 115</span><br><span class="line">a&#x3D;rtpmap:102 H264&#x2F;90000</span><br><span class="line">...</span><br></pre></td></tr></table></figure></h2><h1 id="如何统计当前实时的音视频码率"><a href="#如何统计当前实时的音视频码率" class="headerlink" title="如何统计当前实时的音视频码率"></a>如何统计当前实时的音视频码率</h1><p>很自然的，我们想知道当前实时的音视频码率是多少，这样可以大概判断一下带宽和CPU消耗，参考文档<a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/getStats">RTCPeerConnection.getStats()</a>。
通过webrtc提供的统计接口<code>getStats()</code>来查询实时的信息，来完成对码率的统计。</p>
<p>直接将所有信息打印出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每秒钟打印 stats 信息</span></span><br><span class="line"><span class="built_in">window</span>.setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    pc.getStats(<span class="literal">null</span>).then(<span class="function"><span class="params">stats</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> statsOutput = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        stats.forEach(<span class="function"><span class="params">report</span> =&gt;</span> &#123;</span><br><span class="line">            statsOutput += <span class="string">`&lt;h2&gt;Report: <span class="subst">$&#123;report.type&#125;</span>&lt;/h3&gt;\n&lt;strong&gt;ID:&lt;/strong&gt; <span class="subst">$&#123;report.id&#125;</span>&lt;br&gt;\n`</span> +</span><br><span class="line">                <span class="string">`&lt;strong&gt;Timestamp:&lt;/strong&gt; <span class="subst">$&#123;report.timestamp&#125;</span>&lt;br&gt;\n`</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Now the statistics for this report; we intentially drop the ones we</span></span><br><span class="line">            <span class="comment">// sorted to the top above</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">Object</span>.keys(report).forEach(<span class="function"><span class="params">statName</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (statName !== <span class="string">&quot;id&quot;</span> &amp;&amp; statName !== <span class="string">&quot;timestamp&quot;</span> &amp;&amp; statName !== <span class="string">&quot;type&quot;</span>) &#123;</span><br><span class="line">                    statsOutput += <span class="string">`&lt;strong&gt;<span class="subst">$&#123;statName&#125;</span>:&lt;/strong&gt; <span class="subst">$&#123;report[statName]&#125;</span>&lt;br&gt;\n`</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;stats-box&quot;</span>).innerHTML = statsOutput;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>这样打印出来的信息非常多，很多都是我们不需要的，所以可以传入track，来过滤出我们需要的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 处理远端 track</span><br><span class="line">let videoElem &#x3D; document.getElementById(&#39;video2&#39;);</span><br><span class="line">let mediaTracks &#x3D; [];    &#x2F;&#x2F; 用于统计</span><br><span class="line">pc.ontrack &#x3D; ev &#x3D;&gt; &#123;</span><br><span class="line">    if (ev.streams &amp;&amp; ev.streams[0]) &#123;</span><br><span class="line">        console.log(&quot;on track&quot; + ev.streams[0]);</span><br><span class="line">        videoElem.srcObject &#x3D; ev.streams[0];</span><br><span class="line">        mediaTracks.push(ev.track);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里稍微过滤了一下,只统计输入的音视频流,并计算出实时码率(简单平滑了一下)</span><br><span class="line">const statIntervalBase &#x3D; 1000;</span><br><span class="line">const statInterval &#x3D; 1;</span><br><span class="line">let lastRecvByteVideo &#x3D; 0;</span><br><span class="line">let lastRecvByteAudio &#x3D; 0;</span><br><span class="line">window.setInterval(function() &#123;</span><br><span class="line">    if (mediaTracks.length &lt;&#x3D; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mediaTracks.forEach(track &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        pc.getStats(track).then(stats &#x3D;&gt; &#123;</span><br><span class="line">            stats.forEach(report &#x3D;&gt; &#123;</span><br><span class="line">                if (report.type &#x3D;&#x3D;&#x3D; &quot;inbound-rtp&quot;) &#123;</span><br><span class="line">                    let statsOutput &#x3D; &quot;&quot;;</span><br><span class="line">                    statsOutput +&#x3D; &#96;&lt;h2&gt;Report: $&#123;report.type&#125;&lt;&#x2F;h3&gt;\n&lt;strong&gt;ID:&lt;&#x2F;strong&gt; $&#123;report.id&#125;&lt;br&gt;\n&#96; +</span><br><span class="line">                        &#96;&lt;strong&gt;Timestamp:&lt;&#x2F;strong&gt; $&#123;report.timestamp&#125;&lt;br&gt;\n&#96;;</span><br><span class="line"></span><br><span class="line">                    Object.keys(report).forEach(statName &#x3D;&gt; &#123;</span><br><span class="line">                        if (statName !&#x3D;&#x3D; &quot;id&quot; &amp;&amp; statName !&#x3D;&#x3D; &quot;timestamp&quot; &amp;&amp; statName !&#x3D;&#x3D; &quot;type&quot;) &#123;</span><br><span class="line">                            statsOutput +&#x3D; &#96;&lt;strong&gt;$&#123;statName&#125;:&lt;&#x2F;strong&gt; $&#123;report[statName]&#125;&lt;br&gt;\n&#96;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    let RecvByte &#x3D; report.bytesReceived;</span><br><span class="line"></span><br><span class="line">                    if (report.mediaType &#x3D;&#x3D;&#x3D; &quot;video&quot;) &#123;</span><br><span class="line">                        document.getElementById(&quot;stats-video&quot;).innerHTML &#x3D; statsOutput;</span><br><span class="line"></span><br><span class="line">                        let bitRate &#x3D; ((RecvByte - lastRecvByteVideo) * 8) &#x2F; (statInterval * 1000);</span><br><span class="line">                        lastRecvByteVideo &#x3D; RecvByte;</span><br><span class="line"></span><br><span class="line">                        document.getElementById(&quot;remote-stat-video-show&quot;).innerHTML &#x3D; &quot;video: &quot; + bitRate + &quot; kbps&quot;;</span><br><span class="line"></span><br><span class="line">                    &#125; else if (report.mediaType &#x3D;&#x3D;&#x3D; &quot;audio&quot;) &#123;</span><br><span class="line">                        document.getElementById(&quot;stats-audio&quot;).innerHTML &#x3D; statsOutput;</span><br><span class="line"></span><br><span class="line">                        let bitRate &#x3D; ((RecvByte - lastRecvByteAudio) * 8) &#x2F; (statInterval * 1000);</span><br><span class="line">                        lastRecvByteAudio &#x3D; RecvByte;</span><br><span class="line"></span><br><span class="line">                        document.getElementById(&quot;remote-stat-audio-show&quot;).innerHTML &#x3D; &quot;audio: &quot; + bitRate + &quot; kbps&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;, statIntervalBase * statInterval);</span><br></pre></td></tr></table></figure>
<p>上面的代码，在<code>ontrack</code>时将远端的track临时保存一下，然后传入到<code>getStats()</code>中，这样筛选出我们所需要的<code>inbound-rtp</code>信息，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Report: inbound-rtp</span><br><span class="line"></span><br><span class="line">    ID: RTCInboundRTPVideoStream_3091018575</span><br><span class="line">    Timestamp: 1609225346268</span><br><span class="line">    ssrc: 3091018575</span><br><span class="line">    isRemote: false</span><br><span class="line">    mediaType: video</span><br><span class="line">    kind: video</span><br><span class="line">    trackId: RTCMediaStreamTrack_receiver_2</span><br><span class="line">    transportId: RTCTransport_0_1</span><br><span class="line">    codecId: RTCCodec_1_Inbound_102</span><br><span class="line">    firCount: 0</span><br><span class="line">    pliCount: 2</span><br><span class="line">    nackCount: 0</span><br><span class="line">    packetsReceived: 383830</span><br><span class="line">    bytesReceived: 323599556</span><br><span class="line">    headerBytesReceived: 9330284</span><br><span class="line">    packetsLost: 0</span><br><span class="line">    lastPacketReceivedTimestamp: 1663077.686</span><br><span class="line">    framesReceived: 45982</span><br><span class="line">    frameWidth: 640</span><br><span class="line">    frameHeight: 480</span><br><span class="line">    framesPerSecond: 29</span><br><span class="line">    framesDecoded: 45952</span><br><span class="line">    keyFramesDecoded: 768</span><br><span class="line">    framesDropped: 11</span><br><span class="line">    totalDecodeTime: 30.94</span><br><span class="line">    totalInterFrameDelay: 1533.7619999993074</span><br><span class="line">    totalSquaredInterFrameDelay: 53.32035400000804</span><br><span class="line">    estimatedPlayoutTimestamp: 3818214146152</span><br><span class="line">    decoderImplementation: ExternalDecoder</span><br><span class="line"></span><br><span class="line">Report: inbound-rtp</span><br><span class="line"></span><br><span class="line">    ID: RTCInboundRTPAudioStream_3120593010</span><br><span class="line">    Timestamp: 1609225361268</span><br><span class="line">    ssrc: 3120593010</span><br><span class="line">    isRemote: false</span><br><span class="line">    mediaType: audio</span><br><span class="line">    kind: audio</span><br><span class="line">    trackId: RTCMediaStreamTrack_receiver_1</span><br><span class="line">    transportId: RTCTransport_0_1</span><br><span class="line">    codecId: RTCCodec_0_Inbound_111</span><br><span class="line">    packetsReceived: 77452</span><br><span class="line">    fecPacketsReceived: 0</span><br><span class="line">    fecPacketsDiscarded: 0</span><br><span class="line">    bytesReceived: 4679465</span><br><span class="line">    headerBytesReceived: 2168656</span><br><span class="line">    packetsLost: 0</span><br><span class="line">    lastPacketReceivedTimestamp: 1663092.678</span><br><span class="line">    jitter: 0.002</span><br><span class="line">    jitterBufferDelay: 3664896</span><br><span class="line">    jitterBufferEmittedCount: 74351040</span><br><span class="line">    totalSamplesReceived: 74406560</span><br><span class="line">    concealedSamples: 53120</span><br><span class="line">    silentConcealedSamples: 52600</span><br><span class="line">    concealmentEvents: 1</span><br><span class="line">    insertedSamplesForDeceleration: 4197</span><br><span class="line">    removedSamplesForAcceleration: 1663</span><br><span class="line">    audioLevel: 0</span><br><span class="line">    totalAudioEnergy: 0</span><br><span class="line">    totalSamplesDuration: 1552.3499999987332</span><br><span class="line">    estimatedPlayoutTimestamp: 3818214161171</span><br></pre></td></tr></table></figure>
<p>首先可以看到视频的信息中的<code>codecId: RTCCodec_1_Inbound_102</code>说明当前视频编码为102，也就是<code>a=rtpmap:102 H264/90000</code>，即H264，说明上面对编码的修改成功生效。</p>
<p>然后很明显，我们可以通过<code>bytesReceived: 323599556</code>信息来对音视频的实时码率进行计算，正如上面代码中所展示的那样。</p>
<p><img src="/images/media/webrtc/bitrate-show.png" alt="image" title="码率统计"></p>
<p>上图可以看到视频码率在1700kbps左右，音频在20kbps左右。本地连接之间的延迟大概在70ms。</p>
<hr>
]]></content>
      <categories>
        <category>media</category>
      </categories>
      <tags>
        <tag>live</tag>
        <tag>golang</tag>
        <tag>webrtc</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow 笔记一</title>
    <url>/2017/09/26/2017-09-26-tensorflow-tutorial/</url>
    <content><![CDATA[<hr>
<h2 id="Building-Input-Functions-with-tf-estimator"><a href="#Building-Input-Functions-with-tf-estimator" class="headerlink" title="Building Input Functions with tf.estimator"></a>Building Input Functions with tf.estimator</h2><p>直接从<code>Building Input Functions with tf.estimator</code>这一节开始，前面的就先不做笔记了。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">tf.logging.set_verbosity(tf.logging.INFO)</span><br><span class="line"></span><br><span class="line">COLUMNS = [<span class="string">&quot;crim&quot;</span>, <span class="string">&quot;zn&quot;</span>, <span class="string">&quot;indus&quot;</span>, <span class="string">&quot;nox&quot;</span>, <span class="string">&quot;rm&quot;</span>, <span class="string">&quot;age&quot;</span>,</span><br><span class="line">           <span class="string">&quot;dis&quot;</span>, <span class="string">&quot;tax&quot;</span>, <span class="string">&quot;ptratio&quot;</span>, <span class="string">&quot;medv&quot;</span>]</span><br><span class="line">FEATURES = [<span class="string">&quot;crim&quot;</span>, <span class="string">&quot;zn&quot;</span>, <span class="string">&quot;indus&quot;</span>, <span class="string">&quot;nox&quot;</span>, <span class="string">&quot;rm&quot;</span>,</span><br><span class="line">            <span class="string">&quot;age&quot;</span>, <span class="string">&quot;dis&quot;</span>, <span class="string">&quot;tax&quot;</span>, <span class="string">&quot;ptratio&quot;</span>]</span><br><span class="line">LABEL = <span class="string">&quot;medv&quot;</span></span><br><span class="line"></span><br><span class="line">training_set = pd.read_csv(<span class="string">&quot;boston_train.csv&quot;</span>, </span><br><span class="line">                           skipinitialspace=<span class="literal">True</span>, </span><br><span class="line">                           skiprows=<span class="number">1</span>, names=COLUMNS)</span><br><span class="line"></span><br><span class="line">test_set = pd.read_csv(<span class="string">&quot;boston_test.csv&quot;</span>, </span><br><span class="line">                       skipinitialspace=<span class="literal">True</span>, </span><br><span class="line">                       skiprows=<span class="number">1</span>, names=COLUMNS)</span><br><span class="line"></span><br><span class="line">prediction_set = pd.read_csv(<span class="string">&quot;boston_predict.csv&quot;</span>, </span><br><span class="line">                             skipinitialspace=<span class="literal">True</span>, </span><br><span class="line">                             skiprows=<span class="number">1</span>, names=COLUMNS)</span><br><span class="line"></span><br><span class="line">feature_cols = [tf.feature_column.numeric_column(k) <span class="keyword">for</span> k <span class="keyword">in</span> FEATURES]</span><br><span class="line"></span><br><span class="line">regressor = tf.estimator.DNNRegressor(feature_columns=feature_cols, </span><br><span class="line">                                      hidden_units=[<span class="number">10</span>, <span class="number">10</span>], model_dir=<span class="string">&quot;/tmp5/boston_model&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_input_fn</span>(<span class="params">data_set, num_epochs=<span class="literal">None</span>, shuffle=<span class="literal">True</span></span>):</span></span><br><span class="line">  <span class="keyword">return</span> tf.estimator.inputs.pandas_input_fn(</span><br><span class="line">      x=pd.DataFrame(&#123;k: data_set[k].values <span class="keyword">for</span> k <span class="keyword">in</span> FEATURES&#125;),</span><br><span class="line">      y = pd.Series(data_set[LABEL].values),</span><br><span class="line">      num_epochs=num_epochs,</span><br><span class="line">      shuffle=shuffle)</span><br><span class="line"></span><br><span class="line">regressor.train(input_fn=get_input_fn(training_set), steps=<span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line">ev = regressor.evaluate(input_fn=get_input_fn(test_set, num_epochs=<span class="number">1</span>, shuffle=<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line">loss_score = ev[<span class="string">&quot;loss&quot;</span>]</span><br><span class="line">print(<span class="string">&quot;Loss: &#123;0:f&#125;&quot;</span>.<span class="built_in">format</span>(loss_score))</span><br><span class="line"></span><br><span class="line">y = regressor.predict(</span><br><span class="line">    input_fn=get_input_fn(prediction_set, num_epochs=<span class="number">1</span>, shuffle=<span class="literal">False</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># .predict() returns an iterator of dicts; convert to a list and print predictions</span></span><br><span class="line">predictions = <span class="built_in">list</span>(p[<span class="string">&quot;predictions&quot;</span>] <span class="keyword">for</span> p <span class="keyword">in</span> itertools.islice(y, <span class="number">6</span>))</span><br><span class="line">print(<span class="string">&quot;Predictions: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(predictions)))</span><br></pre></td></tr></table></figure></h2><p><strong>一段一段的理解：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br></pre></td></tr></table></figure>
<p>这里从<code>__future__</code>这个包下引入了<code>absolute_import</code>，<code>division</code>，<code>print_function</code>。</p>
<p>首先看<a href="https://docs.python.org/3/library/__future__.html?highlight=future#module-__future__"><strong>future</strong>官方API</a>，
简单来说就是将python的后面版本新特性导入到当前版本，使得当然版本也可以使用后面版本的语法。</p>
<p>看文档最后的表就知道，这里我使用的python3.6.1，所以这里的代码可以不写，如果是python较低版本，比如2.xxx，那就能需要导入一下了。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">predictions = <span class="built_in">list</span>(p[<span class="string">&quot;predictions&quot;</span>] <span class="keyword">for</span> p <span class="keyword">in</span> itertools.islice(y, <span class="number">6</span>))</span><br></pre></td></tr></table></figure>
<p>同样的，来查看<a href="https://docs.python.org/3/library/itertools.html?highlight=itertools">itertools官方API</a>，
它是一个迭代的工具类，提供了各种迭代的方法。</p>
<p>这里的，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itertools.islice(y, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>创建了一个迭代器，从<code>y</code>集合的第<strong>1</strong>个元素开始到第<strong>6</strong>个元素结束。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<p>一样的<a href="http://pandas.pydata.org/pandas-docs/stable/10min.html">官方10 Minutes to pandas</a>，
<strong>pandas</strong>是基于<code>numpy</code>的，在做数据分析时，用它来表示矩阵向量可能更加方便快捷。</p>
<p>在安装<strong>pandas</strong>时，直接使用<code>pip3 install pandas</code>会很慢，基本等于失败，换源后效果显著，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple some-package</span><br></pre></td></tr></table></figure>
<p>这里换成清华源来安装，速度很快。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.logging.set_verbosity(tf.logging.INFO)</span><br></pre></td></tr></table></figure>
<p>打开这个过后，在进行训练时，会打印很多中间过程的信息，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO:tensorflow:Restoring parameters from &#x2F;tmp5&#x2F;boston_model\model.ckpt-15000</span><br><span class="line">INFO:tensorflow:Saving checkpoints for 15001 into &#x2F;tmp5&#x2F;boston_model\model.ckpt.</span><br><span class="line">INFO:tensorflow:loss &#x3D; 1842.78, step &#x3D; 15001</span><br><span class="line">INFO:tensorflow:global_step&#x2F;sec: 702.316</span><br><span class="line">INFO:tensorflow:loss &#x3D; 3675.04, step &#x3D; 15101 (0.143 sec)</span><br><span class="line">INFO:tensorflow:global_step&#x2F;sec: 779.157</span><br><span class="line">INFO:tensorflow:loss &#x3D; 2918.1, step &#x3D; 15201 (0.128 sec)</span><br><span class="line">INFO:tensorflow:global_step&#x2F;sec: 667.102</span><br><span class="line">INFO:tensorflow:loss &#x3D; 4292.76, step &#x3D; 15301 (0.150 sec)</span><br><span class="line">INFO:tensorflow:global_step&#x2F;sec: 704.81</span><br><span class="line">INFO:tensorflow:loss &#x3D; 2817.55, step &#x3D; 15401 (0.142 sec)</span><br><span class="line">INFO:tensorflow:global_step&#x2F;sec: 727.968</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里每<strong>100</strong>次迭代打印一次当前损失。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">COLUMNS = [<span class="string">&quot;crim&quot;</span>, <span class="string">&quot;zn&quot;</span>, <span class="string">&quot;indus&quot;</span>, <span class="string">&quot;nox&quot;</span>, <span class="string">&quot;rm&quot;</span>, <span class="string">&quot;age&quot;</span>,</span><br><span class="line">           <span class="string">&quot;dis&quot;</span>, <span class="string">&quot;tax&quot;</span>, <span class="string">&quot;ptratio&quot;</span>, <span class="string">&quot;medv&quot;</span>]</span><br><span class="line">FEATURES = [<span class="string">&quot;crim&quot;</span>, <span class="string">&quot;zn&quot;</span>, <span class="string">&quot;indus&quot;</span>, <span class="string">&quot;nox&quot;</span>, <span class="string">&quot;rm&quot;</span>,</span><br><span class="line">            <span class="string">&quot;age&quot;</span>, <span class="string">&quot;dis&quot;</span>, <span class="string">&quot;tax&quot;</span>, <span class="string">&quot;ptratio&quot;</span>]</span><br><span class="line">LABEL = <span class="string">&quot;medv&quot;</span></span><br></pre></td></tr></table></figure>
<p>定义三个list，第一个是读文件时需要读取的列，第二个是样本的属性，第三个是标签列。定义这个方便对属性和标签进行拆分。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">regressor = tf.estimator.DNNRegressor(feature_columns=feature_cols, </span><br><span class="line">                                      hidden_units=[<span class="number">10</span>, <span class="number">10</span>], model_dir=<span class="string">&quot;/tmp5/boston_model&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>定义了一个深度学习回归模型，<code>[10, 10]</code>指定了模型共两层，每层<strong>10</strong>个神经元，<code>model_dir=&quot;/tmp5/boston_model&quot;</code>表示了模型存储的位置。</p>
<p><strong>注意</strong>，这里的<code>/tmp5/boston_model</code>在<strong>windows</strong>下面表示是在根目录下的<code>tmp5</code>文件夹，比如程序是在<code>F盘</code>下执行的，
那么它建立一个<code>F:/tmp5/</code>目录，如果需要当前目录下的<code>tmp5</code>目录，那就要使用<code>tmp5/boston_model</code>路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feature_cols &#x3D; [tf.feature_column.numeric_column(k) for k in FEATURES]</span><br></pre></td></tr></table></figure>
<p>这里先将<strong>FEATURES</strong>转化成回归模型所需的格式，然后传入模型。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_input_fn</span>(<span class="params">data_set, num_epochs=<span class="literal">None</span>, shuffle=<span class="literal">True</span></span>):</span></span><br><span class="line">  <span class="keyword">return</span> tf.estimator.inputs.pandas_input_fn(</span><br><span class="line">      x=pd.DataFrame(&#123;k: data_set[k].values <span class="keyword">for</span> k <span class="keyword">in</span> FEATURES&#125;),</span><br><span class="line">      y = pd.Series(data_set[LABEL].values),</span><br><span class="line">      num_epochs=num_epochs,</span><br><span class="line">      shuffle=shuffle)</span><br><span class="line"></span><br><span class="line">regressor.train(input_fn=get_input_fn(training_set), steps=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure>
<p>注意这里<code>get_input_fn</code>中调用的<code>tf.estimator.inputs.pandas_input_fn(...)</code>返回的是一个函数，因为<code>train()</code>里面接受的是一个函数对象。</p>
<p>这里调用时按照格式来的，<code>num_epochs</code>代表数据集可以过几遍，对训练集当然没有限制，所以输入数<code>None</code>，对于验证集或者测试集，
这里的<code>num_epochs</code>就要设置为<strong>1</strong>，因为一个样本只需要过一次，同样的，<code>shuffle</code>表示是否随机读取样本，也只有训练集需要随机读取操作。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ev = regressor.evaluate(input_fn=get_input_fn(test_set, num_epochs=<span class="number">1</span>, shuffle=<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line">loss_score = ev[<span class="string">&quot;loss&quot;</span>]</span><br><span class="line">print(<span class="string">&quot;Loss: &#123;0:f&#125;&quot;</span>.<span class="built_in">format</span>(loss_score))</span><br></pre></td></tr></table></figure>
<p>训练完成后，使用验证集进行验证，这里打印出损失分数。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = regressor.predict(</span><br><span class="line">    input_fn=get_input_fn(prediction_set, num_epochs=<span class="number">1</span>, shuffle=<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># .predict() returns an iterator of dicts; convert to a list and print predictions</span></span><br><span class="line">predictions = <span class="built_in">list</span>(p[<span class="string">&quot;predictions&quot;</span>] <span class="keyword">for</span> p <span class="keyword">in</span> itertools.islice(y, <span class="number">6</span>))</span><br><span class="line">print(<span class="string">&quot;Predictions: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(predictions)))</span><br></pre></td></tr></table></figure>
<p>这里就是测试预测的结果，想要的效果是，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Predictions: [33.480186, 18.6161, 23.09123, 34.338253, 16.050083, 19.354153]</span><br></pre></td></tr></table></figure>
<p>实际的结果是，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Predictions: [array([ 33.83599091], dtype&#x3D;float32), array([ 17.83500481], dtype&#x3D;float32),</span><br><span class="line"> array([ 24.12747383], dtype&#x3D;float32), array([ 35.41732025], dtype&#x3D;float32), </span><br><span class="line"> array([ 15.54900551], dtype&#x3D;float32), array([ 17.97283173], dtype&#x3D;float32)]</span><br></pre></td></tr></table></figure>
<p>说明这里<code>predict()</code>返回的是一个列表，但是列表中的元素是<code>array</code>对象，所以这里要简单改动一下，</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predictions = <span class="built_in">list</span>(p[<span class="string">&quot;predictions&quot;</span>][<span class="number">0</span>] <span class="keyword">for</span> p <span class="keyword">in</span> itertools.islice(y, <span class="number">6</span>))</span><br></pre></td></tr></table></figure></h2><hr>
<h2 id="TensorBoard-Visualizing-Learning"><a href="#TensorBoard-Visualizing-Learning" class="headerlink" title="TensorBoard: Visualizing Learning"></a>TensorBoard: Visualizing Learning</h2><p>同样的，直接阅读代码，来看看整个流程到底发生了什么，<a href="https://github.com/tensorflow/tensorflow/blob/r1.3/tensorflow/examples/tutorials/mnist/mnist_with_summaries.py">mnist_with_summaries.py</a>。</p>
<hr>
<p>首先，看<strong>入口</strong>函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  </span><br><span class="line">  parser = argparse.ArgumentParser()</span><br><span class="line">  parser.add_argument(<span class="string">&#x27;--fake_data&#x27;</span>, nargs=<span class="string">&#x27;?&#x27;</span>, const=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">bool</span>,</span><br><span class="line">                      default=<span class="literal">False</span>,</span><br><span class="line">                      <span class="built_in">help</span>=<span class="string">&#x27;If true, uses fake data for unit testing.&#x27;</span>)</span><br><span class="line">  parser.add_argument(<span class="string">&#x27;--max_steps&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1000</span>,</span><br><span class="line">                      <span class="built_in">help</span>=<span class="string">&#x27;Number of steps to run trainer.&#x27;</span>)</span><br><span class="line">  parser.add_argument(<span class="string">&#x27;--learning_rate&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.001</span>,</span><br><span class="line">                      <span class="built_in">help</span>=<span class="string">&#x27;Initial learning rate&#x27;</span>)</span><br><span class="line">  parser.add_argument(<span class="string">&#x27;--dropout&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.9</span>,</span><br><span class="line">                      <span class="built_in">help</span>=<span class="string">&#x27;Keep probability for training dropout.&#x27;</span>)</span><br><span class="line">  parser.add_argument(</span><br><span class="line">      <span class="string">&#x27;--data_dir&#x27;</span>,</span><br><span class="line">      <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">      default=os.path.join(os.getenv(<span class="string">&#x27;TEST_TMPDIR&#x27;</span>, <span class="string">&#x27;/tmp&#x27;</span>),</span><br><span class="line">                           <span class="string">&#x27;tensorflow/mnist/input_data&#x27;</span>),</span><br><span class="line">      <span class="built_in">help</span>=<span class="string">&#x27;Directory for storing input data&#x27;</span>)</span><br><span class="line">  parser.add_argument(</span><br><span class="line">      <span class="string">&#x27;--log_dir&#x27;</span>,</span><br><span class="line">      <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">      default=os.path.join(os.getenv(<span class="string">&#x27;TEST_TMPDIR&#x27;</span>, <span class="string">&#x27;/tmp&#x27;</span>),</span><br><span class="line">                           <span class="string">&#x27;tensorflow/mnist/logs/mnist_with_summaries&#x27;</span>),</span><br><span class="line">      <span class="built_in">help</span>=<span class="string">&#x27;Summaries log directory&#x27;</span>)</span><br><span class="line">  FLAGS, unparsed = parser.parse_known_args()</span><br><span class="line">  tf.app.run(main=main, argv=[sys.argv[<span class="number">0</span>]] + unparsed)</span><br></pre></td></tr></table></figure>
<p>第一句，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br></pre></td></tr></table></figure>
<p>表示下面的代码只有在这个文件被当做脚本执行时才会执行。</p>
<p>下一句，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--fake_data&#x27;</span>, nargs=<span class="string">&#x27;?&#x27;</span>, const=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">bool</span>,</span><br><span class="line">                    default=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;If true, uses fake data for unit testing.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>参考<a href="http://longrm.com/2017/09/26/2017-09-26-python-argparse/">argparse笔记</a>来理解，
那么这里也就是定义了输入的可选参数，同时也设定了默认值。</p>
<p>然后关注这一句，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">default=os.path.join( os.getenv(<span class="string">&#x27;TEST_TMPDIR&#x27;</span>, <span class="string">&#x27;/tmp&#x27;</span>),</span><br><span class="line">                      <span class="string">&#x27;tensorflow/mnist/input_data&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>其中<code>os.getenv(&#39;TEST_TMPDIR&#39;, &#39;/tmp&#39;)</code>是查询系统信息的函数，它去查询系统中<code>&#39;TEST_TMPDIR&#39;</code>的值，
显然这里没有对<code>&#39;TEST_TMPDIR&#39;</code>定义，于是它就会返回这里的设置默认值<code>&#39;/tmp&#39;</code>，否则返回<code>null</code>。</p>
<p>然后，对于<code>os.path.join()</code>它就是一个将路径合并的函数，例如，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ os.path.join(<span class="string">&#x27;/hello/&#x27;</span>,<span class="string">&#x27;good/boy/&#x27;</span>,<span class="string">&#x27;doiido&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;/hello/good/boy/doiido&#x27;</span></span><br></pre></td></tr></table></figure>
<p>但是如果是在windows下面执行，它就会变成下面这样，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ os.path.join( <span class="string">&#x27;/tmp&#x27;</span>, <span class="string">&#x27;tensorflow/mnist/input_data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;/tmp\\tensorflow/mnist/input_data&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我去，所以在windows下面执行的时候老是路径报错。</p>
<p>接着就是<code>main</code>函数的最后两句，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FLAGS, unparsed = parser.parse_known_args()</span><br><span class="line">tf.app.run(main=main, argv=[sys.argv[<span class="number">0</span>]] + unparsed)</span><br></pre></td></tr></table></figure>
<p>随便百度就可以看到它的源代码，它所进行的操作就是传入<code>main</code>函数，然后再传入参数，然后运行。
这里<code>FLAGS</code>里面的参数我们已经使用了，所以将剩下的参数传入，其中<code>sys.argv[0]</code>是当前文件的路径位置，
<code>unparsed</code>就是剩下未使用的参数。</p>
<hr>
<p>其次看<strong>main</strong>函数，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">_</span>):</span></span><br><span class="line">  <span class="keyword">if</span> tf.gfile.Exists(FLAGS.log_dir):</span><br><span class="line">    tf.gfile.DeleteRecursively(FLAGS.log_dir)</span><br><span class="line">  tf.gfile.MakeDirs(FLAGS.log_dir)</span><br><span class="line">  train()</span><br></pre></td></tr></table></figure>
<p>这里的<code>log_dir</code>就是日志文件，也就是<strong>TensorBoard</strong>画图时所需要的文件。
操作就是删除旧的日志文件，然后重新建一个文件夹，再调用<strong>train()</strong>函数。</p>
<hr>
<p><strong>这里来到train()函数，剩下的所有代码都在这里面。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line">mnist = input_data.read_data_sets(FLAGS.data_dir,</span><br><span class="line">                                  one_hot=<span class="literal">True</span>,</span><br><span class="line">                                  fake_data=FLAGS.fake_data)</span><br></pre></td></tr></table></figure>
<p>这个部分会读取本地的<code>mnist</code>数据集，如果没有它就会先将数据集下载下来，放到指定的数据目录里面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sess = tf.InteractiveSession()</span><br></pre></td></tr></table></figure>
<p>这一句使用了<strong>InteractiveSession()</strong>来建立了会话，它与<strong>Session()</strong>的不同之处在于，使用了它之后，
调用时<strong>run()</strong>变成了<strong>tf.global_variables_initializer().run()</strong>。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input placeholders</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;input&#x27;</span>):</span><br><span class="line">  x = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">784</span>], name=<span class="string">&#x27;x-input&#x27;</span>)</span><br><span class="line">  y_ = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">10</span>], name=<span class="string">&#x27;y-input&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里定义了两个输入的占位符。使用<strong>name_scope()</strong>使得在TensorBoard上它们会同处于<code>&#39;input&#39;</code>这个命名之下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;input_reshape&#x27;</span>):</span><br><span class="line">  image_shaped_input = tf.reshape(x, [-<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>])</span><br><span class="line">  tf.summary.image(<span class="string">&#x27;input&#x27;</span>, image_shaped_input, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>这里将输入重新<strong>reshape</strong>变成方阵（图片本来的形式），然后使用<code>tf.summary.image()</code>将它记录到日志里。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># We can&#x27;t initialize these variables to 0 - the network will get stuck.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span>(<span class="params">shape</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Create a weight variable with appropriate initialization.&quot;&quot;&quot;</span></span><br><span class="line">  initial = tf.truncated_normal(shape, stddev=<span class="number">0.1</span>)</span><br><span class="line">  <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span>(<span class="params">shape</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Create a bias variable with appropriate initialization.&quot;&quot;&quot;</span></span><br><span class="line">  initial = tf.constant(<span class="number">0.1</span>, shape=shape)</span><br><span class="line">  <span class="keyword">return</span> tf.Variable(initial)</span><br></pre></td></tr></table></figure>
<p>定义了一个权重初始化的函数，输入需要初始化权重的<code>shape</code>，然后第一句进行了一个<code>truncated_normal()</code>，
它进行正态初始化，但是对于超出正态一定范围的值进行丢弃，返回的是一个<code>tensor</code>。
然后使用<code>tf.Variable()</code>将它变成一个变量。</p>
<p>同样的，将<code>bias</code>初始为<strong>0.1</strong>。</p>
<hr>
<p>下面的函数是专门用来对变量进行记录的，提供给<code>TensorBoard</code>去使用，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variable_summaries</span>(<span class="params">var</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Attach a lot of summaries to a Tensor (for TensorBoard visualization).&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;summaries&#x27;</span>):</span><br><span class="line">        mean = tf.reduce_mean(var)</span><br><span class="line">        tf.summary.scalar(<span class="string">&#x27;mean&#x27;</span>, mean)</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;stddev&#x27;</span>):</span><br><span class="line">            stddev = tf.sqrt(tf.reduce_mean(tf.square(var - mean)))</span><br><span class="line">        tf.summary.scalar(<span class="string">&#x27;stddev&#x27;</span>, stddev)</span><br><span class="line">        tf.summary.scalar(<span class="string">&#x27;max&#x27;</span>, tf.reduce_max(var))</span><br><span class="line">        tf.summary.scalar(<span class="string">&#x27;min&#x27;</span>, tf.reduce_min(var))</span><br><span class="line">        tf.summary.histogram(<span class="string">&#x27;histogram&#x27;</span>, var)</span><br></pre></td></tr></table></figure>
<p>记录下变量的均值，标准差，最大值，最小值，柱状图。</p>
<p>接着的一个函数用来构建神经网络层，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nn_layer</span>(<span class="params">input_tensor, input_dim, output_dim, layer_name, act=tf.nn.relu</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Reusable code for making a simple neural net layer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    It does a matrix multiply, bias add, and then uses ReLU to nonlinearize.</span></span><br><span class="line"><span class="string">    It also sets up name scoping so that the resultant graph is easy to read,</span></span><br><span class="line"><span class="string">    and adds a number of summary ops.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Adding a name scope ensures logical grouping of the layers in the graph.</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(layer_name):</span><br><span class="line">      <span class="comment"># This Variable will hold the state of the weights for the layer</span></span><br><span class="line">      <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;weights&#x27;</span>):</span><br><span class="line">        weights = weight_variable([input_dim, output_dim])</span><br><span class="line">        variable_summaries(weights)</span><br><span class="line">      <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;biases&#x27;</span>):</span><br><span class="line">        biases = bias_variable([output_dim])</span><br><span class="line">        variable_summaries(biases)</span><br><span class="line">      <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;Wx_plus_b&#x27;</span>):</span><br><span class="line">        preactivate = tf.matmul(input_tensor, weights) + biases</span><br><span class="line">        tf.summary.histogram(<span class="string">&#x27;pre_activations&#x27;</span>, preactivate)</span><br><span class="line">      activations = act(preactivate, name=<span class="string">&#x27;activation&#x27;</span>)</span><br><span class="line">      tf.summary.histogram(<span class="string">&#x27;activations&#x27;</span>, activations)</span><br><span class="line">      <span class="keyword">return</span> activations</span><br></pre></td></tr></table></figure>
<p>初始化权重并记录，初始化偏置并记录。计算通过激活函数前的输出并记录，计算输出并记录，最后返回输出。</p>
<hr>
<p><strong>下面开始构建神经网络，</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hidden1 = nn_layer(x, <span class="number">784</span>, <span class="number">500</span>, <span class="string">&#x27;layer1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>首先构建了第一层隐藏层，神经元数量500。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;dropout&#x27;</span>):</span><br><span class="line">  keep_prob = tf.placeholder(tf.float32)</span><br><span class="line">  tf.summary.scalar(<span class="string">&#x27;dropout_keep_probability&#x27;</span>, keep_prob)</span><br><span class="line">  dropped = tf.nn.dropout(hidden1, keep_prob)</span><br></pre></td></tr></table></figure>
<p>下一步则是在第一层之后，加入了一个<code>dropout</code>层，这里的<code>keep_prob</code>使用了占位符，以便调整。同样也将概率进行记录。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Do not apply softmax activation yet, see below.</span></span><br><span class="line">y = nn_layer(dropped, <span class="number">500</span>, <span class="number">10</span>, <span class="string">&#x27;layer2&#x27;</span>, act=tf.identity)</span><br></pre></td></tr></table></figure>
<p>这里建立了神经网络的第二层，但是激活函数这里传入的是一个<code>tf.identity</code>，这个函数的意思是，
传入什么数，它就传出什么数…那么这里就相当于是没有激活函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;cross_entropy&#x27;</span>):</span><br><span class="line">  <span class="comment"># The raw formulation of cross-entropy,</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(tf.softmax(y)),</span></span><br><span class="line">  <span class="comment">#                               reduction_indices=[1]))</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># can be numerically unstable.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># So here we use tf.nn.softmax_cross_entropy_with_logits on the</span></span><br><span class="line">  <span class="comment"># raw outputs of the nn_layer above, and then average across</span></span><br><span class="line">  <span class="comment"># the batch.</span></span><br><span class="line">  diff = tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=y)</span><br><span class="line">  <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;total&#x27;</span>):</span><br><span class="line">    cross_entropy = tf.reduce_mean(diff)</span><br><span class="line">tf.summary.scalar(<span class="string">&#x27;cross_entropy&#x27;</span>, cross_entropy)</span><br></pre></td></tr></table></figure>
<p>这里就像它注释里面写的，它先计算了整体的交叉熵，然后取了一下均值，最后进行记录。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;train&#x27;</span>):</span><br><span class="line">  train_step = tf.train.AdamOptimizer(FLAGS.learning_rate).minimize(</span><br><span class="line">        cross_entropy)</span><br></pre></td></tr></table></figure>
<p>调用<code>AdamOptimizer()</code>来进行优化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;accuracy&#x27;</span>):</span><br><span class="line">  <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;correct_prediction&#x27;</span>):</span><br><span class="line">    correct_prediction = tf.equal(tf.argmax(y, <span class="number">1</span>), tf.argmax(y_, <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">with</span> tf.name_scope(<span class="string">&#x27;accuracy&#x27;</span>):</span><br><span class="line">    accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line">tf.summary.scalar(<span class="string">&#x27;accuracy&#x27;</span>, accuracy)</span><br></pre></td></tr></table></figure>
<p>首先，这里的<strong>y</strong>是一个行向量，所以使用<code>tf.argmax(y, 1)</code>将它每一行的最大值得下标找出来。同时，
<code>tf.equal()</code>将返回一个<code>bool</code>值组成的<code>tensor</code>。</p>
<p>使用<code>tf.reduce_mean()</code>计算一下均值，就得到了当前的准确率，然后将它进行记录。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Merge all the summaries and write them out to</span></span><br><span class="line"><span class="comment"># /tmp/tensorflow/mnist/logs/mnist_with_summaries (by default)</span></span><br><span class="line">merged = tf.summary.merge_all()</span><br><span class="line">train_writer = tf.summary.FileWriter(FLAGS.log_dir + <span class="string">&#x27;/train&#x27;</span>, sess.graph)</span><br><span class="line">test_writer = tf.summary.FileWriter(FLAGS.log_dir + <span class="string">&#x27;/test&#x27;</span>)</span><br><span class="line">tf.global_variables_initializer().run()</span><br></pre></td></tr></table></figure>
<p>将所有的日志合并，进行共同的操作。然后定义日志写入的位置。最后将变量初始化。</p>
<hr>
<p>最后就到了训练阶段，首先定义了<code>feed_dict</code>函数，用来给占位符赋值，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feed_dict</span>(<span class="params">train</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Make a TensorFlow feed_dict: maps data onto Tensor placeholders.&quot;&quot;&quot;</span></span><br><span class="line">  <span class="keyword">if</span> train <span class="keyword">or</span> FLAGS.fake_data:</span><br><span class="line">    xs, ys = mnist.train.next_batch(<span class="number">100</span>, fake_data=FLAGS.fake_data)</span><br><span class="line">    k = FLAGS.dropout</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    xs, ys = mnist.test.images, mnist.test.labels</span><br><span class="line">    k = <span class="number">1.0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;x: xs, y_: ys, keep_prob: k&#125;</span><br></pre></td></tr></table></figure>
<p>如果是训练阶段，那么就<code>mnist.train</code>中取出一个<code>batch</code>给<code>x</code>和<code>y</code>，如果不是训练阶段，
在这里肯定就是测试阶段了，那么就把整个测试集传给<code>x</code>和<code>y</code>。</p>
<p>下面就是训练代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Train the model, and also write summaries.</span></span><br><span class="line"><span class="comment"># Every 10th step, measure test-set accuracy, and write test summaries</span></span><br><span class="line"><span class="comment"># All other steps, run train_step on training data, &amp; add training summaries </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(FLAGS.max_steps):</span><br><span class="line">  <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span>:  <span class="comment"># Record summaries and test-set accuracy</span></span><br><span class="line">    summary, acc = sess.run([merged, accuracy], feed_dict=feed_dict(<span class="literal">False</span>))</span><br><span class="line">    test_writer.add_summary(summary, i)</span><br><span class="line">    print(<span class="string">&#x27;Accuracy at step %s: %s&#x27;</span> % (i, acc))</span><br><span class="line">  <span class="keyword">else</span>:  <span class="comment"># Record train set summaries, and train</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">99</span>:  <span class="comment"># Record execution stats</span></span><br><span class="line">      run_options = tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE)</span><br><span class="line">      run_metadata = tf.RunMetadata()</span><br><span class="line">      summary, _ = sess.run([merged, train_step],</span><br><span class="line">                            feed_dict=feed_dict(<span class="literal">True</span>),</span><br><span class="line">                            options=run_options,</span><br><span class="line">                            run_metadata=run_metadata)</span><br><span class="line">      train_writer.add_run_metadata(run_metadata, <span class="string">&#x27;step%03d&#x27;</span> % i)</span><br><span class="line">      train_writer.add_summary(summary, i)</span><br><span class="line">      print(<span class="string">&#x27;Adding run metadata for&#x27;</span>, i)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># Record a summary</span></span><br><span class="line">      summary, _ = sess.run([merged, train_step], feed_dict=feed_dict(<span class="literal">True</span>))</span><br><span class="line">      train_writer.add_summary(summary, i)</span><br><span class="line">train_writer.close()</span><br><span class="line">test_writer.close()</span><br></pre></td></tr></table></figure>
<p>首先，每运行<strong>10</strong>步，就计算一下当前的准确度，并将日志数据写入<strong>test</strong>日志文件。</p>
<p>然后，每隔<strong>100</strong>步，加入<code>tf.RunOptions()</code>和<code>tf.RunMetadata()</code>，这好像是一些原信息，类似运行时间什么的。</p>
<p>剩下的步骤就是正常的训练，每次训练的日志都写入<code>train</code>日志文件。</p>
<p>最后关闭<code>train_writer</code>和<code>test_writer</code>。</p>
]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML颜色表</title>
    <url>/2017/12/08/2017-12-08-html-color/</url>
    <content><![CDATA[<p>来源<a href="http://www.divcss5.com/html/h636.shtml">常用HTML颜色表-HTML颜色代码色彩表</a></p>
<div align="center">
<table cellspacing="0" border="1" style="zoom:50%">
    <tbody>
        <tr>
            <td width="60" bgcolor="#000000">&nbsp;</td>
            <td width="50">#000000</td>
            <td width="60" bgcolor="#2f0000">&nbsp;</td>
            <td width="50">#2F0000</td>
            <td width="60" bgcolor="#600030">&nbsp;</td>
            <td width="50">#600030</td>
            <td width="60" bgcolor="#460046">&nbsp;</td>
            <td width="50">#460046</td>
            <td width="60" bgcolor="#28004d">&nbsp;</td>
            <td width="50">#28004D</td>
        </tr>
        <tr>
            <td bgcolor="#272727">&nbsp;</td>
            <td>#272727</td>
            <td bgcolor="#4d0000">&nbsp;</td>
            <td>#4D0000</td>
            <td bgcolor="#820041">&nbsp;</td>
            <td>#820041</td>
            <td bgcolor="#5e005e">&nbsp;</td>
            <td>#5E005E</td>
            <td bgcolor="#3a006f">&nbsp;</td>
            <td>#3A006F</td>
        </tr>
        <tr>
            <td bgcolor="#3c3c3c">&nbsp;</td>
            <td>#3C3C3C</td>
            <td bgcolor="#600000">&nbsp;</td>
            <td>#600000</td>
            <td bgcolor="#9f0050">&nbsp;</td>
            <td>#9F0050</td>
            <td bgcolor="#750075">&nbsp;</td>
            <td>#750075</td>
            <td bgcolor="#4b0091">&nbsp;</td>
            <td>#4B0091</td>
        </tr>
        <tr>
            <td bgcolor="#4f4f4f">&nbsp;</td>
            <td>#4F4F4F</td>
            <td bgcolor="#750000">&nbsp;</td>
            <td>#750000</td>
            <td bgcolor="#bf0060">&nbsp;</td>
            <td>#BF0060</td>
            <td bgcolor="#930093">&nbsp;</td>
            <td>#930093</td>
            <td bgcolor="#5b00ae">&nbsp;</td>
            <td>#5B00AE</td>
        </tr>
        <tr>
            <td bgcolor="#5b5b5b">&nbsp;</td>
            <td>#5B5B5B</td>
            <td bgcolor="#930000">&nbsp;</td>
            <td>#930000</td>
            <td bgcolor="#d9006c">&nbsp;</td>
            <td>#D9006C</td>
            <td bgcolor="#ae00ae">&nbsp;</td>
            <td>#AE00AE</td>
            <td bgcolor="#6f00d2">&nbsp;</td>
            <td>#6F00D2</td>
        </tr>
        <tr>
            <td bgcolor="#6c6c6c">&nbsp;</td>
            <td>#6C6C6C</td>
            <td bgcolor="#ae0000">&nbsp;</td>
            <td>#AE0000</td>
            <td bgcolor="#f00078">&nbsp;</td>
            <td>#F00078</td>
            <td bgcolor="#d200d2">&nbsp;</td>
            <td>#D200D2</td>
            <td bgcolor="#8600ff">&nbsp;</td>
            <td>#8600FF</td>
        </tr>
        <tr>
            <td bgcolor="#7b7b7b">&nbsp;</td>
            <td>#7B7B7B</td>
            <td bgcolor="#ce0000">&nbsp;</td>
            <td>#CE0000</td>
            <td bgcolor="#ff0080">&nbsp;</td>
            <td>#FF0080</td>
            <td bgcolor="#e800e8">&nbsp;</td>
            <td>#E800E8</td>
            <td bgcolor="#921aff">&nbsp;</td>
            <td>#921AFF</td>
        </tr>
        <tr>
            <td bgcolor="#8e8e8e">&nbsp;</td>
            <td>#8E8E8E</td>
            <td bgcolor="#ea0000">&nbsp;</td>
            <td>#EA0000</td>
            <td bgcolor="#ff359a">&nbsp;</td>
            <td>#FF359A</td>
            <td bgcolor="#ff00ff">&nbsp;</td>
            <td>#FF00FF</td>
            <td bgcolor="#9f35ff">&nbsp;</td>
            <td>#9F35FF</td>
        </tr>
        <tr>
            <td bgcolor="#9d9d9d">&nbsp;</td>
            <td>#9D9D9D</td>
            <td bgcolor="#ff0000">&nbsp;</td>
            <td>#FF0000</td>
            <td bgcolor="#ff60af">&nbsp;</td>
            <td>#FF60AF</td>
            <td bgcolor="#ff44ff">&nbsp;</td>
            <td>#FF44FF</td>
            <td bgcolor="#b15bff">&nbsp;</td>
            <td>#B15BFF</td>
        </tr>
        <tr>
            <td bgcolor="#adadad">&nbsp;</td>
            <td>#ADADAD</td>
            <td bgcolor="#ff2d2d">&nbsp;</td>
            <td>#FF2D2D</td>
            <td bgcolor="#ff79bc">&nbsp;</td>
            <td>#FF79BC</td>
            <td bgcolor="#ff77ff">&nbsp;</td>
            <td>#FF77FF</td>
            <td bgcolor="#be77ff">&nbsp;</td>
            <td>#BE77FF</td>
        </tr>
        <tr>
            <td bgcolor="#bebebe">&nbsp;</td>
            <td>#BEBEBE</td>
            <td bgcolor="#ff5151">&nbsp;</td>
            <td>#FF5151</td>
            <td bgcolor="#ff95ca">&nbsp;</td>
            <td>#FF95CA</td>
            <td bgcolor="#ff8eff">&nbsp;</td>
            <td>#FF8EFF</td>
            <td bgcolor="#ca8eff">&nbsp;</td>
            <td>#CA8EFF</td>
        </tr>
        <tr>
            <td bgcolor="#d0d0d0">&nbsp;</td>
            <td>#d0d0d0</td>
            <td bgcolor="#ff7575">&nbsp;</td>
            <td>#ff7575</td>
            <td bgcolor="#ffaad5">&nbsp;</td>
            <td>#ffaad5</td>
            <td bgcolor="#ffa6ff">&nbsp;</td>
            <td>#ffa6ff</td>
            <td bgcolor="#d3a4ff">&nbsp;</td>
            <td>#d3a4ff</td>
        </tr>
        <tr>
            <td bgcolor="#e0e0e0">&nbsp;</td>
            <td>#E0E0E0</td>
            <td bgcolor="#ff9797">&nbsp;</td>
            <td>#FF9797</td>
            <td bgcolor="#ffc1e0">&nbsp;</td>
            <td>#FFC1E0</td>
            <td bgcolor="#ffbfff">&nbsp;</td>
            <td>#FFBFFF</td>
            <td bgcolor="#dcb5ff">&nbsp;</td>
            <td>#DCB5FF</td>
        </tr>
        <tr>
            <td bgcolor="#f0f0f0">&nbsp;</td>
            <td>#F0F0F0</td>
            <td bgcolor="#ffb5b5">&nbsp;</td>
            <td>#FFB5B5</td>
            <td bgcolor="#ffd9ec">&nbsp;</td>
            <td>#FFD9EC</td>
            <td bgcolor="#ffd0ff">&nbsp;</td>
            <td>#FFD0FF</td>
            <td bgcolor="#e6caff">&nbsp;</td>
            <td>#E6CAFF</td>
        </tr>
        <tr>
            <td bgcolor="#fcfcfc">&nbsp;</td>
            <td>#FCFCFC</td>
            <td bgcolor="#ffd2d2">&nbsp;</td>
            <td>#FFD2D2</td>
            <td bgcolor="#ffecf5">&nbsp;</td>
            <td>#FFECF5</td>
            <td bgcolor="#ffe6ff">&nbsp;</td>
            <td>#FFE6FF</td>
            <td bgcolor="#f1e1ff">&nbsp;</td>
            <td>#F1E1FF</td>
        </tr>
        <tr>
            <td bgcolor="#ffffff">&nbsp;</td>
            <td>#FFFFFF</td>
            <td bgcolor="#ffecec">&nbsp;</td>
            <td>#FFECEC</td>
            <td bgcolor="#fff7fb">&nbsp;</td>
            <td>#FFF7FB</td>
            <td bgcolor="#fff7ff">&nbsp;</td>
            <td>#FFF7FF</td>
            <td bgcolor="#faf4ff">&nbsp;</td>
            <td>#FAF4FF</td>
        </tr>
        <tr>
            <td bgcolor="#000079">&nbsp;</td>
            <td>#000079</td>
            <td bgcolor="#000079">&nbsp;</td>
            <td>#000079</td>
            <td bgcolor="#003e3e">&nbsp;</td>
            <td>#003E3E</td>
            <td bgcolor="#006030">&nbsp;</td>
            <td>#006030</td>
            <td bgcolor="#006000">&nbsp;</td>
            <td>#006000</td>
        </tr>
        <tr>
            <td bgcolor="#000093">&nbsp;</td>
            <td>#000093</td>
            <td bgcolor="#003d79">&nbsp;</td>
            <td>#003D79</td>
            <td bgcolor="#005757">&nbsp;</td>
            <td>#005757</td>
            <td bgcolor="#01814a">&nbsp;</td>
            <td>#01814A</td>
            <td bgcolor="#007500">&nbsp;</td>
            <td>#007500</td>
        </tr>
        <tr>
            <td bgcolor="#0000c6">&nbsp;</td>
            <td>#0000C6</td>
            <td bgcolor="#004b97">&nbsp;</td>
            <td>#004B97</td>
            <td bgcolor="#007979">&nbsp;</td>
            <td>#007979</td>
            <td bgcolor="#019858">&nbsp;</td>
            <td>#019858</td>
            <td bgcolor="#009100">&nbsp;</td>
            <td>#009100</td>
        </tr>
        <tr>
            <td bgcolor="#0000c6">&nbsp;</td>
            <td>#0000C6</td>
            <td bgcolor="#005ab5">&nbsp;</td>
            <td>#005AB5</td>
            <td bgcolor="#009393">&nbsp;</td>
            <td>#009393</td>
            <td bgcolor="#01b468">&nbsp;</td>
            <td>#01B468</td>
            <td bgcolor="#00a600">&nbsp;</td>
            <td>#00A600</td>
        </tr>
        <tr>
            <td bgcolor="#0000e3">&nbsp;</td>
            <td>#0000E3</td>
            <td bgcolor="#0066cc">&nbsp;</td>
            <td>#0066CC</td>
            <td bgcolor="#00aeae">&nbsp;</td>
            <td>#00AEAE</td>
            <td bgcolor="#02c874">&nbsp;</td>
            <td>#02C874</td>
            <td bgcolor="#00bb00">&nbsp;</td>
            <td>#00BB00</td>
        </tr>
        <tr>
            <td bgcolor="#2828ff">&nbsp;</td>
            <td>#2828FF</td>
            <td bgcolor="#0072e3">&nbsp;</td>
            <td>#0072E3</td>
            <td bgcolor="#00caca">&nbsp;</td>
            <td>#00CACA</td>
            <td bgcolor="#02df82">&nbsp;</td>
            <td>#02DF82</td>
            <td bgcolor="#00db00">&nbsp;</td>
            <td>#00DB00</td>
        </tr>
        <tr>
            <td bgcolor="#4a4aff">&nbsp;</td>
            <td>#4A4AFF</td>
            <td bgcolor="#0080ff">&nbsp;</td>
            <td>#0080FF</td>
            <td bgcolor="#00e3e3">&nbsp;</td>
            <td>#00E3E3</td>
            <td bgcolor="#02f78e">&nbsp;</td>
            <td>#02F78E</td>
            <td bgcolor="#00ec00">&nbsp;</td>
            <td>#00EC00</td>
        </tr>
        <tr>
            <td bgcolor="#6a6aff">&nbsp;</td>
            <td>#6A6AFF</td>
            <td bgcolor="#2894ff">&nbsp;</td>
            <td>#2894FF</td>
            <td bgcolor="#00ffff">&nbsp;</td>
            <td>#00FFFF</td>
            <td bgcolor="#1afd9c">&nbsp;</td>
            <td>#1AFD9C</td>
            <td bgcolor="#28ff28">&nbsp;</td>
            <td>#28FF28</td>
        </tr>
        <tr>
            <td bgcolor="#7d7dff">&nbsp;</td>
            <td>#7D7DFF</td>
            <td bgcolor="#46a3ff">&nbsp;</td>
            <td>#46A3FF</td>
            <td bgcolor="#4dffff">&nbsp;</td>
            <td>#4DFFFF</td>
            <td bgcolor="#4efeb3">&nbsp;</td>
            <td>#4EFEB3</td>
            <td bgcolor="#53ff53">&nbsp;</td>
            <td>#53FF53</td>
        </tr>
        <tr>
            <td bgcolor="#9393ff">&nbsp;</td>
            <td>#9393FF</td>
            <td bgcolor="#66b3ff">&nbsp;</td>
            <td>#66B3FF</td>
            <td bgcolor="#80ffff">&nbsp;</td>
            <td>#80FFFF</td>
            <td bgcolor="#7afec6">&nbsp;</td>
            <td>#7AFEC6</td>
            <td bgcolor="#79ff79">&nbsp;</td>
            <td>#79FF79</td>
        </tr>
        <tr>
            <td bgcolor="#aaaaff">&nbsp;</td>
            <td>#AAAAFF</td>
            <td bgcolor="#84c1ff">&nbsp;</td>
            <td>#84C1FF</td>
            <td bgcolor="#a6ffff">&nbsp;</td>
            <td>#A6FFFF</td>
            <td bgcolor="#96fed1">&nbsp;</td>
            <td>#96FED1</td>
            <td bgcolor="#93ff93">&nbsp;</td>
            <td>#93FF93</td>
        </tr>
        <tr>
            <td bgcolor="#b9b9ff">&nbsp;</td>
            <td>#B9B9FF</td>
            <td bgcolor="#97cbff">&nbsp;</td>
            <td>#97CBFF</td>
            <td bgcolor="#bbffff">&nbsp;</td>
            <td>#BBFFFF</td>
            <td bgcolor="#adfedc">&nbsp;</td>
            <td>#ADFEDC</td>
            <td bgcolor="#a6ffa6">&nbsp;</td>
            <td>#A6FFA6</td>
        </tr>
        <tr>
            <td bgcolor="#ceceff">&nbsp;</td>
            <td>#CECEFF</td>
            <td bgcolor="#acd6ff">&nbsp;</td>
            <td>#ACD6FF</td>
            <td bgcolor="#caffff">&nbsp;</td>
            <td>#CAFFFF</td>
            <td bgcolor="#c1ffe4">&nbsp;</td>
            <td>#C1FFE4</td>
            <td bgcolor="#bbffbb">&nbsp;</td>
            <td>#BBFFBB</td>
        </tr>
        <tr>
            <td bgcolor="#ddddff">&nbsp;</td>
            <td>#DDDDFF</td>
            <td bgcolor="#c4e1ff">&nbsp;</td>
            <td>#C4E1FF</td>
            <td bgcolor="#d9ffff">&nbsp;</td>
            <td>#D9FFFF</td>
            <td bgcolor="#d7ffee">&nbsp;</td>
            <td>#D7FFEE</td>
            <td bgcolor="#ceffce">&nbsp;</td>
            <td>#CEFFCE</td>
        </tr>
        <tr>
            <td bgcolor="#ececff">&nbsp;</td>
            <td>#ECECFF</td>
            <td bgcolor="#d2e9ff">&nbsp;</td>
            <td>#D2E9FF</td>
            <td bgcolor="#ecffff">&nbsp;</td>
            <td>#ECFFFF</td>
            <td bgcolor="#e8fff5">&nbsp;</td>
            <td>#E8FFF5</td>
            <td bgcolor="#dfffdf">&nbsp;</td>
            <td>#DFFFDF</td>
        </tr>
        <tr>
            <td bgcolor="#fbfbff">&nbsp;</td>
            <td>#FBFBFF</td>
            <td bgcolor="#ecf5ff">&nbsp;</td>
            <td>#ECF5FF</td>
            <td bgcolor="#fdffff">&nbsp;</td>
            <td>#FDFFFF</td>
            <td bgcolor="#fbfffd">&nbsp;</td>
            <td>#FBFFFD</td>
            <td bgcolor="#f0fff0">&nbsp;</td>
            <td>#F0FFF0</td>
        </tr>
        <tr>
            <td bgcolor="#467500">&nbsp;</td>
            <td>#467500</td>
            <td bgcolor="#424200">&nbsp;</td>
            <td>#424200</td>
            <td bgcolor="#5b4b00">&nbsp;</td>
            <td>#5B4B00</td>
            <td bgcolor="#844200">&nbsp;</td>
            <td>#844200</td>
            <td bgcolor="#642100">&nbsp;</td>
            <td>#642100</td>
        </tr>
        <tr>
            <td bgcolor="#548c00">&nbsp;</td>
            <td>#548C00</td>
            <td bgcolor="#5b5b00">&nbsp;</td>
            <td>#5B5B00</td>
            <td bgcolor="#796400">&nbsp;</td>
            <td>#796400</td>
            <td bgcolor="#9f5000">&nbsp;</td>
            <td>#9F5000</td>
            <td bgcolor="#842b00">&nbsp;</td>
            <td>#842B00</td>
        </tr>
        <tr>
            <td bgcolor="#64a600">&nbsp;</td>
            <td>#64A600</td>
            <td bgcolor="#737300">&nbsp;</td>
            <td>#737300</td>
            <td bgcolor="#977c00">&nbsp;</td>
            <td>#977C00</td>
            <td bgcolor="#bb5e00">&nbsp;</td>
            <td>#BB5E00</td>
            <td bgcolor="#a23400">&nbsp;</td>
            <td>#A23400</td>
        </tr>
        <tr>
            <td bgcolor="#73bf00">&nbsp;</td>
            <td>#73BF00</td>
            <td bgcolor="#8c8c00">&nbsp;</td>
            <td>#8C8C00</td>
            <td bgcolor="#ae8f00">&nbsp;</td>
            <td>#AE8F00</td>
            <td bgcolor="#d26900">&nbsp;</td>
            <td>#D26900</td>
            <td bgcolor="#bb3d00">&nbsp;</td>
            <td>#BB3D00</td>
        </tr>
        <tr>
            <td bgcolor="#82d900">&nbsp;</td>
            <td>#82D900</td>
            <td bgcolor="#a6a600">&nbsp;</td>
            <td>#A6A600</td>
            <td bgcolor="#c6a300">&nbsp;</td>
            <td>#C6A300</td>
            <td bgcolor="#ea7500">&nbsp;</td>
            <td>#EA7500</td>
            <td bgcolor="#d94600">&nbsp;</td>
            <td>#D94600</td>
        </tr>
        <tr>
            <td bgcolor="#8cea00">&nbsp;</td>
            <td>#8CEA00</td>
            <td bgcolor="#c4c400">&nbsp;</td>
            <td>#C4C400</td>
            <td bgcolor="#d9b300">&nbsp;</td>
            <td>#D9B300</td>
            <td bgcolor="#ff8000">&nbsp;</td>
            <td>#FF8000</td>
            <td bgcolor="#f75000">&nbsp;</td>
            <td>#F75000</td>
        </tr>
        <tr>
            <td bgcolor="#9aff02">&nbsp;</td>
            <td>#9AFF02</td>
            <td bgcolor="#e1e100">&nbsp;</td>
            <td>#E1E100</td>
            <td bgcolor="#eac100">&nbsp;</td>
            <td>#EAC100</td>
            <td bgcolor="#ff9224">&nbsp;</td>
            <td>#FF9224</td>
            <td bgcolor="#ff5809">&nbsp;</td>
            <td>#FF5809</td>
        </tr>
        <tr>
            <td bgcolor="#a8ff24">&nbsp;</td>
            <td>#A8FF24</td>
            <td bgcolor="#f9f900">&nbsp;</td>
            <td>#F9F900</td>
            <td bgcolor="#ffd306">&nbsp;</td>
            <td>#FFD306</td>
            <td bgcolor="#ffa042">&nbsp;</td>
            <td>#FFA042</td>
            <td bgcolor="#ff8040">&nbsp;</td>
            <td>#FF8040</td>
        </tr>
        <tr>
            <td bgcolor="#b7ff4a">&nbsp;</td>
            <td>#B7FF4A</td>
            <td bgcolor="#ffff37">&nbsp;</td>
            <td>#FFFF37</td>
            <td bgcolor="#ffdc35">&nbsp;</td>
            <td>#FFDC35</td>
            <td bgcolor="#ffaf60">&nbsp;</td>
            <td>#FFAF60</td>
            <td bgcolor="#ff8f59">&nbsp;</td>
            <td>#FF8F59</td>
        </tr>
        <tr>
            <td bgcolor="#c2ff68">&nbsp;</td>
            <td>#C2FF68</td>
            <td bgcolor="#ffff6f">&nbsp;</td>
            <td>#FFFF6F</td>
            <td bgcolor="#ffe153">&nbsp;</td>
            <td>#FFE153</td>
            <td bgcolor="#ffbb77">&nbsp;</td>
            <td>#FFBB77</td>
            <td bgcolor="#ff9d6f">&nbsp;</td>
            <td>#FF9D6F</td>
        </tr>
        <tr>
            <td bgcolor="#ccff80">&nbsp;</td>
            <td>#CCFF80</td>
            <td bgcolor="#ffff93">&nbsp;</td>
            <td>#FFFF93</td>
            <td bgcolor="#ffe66f">&nbsp;</td>
            <td>#FFE66F</td>
            <td bgcolor="#ffc78e">&nbsp;</td>
            <td>#FFC78E</td>
            <td bgcolor="#ffad86">&nbsp;</td>
            <td>#FFAD86</td>
        </tr>
        <tr>
            <td bgcolor="#d3ff93">&nbsp;</td>
            <td>#D3FF93</td>
            <td bgcolor="#ffffaa">&nbsp;</td>
            <td>#FFFFAA</td>
            <td bgcolor="#ffed97">&nbsp;</td>
            <td>#FFED97</td>
            <td bgcolor="#ffd1a4">&nbsp;</td>
            <td>#FFD1A4</td>
            <td bgcolor="#ffbd9d">&nbsp;</td>
            <td>#FFBD9D</td>
        </tr>
        <tr>
            <td bgcolor="#deffac">&nbsp;</td>
            <td>#DEFFAC</td>
            <td bgcolor="#ffffb9">&nbsp;</td>
            <td>#FFFFB9</td>
            <td bgcolor="#fff0ac">&nbsp;</td>
            <td>#FFF0AC</td>
            <td bgcolor="#ffdcb9">&nbsp;</td>
            <td>#FFDCB9</td>
            <td bgcolor="#ffcbb3">&nbsp;</td>
            <td>#FFCBB3</td>
        </tr>
        <tr>
            <td bgcolor="#e8ffc4">&nbsp;</td>
            <td>#E8FFC4</td>
            <td bgcolor="#ffffce">&nbsp;</td>
            <td>#FFFFCE</td>
            <td bgcolor="#fff4c1">&nbsp;</td>
            <td>#FFF4C1</td>
            <td bgcolor="#ffe4ca">&nbsp;</td>
            <td>#FFE4CA</td>
            <td bgcolor="#ffdac8">&nbsp;</td>
            <td>#FFDAC8</td>
        </tr>
        <tr>
            <td bgcolor="#efffd7">&nbsp;</td>
            <td>#EFFFD7</td>
            <td bgcolor="#ffffdf">&nbsp;</td>
            <td>#FFFFDF</td>
            <td bgcolor="#fff8d7">&nbsp;</td>
            <td>#FFF8D7</td>
            <td bgcolor="#ffeedd">&nbsp;</td>
            <td>#FFEEDD</td>
            <td bgcolor="#ffe6d9">&nbsp;</td>
            <td>#FFE6D9</td>
        </tr>
        <tr>
            <td bgcolor="#f5ffe8">&nbsp;</td>
            <td>#F5FFE8</td>
            <td bgcolor="#fffff4">&nbsp;</td>
            <td>#FFFFF4</td>
            <td bgcolor="#fffcec">&nbsp;</td>
            <td>#FFFCEC</td>
            <td bgcolor="#fffaf4">&nbsp;</td>
            <td>#FFFAF4</td>
            <td bgcolor="#fff3ee">&nbsp;</td>
            <td>#FFF3EE</td>
        </tr>
        <tr>
            <td bgcolor="#613030">&nbsp;</td>
            <td>#613030</td>
            <td bgcolor="#616130">&nbsp;</td>
            <td>#616130</td>
            <td bgcolor="#336666">&nbsp;</td>
            <td>#336666</td>
            <td bgcolor="#484891">&nbsp;</td>
            <td>#484891</td>
            <td bgcolor="#6c3365">&nbsp;</td>
            <td>#6C3365</td>
        </tr>
        <tr>
            <td bgcolor="#743a3a">&nbsp;</td>
            <td>#743A3A</td>
            <td bgcolor="#707038">&nbsp;</td>
            <td>#707038</td>
            <td bgcolor="#3d7878">&nbsp;</td>
            <td>#3D7878</td>
            <td bgcolor="#5151a2">&nbsp;</td>
            <td>#5151A2</td>
            <td bgcolor="#7e3d76">&nbsp;</td>
            <td>#7E3D76</td>
        </tr>
        <tr>
            <td bgcolor="#804040">&nbsp;</td>
            <td>#804040</td>
            <td bgcolor="#808040">&nbsp;</td>
            <td>#808040</td>
            <td bgcolor="#408080">&nbsp;</td>
            <td>#408080</td>
            <td bgcolor="#5a5aad">&nbsp;</td>
            <td>#5A5AAD</td>
            <td bgcolor="#8f4586">&nbsp;</td>
            <td>#8F4586</td>
        </tr>
        <tr>
            <td bgcolor="#984b4b">&nbsp;</td>
            <td>#984B4B</td>
            <td bgcolor="#949449">&nbsp;</td>
            <td>#949449</td>
            <td bgcolor="#4f9d9d">&nbsp;</td>
            <td>#4F9D9D</td>
            <td bgcolor="#7373b9">&nbsp;</td>
            <td>#7373B9</td>
            <td bgcolor="#9f4d95">&nbsp;</td>
            <td>#9F4D95</td>
        </tr>
        <tr>
            <td bgcolor="#ad5a5a">&nbsp;</td>
            <td>#AD5A5A</td>
            <td bgcolor="#a5a552">&nbsp;</td>
            <td>#A5A552</td>
            <td bgcolor="#5cadad">&nbsp;</td>
            <td>#5CADAD</td>
            <td bgcolor="#8080c0">&nbsp;</td>
            <td>#8080C0</td>
            <td bgcolor="#ae57a4">&nbsp;</td>
            <td>#AE57A4</td>
        </tr>
        <tr>
            <td bgcolor="#b87070">&nbsp;</td>
            <td>#B87070</td>
            <td bgcolor="#afaf61">&nbsp;</td>
            <td>#AFAF61</td>
            <td bgcolor="#6fb7b7">&nbsp;</td>
            <td>#6FB7B7</td>
            <td bgcolor="#9999cc">&nbsp;</td>
            <td>#9999CC</td>
            <td bgcolor="#b766ad">&nbsp;</td>
            <td>#B766AD</td>
        </tr>
        <tr>
            <td bgcolor="#c48888">&nbsp;</td>
            <td>#C48888</td>
            <td bgcolor="#b9b973">&nbsp;</td>
            <td>#B9B973</td>
            <td bgcolor="#81c0c0">&nbsp;</td>
            <td>#81C0C0</td>
            <td bgcolor="#a6a6d2">&nbsp;</td>
            <td>#A6A6D2</td>
            <td bgcolor="#c07ab8">&nbsp;</td>
            <td>#C07AB8</td>
        </tr>
        <tr>
            <td bgcolor="#cf9e9e">&nbsp;</td>
            <td>#CF9E9E</td>
            <td bgcolor="#c2c287">&nbsp;</td>
            <td>#C2C287</td>
            <td bgcolor="#95caca">&nbsp;</td>
            <td>#95CACA</td>
            <td bgcolor="#b8b8dc">&nbsp;</td>
            <td>#B8B8DC</td>
            <td bgcolor="#ca8ec2">&nbsp;</td>
            <td>#CA8EC2</td>
        </tr>
        <tr>
            <td bgcolor="#d9b3b3">&nbsp;</td>
            <td>#D9B3B3</td>
            <td bgcolor="#cdcd9a">&nbsp;</td>
            <td>#CDCD9A</td>
            <td bgcolor="#a3d1d1">&nbsp;</td>
            <td>#A3D1D1</td>
            <td bgcolor="#c7c7e2">&nbsp;</td>
            <td>#C7C7E2</td>
            <td bgcolor="#d2a2cc">&nbsp;</td>
            <td>#D2A2CC</td>
        </tr>
        <tr>
            <td bgcolor="#e1c4c4">&nbsp;</td>
            <td>#E1C4C4</td>
            <td bgcolor="#d6d6ad">&nbsp;</td>
            <td>#D6D6AD</td>
            <td bgcolor="#b3d9d9">&nbsp;</td>
            <td>#B3D9D9</td>
            <td bgcolor="#d8d8eb">&nbsp;</td>
            <td>#D8D8EB</td>
            <td bgcolor="#dab1d5">&nbsp;</td>
            <td>#DAB1D5</td>
        </tr>
        <tr>
            <td bgcolor="#ebd6d6">&nbsp;</td>
            <td>#EBD6D6</td>
            <td bgcolor="#dedebe">&nbsp;</td>
            <td>#DEDEBE</td>
            <td bgcolor="#c4e1e1">&nbsp;</td>
            <td>#C4E1E1</td>
            <td bgcolor="#e6e6f2">&nbsp;</td>
            <td>#E6E6F2</td>
            <td bgcolor="#e2c2de">&nbsp;</td>
            <td>#E2C2DE</td>
        </tr>
        <tr>
            <td bgcolor="#f2e6e6">&nbsp;</td>
            <td>#F2E6E6</td>
            <td bgcolor="#e8e8d0">&nbsp;</td>
            <td>#E8E8D0</td>
            <td bgcolor="#d1e9e9">&nbsp;</td>
            <td>#D1E9E9</td>
            <td bgcolor="#f3f3fa">&nbsp;</td>
            <td>#F3F3FA</td>
            <td bgcolor="#ebd3e8">&nbsp;</td>
            <td>#EBD3E8</td>
        </tr>
    </tbody>
</table>
</div>]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法笔记</title>
    <url>/2018/02/03/2018-02-03-sorting-algorithm/</url>
    <content><![CDATA[<h2 id="关于这篇笔记"><a href="#关于这篇笔记" class="headerlink" title="关于这篇笔记"></a>关于这篇笔记</h2><p>最近做了几道比较难的leetCode题，其中一道题使用了基数排序（LeetCode-164题，另一种思路有桶排序的思想），
突然发现自己好多东西都忘记了，或者说其实从来就没有真正的学会。所以这里决定重新回到算法导论的前面再看一看排序算法。</p>
<p>这篇笔记中包含算法<code>冒泡排序</code>、<code>插入排序</code>、<code>希尔排序</code>、<code>归并排序</code>、<code>堆排序</code>、<code>快速排序</code>、<code>计数排序</code>、<code>基数排序</code>、<code>桶排序</code>。</p>
<p>代码:<a href="https://github.com/isadamu/book_algorithm/tree/master/src/sorting_algorithms">github</a></p>
<p><strong>代码的实现中均没有考虑负数，只考虑了非负数。</strong></p>
<p>参考资料：</p>
<ol>
<li>算法导论。</li>
<li><a href="http://blog.csdn.net/so_geili/article/details/53335266">算法导论———ShellSort希尔排序</a></li>
<li><a href="https://www.cnblogs.com/youzhibing/p/4889037.html">排序之希尔排序(shell sort)</a></li>
<li><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a></li>
</ol>
<hr>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是一种最为简单的排序算法，它的想法就是“比较所有相邻的数的大小，将小的放前面，大的放后面，重复这个过程”。</p>
<p>在算法执行过程中，可以看成，第一轮把最小的元素放到第一个位置，第二轮把第二小的元素放到第二个位置…重复N次。</p>
<p>在实现的时候每次可以检查是否发生交换，如何没有发生交换，就可以提前停止算法。</p>
<p>时间复杂度：$O(n^2)$</p>
<p>空间复杂度：原址（也就是$O(1)$）</p>
<p>是否稳定：是</p>
<p>是否能处理负数：是</p>
<p>代码：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( nums.length &lt; <span class="number">2</span> || begin &gt;= (end - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        begin = begin &lt; <span class="number">0</span> ? <span class="number">0</span> : begin;</span><br><span class="line">        end = end &gt; nums.length ? nums.length : end;</span><br><span class="line">        <span class="keyword">boolean</span> change;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = begin; i &lt; end; i++ ) &#123;</span><br><span class="line">            change = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = end - <span class="number">1</span>; j &gt; i; j-- ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( nums[j] &lt; nums[j-<span class="number">1</span>] ) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j-<span class="number">1</span>];</span><br><span class="line">                    nums[j-<span class="number">1</span>] = nums[j];</span><br><span class="line">                    nums[j] = tmp;</span><br><span class="line">                    change = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( !change ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序也是一种基本的排序算法，它就类似于抓牌的过程，“当抓到一张新牌时，我们会把牌按大小顺序插入到它应该在的位置上”。</p>
<p>在感觉上插入排序和冒泡排序有一些类似，它们的复杂度也是一样，但是实际上插入排序要比冒泡排序快一点。</p>
<p>时间复杂度：$O(n^2)$</p>
<p>空间复杂度：原址</p>
<p>是否稳定：是</p>
<p>是否能处理负数：是</p>
<p>代码：</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( nums.length &lt; <span class="number">2</span> || begin &gt;= (end - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        begin = begin &lt; <span class="number">0</span> ? <span class="number">0</span> : begin;</span><br><span class="line">        end = end &gt; nums.length ? nums.length : end;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = begin + <span class="number">1</span>; i &lt; end; i++ ) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = nums[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= begin &amp;&amp; A[j] &gt; key; j-- ) &#123;</span><br><span class="line">                nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j+<span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序英文为<code>Shell Sort</code>，这里的‘<strong>Shell</strong>’实际上是一个人名。</p>
<p>希尔排序是对<strong>插入排序</strong>的一种改进，它的改进想法来自于“序列越基本有序，则插入排序效率越高”：</p>
<blockquote>
<p>设想序列的最后一个数是最小的数，那么当对它进行插入时，将需要从最后的位置，一个一个向前挪到第一个，
所以这种情况如果越少发生，那么插入排序的效率也就越高。</p>
</blockquote>
<p>这里“序列的基本有序”定义就是所有的数当前位置离排序后的位置越近，就越有序。也就是大的数就在序列的后面，小的数就在序列的前面。</p>
<p>有了上面的观察，那么就要想办法先将序列变得“有序”，然后再进行插入排序。</p>
<p>具体流程可以参考<a href="http://blog.csdn.net/so_geili/article/details/53335266">算法导论———ShellSort希尔排序</a>，比较直观。</p>
<p>代码中gap选择<a href="https://oeis.org/A102549">A102549</a>，
至于gap，可以参考wiki<a href="https://en.wikipedia.org/wiki/Shellsort#Gap_sequences">Gap_sequences</a></p>
<p>时间复杂度：小于$O(n^{\frac{4}{3}})$</p>
<p>空间复杂度：原址</p>
<p>是否稳定：否</p>
<p>是否能处理负数：是</p>
<p>代码：</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( nums.length &lt; <span class="number">2</span> || begin &gt;= (end - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        begin = begin &lt; <span class="number">0</span> ? <span class="number">0</span> : begin;</span><br><span class="line">        end = end &gt; nums.length ? nums.length : end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] gaps = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">23</span>, <span class="number">57</span>, <span class="number">132</span>, <span class="number">301</span>, <span class="number">701</span>, <span class="number">1750</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> idx = gaps.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( idx &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = gaps[idx] + begin;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = start; i &lt; end; i++ ) &#123;</span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">int</span> j = i; j &gt;= start; j -= gaps[idx] ) &#123;</span><br><span class="line">                    <span class="keyword">int</span> front = j - gaps[idx];</span><br><span class="line">                    <span class="keyword">if</span> ( nums[j] &gt;= nums[front] ) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[front];</span><br><span class="line">                    nums[front] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            idx--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并是一种递归排序的方式，它每一次递归将数据均分成左右两个部分，然后两个部分分别排序，这里分别排序也就是再次调用归并排序来进行。</p>
<p>当递归到元素只剩下一个的时候，那么它当然是有序的，于是就开始返回，从下往上进行合并。</p>
<p>两个已经排好序的序列合并很简单，新建一个数组，长度等于两个序列的总长，
对比两个序列的第一个元素，每次选最小的那一个放到新数组里就行了。</p>
<p>对于复杂度为$O(n^2)$的算法，相当于序列的每一个元素都要和序列的其它所有元素比一遍，也就是每个元素要比<code>n-1</code>次，一共<code>n</code>个元素，
所以复杂度就为$O(n^2)$。</p>
<p>对于归并排序来说，它每次进行二分，所以总的深度就为$log_2(n)$，在向上合并的过程中，比较一次就可以放下一个元素，
所以每一层最多需要比较<code>n</code>次，所以算法的复杂度就降到了$nlog(n)$。</p>
<p>时间复杂度：$nlog(n)$</p>
<p>空间复杂度：$O(n)$</p>
<p>是否稳定：是</p>
<p>是否能处理负数：是</p>
<p>代码：</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( nums.length &lt; <span class="number">2</span> || begin &gt;= (end - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        begin = begin &lt; <span class="number">0</span> ? <span class="number">0</span> : begin;</span><br><span class="line">        end = end &gt; nums.length ? nums.length : end;</span><br><span class="line">        mergeSort(nums, begin, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( begin &gt;= (end - <span class="number">1</span>) ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (end + begin) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(nums, begin, mid);</span><br><span class="line">        mergeSort(nums, mid, end);</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[mid-begin], b = <span class="keyword">new</span> <span class="keyword">int</span>[end-mid];</span><br><span class="line">        System.arraycopy(nums, begin, a, <span class="number">0</span>, a.length);</span><br><span class="line">        System.arraycopy(nums, mid, b, <span class="number">0</span>, b.length);</span><br><span class="line">        <span class="keyword">int</span> idx1 = <span class="number">0</span>, idx2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = begin; i &lt; end; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( idx1 &gt;= a.length ) &#123;</span><br><span class="line">                nums[i] = b[idx2++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( idx2 &gt;= b.length || a[idx1] &lt;= b[idx2] ) &#123;</span><br><span class="line">                nums[i] = a[idx1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[i] = b[idx2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序则是利用了最大堆的性质，建立一个最大堆所需的时间复杂度为$nlog(n)$，将最大堆的最大元素取出，
填上另一个数，再维护最大堆的性质，将这个数下沉到它应该的位置，复杂度为$log(n)$。</p>
<p>所以每次将最大堆的最大元素与堆尾（数组实现最大堆）的元素进行交换，堆大小减一，维护最大堆性质，反复即可。</p>
<p>时间复杂度：$nlog(n)$</p>
<p>空间复杂度：原址</p>
<p>是否稳定：否</p>
<p>是否能处理负数：是</p>
<p>代码，实现中为了简化数组实现最大堆的过程，额外申请了空间保证从数组索引0开始：</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( nums.length &lt; <span class="number">2</span> || begin &gt;= (end - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        begin = begin &lt; <span class="number">0</span> ? <span class="number">0</span> : begin;</span><br><span class="line">        end = end &gt; nums.length ? nums.length : end;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[end-begin];</span><br><span class="line">        System.arraycopy(nums, begin, array, <span class="number">0</span>, array.length);</span><br><span class="line">        heapSort(array);</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, nums, begin, array.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        buildMaxHeap(nums);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = nums.length-<span class="number">1</span>; i &gt; <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">            nums[i] = tmp;</span><br><span class="line">            maxHeapify(nums, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] heap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = heap.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">            maxHeapify(heap, heap.length, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] heap, <span class="keyword">int</span> len, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left(i), r = right(i);</span><br><span class="line">        <span class="keyword">int</span> largest = i;</span><br><span class="line">        <span class="keyword">if</span> ( l &lt; len &amp;&amp; heap[l] &gt; heap[largest] ) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( r &lt; len &amp;&amp; heap[r] &gt; heap[largest] ) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( largest != i ) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = heap[i];</span><br><span class="line">            heap[i] = heap[largest];</span><br><span class="line">            heap[largest] = tmp;</span><br><span class="line">            maxHeapify(heap, len, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是程序员最常使用的排序算法了，它每次选择一个<strong>主元</strong>，将比主元小的元素放到左边，大的放到右边，
在左右划分中重复这个过程，直到划分中只剩下一个元素，也就完成了排序，它通常也是递归实现。</p>
<p>快速排序的最坏复杂度为$O(n^2)$，也就是每次都倒霉的选择了最大或者最小的那个元素，使得左右的划分十分的“不均匀”，
但是在期望情况下，它的复杂度为$nlog(n)$。具体的证明有一些繁琐，需要参考算法导论。</p>
<p><strong>随机化版本：</strong>如果每次主元的选择都是固定位置的，那么很容易就能造出一个使复杂度变成$O(n^2)$的序列，
这一点可能会被<strong>不怀好意</strong>的人给利用，所以通常主元的选择会引入随机化，快速排序的复杂度能不被输入序列给影响。</p>
<p>时间复杂度：$nlog(n)$</p>
<p>空间复杂度：原址</p>
<p>是否稳定：否</p>
<p>是否能处理负数：是</p>
<p>代码：</p>
<h2 id="-5"><a href="#-5" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( nums.length &lt; <span class="number">2</span> || begin &gt;= (end - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        begin = begin &lt; <span class="number">0</span> ? <span class="number">0</span> : begin;</span><br><span class="line">        end = end &gt; nums.length ? nums.length : end;</span><br><span class="line">        quickSort(nums, begin, end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( p &gt;= q ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = partition(nums, p, q);</span><br><span class="line">        <span class="keyword">if</span> ( m == -<span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(nums, p, m - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, m+<span class="number">1</span>, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        randomExchange(nums, p, q);</span><br><span class="line">        <span class="keyword">int</span> axle = nums[q];</span><br><span class="line">        <span class="keyword">int</span> j = p - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> equals_count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt; q; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; axle) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( nums[i] == axle ) &#123; </span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">                equals_count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( equals_count == nums.length ) &#123; <span class="comment">// 防止所有元素都相等时还进行递归</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">        nums[j] = nums[q];</span><br><span class="line">        nums[q] = tmp;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">randomExchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> exchange = rand.nextInt(q-p+<span class="number">1</span>) + p;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[exchange];</span><br><span class="line">        nums[exchange] = nums[q];</span><br><span class="line">        nums[q] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>假设输入的数都是非负数，它们都小于某一个数<code>N</code>，那么我们就可以额外申请一个长度为<code>N</code>的数组对输入序列进行统计，
这个数组中第<code>i</code>个位置就表示序列中大小为<code>i</code>的数的个数。于是我们就可以使用这个计数的信息，
将输入序列中数放到它应该在的位置上。</p>
<p>计数排序有一个很大的假设，就是需要提前知道数的范围，在数的范围已知并且范围不大的时候，计数排序的时间效率为$O(n)$。
但是通常情况下这两个假设都难以满足，所以计数排序用得很少。</p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n) + O(N)$</p>
<p>是否稳定：是</p>
<p>是否能处理负数：否</p>
<p>代码：</p>
<h2 id="-6"><a href="#-6" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++ ) &#123;</span><br><span class="line">            count[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k; j++ ) &#123;</span><br><span class="line">            count[j] += count[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        System.arraycopy(nums, <span class="number">0</span>, copy, <span class="number">0</span>, copy.length);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = copy.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">            nums[--count[copy[i]]] = copy[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序的基础是计数排序，由于输入是一堆十进制数，那么它的每一位就是一个十进制数，也就是范围在<code>0~9</code>，
所以就可能按照计数排序的思想，对输入序列的某一位数进行排序。神奇的是，这样从个位往高位排一遍，
序列就完成了排序。</p>
<p>基数排序同样也只能处理非负数，但是它的复杂度只为$O(n)$，虽然其中的隐藏因子有一点大，当序列很长时，
基数排序会有很大的优势。</p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n)$</p>
<p>是否稳定：是</p>
<p>是否能处理负数：否</p>
<h2 id="-7"><a href="#-7" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( nums.length &lt; <span class="number">2</span> || begin &gt;= (end - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        begin = begin &lt; <span class="number">0</span> ? <span class="number">0</span> : begin;</span><br><span class="line">        end = end &gt; nums.length ? nums.length : end;</span><br><span class="line"></span><br><span class="line">        radixSort(nums, begin, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = begin; i &lt; end; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( nums[i] &gt; max ) &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_exp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( (max / max_exp) &gt;= <span class="number">10</span> ) &#123;</span><br><span class="line">            max_exp *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[end-begin], b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length], radixs = <span class="keyword">new</span> <span class="keyword">int</span>[a.length], exchange;</span><br><span class="line">        System.arraycopy(nums, begin, a, <span class="number">0</span>, a.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> exp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( exp &lt;= max_exp ) &#123;</span><br><span class="line">            Arrays.fill(count,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                radixs[i] = (a[i] / exp) % <span class="number">10</span>;</span><br><span class="line">                count[radixs[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">                count[i] += count[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = a.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">                b[--count[radixs[i]]] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            exchange = b;</span><br><span class="line">            b = a;</span><br><span class="line">            a = exchange;</span><br><span class="line">            exp *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, nums, begin, a.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>假设输入数据的范围是N，桶排序将N划分为m个范围，也就是m个桶，将输入序列的数一个一个丢到桶里，
然后进行桶内排序，再把所有的数据串起来，就完成了排序。</p>
<p>桶排序需要知道输入数据的范围，另外一个十分重要的假设是输入序列<strong>均匀分布</strong>，这样才能保证每个桶里面的元素不会太多。</p>
<p>个人认为计数排序就是一个特殊的桶排序，也就是桶的大小为<code>1</code>的时候的桶排序。</p>
<p>桶排序中的每一个桶其实是一个链表，它的空间消耗应该是上面所有算法中最多的。</p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n)$</p>
<p>是否稳定：是</p>
<p>是否能处理负数：否</p>
<h2 id="-8"><a href="#-8" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Bucket</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = -<span class="number">1</span>;</span><br><span class="line">        Bucket front, next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bucket_num = Math.min(nums.length, bound);</span><br><span class="line">        Bucket[] buckets = <span class="keyword">new</span> Bucket[bucket_num];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket_num; i++ ) &#123;</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> Bucket();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> num : nums ) &#123;</span><br><span class="line">            insertHelper(buckets[(num*bucket_num) / bound], num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( Bucket bucket : buckets ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( bucket.next != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                bucket = bucket.next;</span><br><span class="line">                nums[idx++] = bucket.num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertHelper</span><span class="params">(Bucket bucket, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Bucket in = <span class="keyword">new</span> Bucket();</span><br><span class="line">        in.num = num;</span><br><span class="line">        <span class="keyword">while</span> ( bucket.next != <span class="keyword">null</span> &amp;&amp; bucket.next.num &lt; num ) &#123;</span><br><span class="line">            bucket = bucket.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( bucket.next == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            bucket.next = in;</span><br><span class="line">            in.front = bucket;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            in.next = bucket.next;</span><br><span class="line">            in.front = bucket;</span><br><span class="line">            bucket.next.front = in;</span><br><span class="line">            bucket.next = in;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="代码时间效率对比"><a href="#代码时间效率对比" class="headerlink" title="代码时间效率对比"></a>代码时间效率对比</h2><p>其中基于比较的排序算法：<code>冒泡排序</code>、<code>插入排序</code>、<code>希尔排序</code>、<code>归并排序</code>、<code>堆排序</code>、<code>快速排序</code>。</p>
<p>其它排序算法：<code>计数排序</code>、<code>基数排序</code>、<code>桶排序</code>。</p>
<p>由算法导论可知，基于比较的排序算法的最坏时间复杂度一定是$nlog(n)$，而另外三个算法则没有这个限制，它们的复杂度都在$O(n)$。</p>
<p>时间程序效率对比，可能会受到个人代码编写的影响带来一些偏差，但是大概没有问题：</p>
<p>其中T表示序列个数，N表示序列的最大长度（在N一下进行随机），K表示取值上界（下界默认为大于等于0）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>算法\取值</th>
<th>T=100000, N=20, K=100</th>
<th>T=100000, N=50, K=100</th>
<th>T=100000, N=50, K=200000</th>
<th>T=100000, N=100, K=200000</th>
<th>T=10000, N=1000, K=200000</th>
<th>T=1000, N=20000, K=20000</th>
<th>T=5000, N=10000, K=200000</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>26ms</td>
<td>128ms</td>
<td>133ms</td>
<td>457ms</td>
<td>2590ms</td>
<td>119063ms</td>
<td>138309ms</td>
</tr>
<tr>
<td>插入排序</td>
<td>22ms</td>
<td>51ms</td>
<td>48ms</td>
<td>124ms</td>
<td>801ms</td>
<td>29212ms</td>
<td>38779ms</td>
</tr>
<tr>
<td>希尔排序</td>
<td>22ms</td>
<td>69ms</td>
<td>67ms</td>
<td>134ms</td>
<td>239ms</td>
<td>709ms</td>
<td>1694ms</td>
</tr>
<tr>
<td>归并排序</td>
<td>64ms</td>
<td>167ms</td>
<td>161ms</td>
<td>305ms</td>
<td>375ms</td>
<td>892ms</td>
<td>2180ms</td>
</tr>
<tr>
<td>堆排序</td>
<td>25ms</td>
<td>90ms</td>
<td>84ms</td>
<td>155ms</td>
<td>242ms</td>
<td>666ms</td>
<td>1605ms</td>
</tr>
<tr>
<td>快速排序</td>
<td>38ms</td>
<td>93ms</td>
<td>87ms</td>
<td>145ms</td>
<td>193ms</td>
<td>519ms</td>
<td>1201ms</td>
</tr>
<tr>
<td>计数排序</td>
<td>32ms</td>
<td>30ms</td>
<td>10828ms</td>
<td>10633ms</td>
<td>1301ms</td>
<td>79ms</td>
<td>760ms</td>
</tr>
<tr>
<td>基数排序</td>
<td>35ms</td>
<td>46ms</td>
<td>99ms</td>
<td>172ms</td>
<td>146ms</td>
<td>237ms</td>
<td>689ms</td>
</tr>
<tr>
<td>桶排序</td>
<td>44ms</td>
<td>68ms</td>
<td>66ms</td>
<td>129ms</td>
<td>125ms</td>
<td>280ms</td>
<td>688ms</td>
</tr>
</tbody>
</table>
</div>
<p>值得关注的点：</p>
<ol>
<li>计数排序再取值范围与序列长度差距不大的情况下速度爆炸快。</li>
<li>基数排序平均来看是最快的，当然不能有非负数。</li>
<li>快速排序的稳定性是最好的。</li>
<li>插入排序在序列较短的情况下效率非常高。</li>
</ol>
<p><strong>快速排序</strong>作为最火的排序算法不是没有道理的，它有几点优势：速度快且稳定，$O(1)$的额外空间，能够处理负数。</p>
<p><strong>特殊</strong>情况下，计数排序会十分有用。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>实验室深度学习服务器选型</title>
    <url>/2018/03/08/2018-03-08-deep_learning_server_choosing/</url>
    <content><![CDATA[<p>这一篇笔记主要是对实验室服务器选型的一些调研。</p>
<p>当然，其中的很多知识也许在自己以后的装机岁月中会用到。</p>
<p>（目前忽略AMD，毕竟没有接触过，也不是主流）</p>
<hr>
<h2 id="服务器目标"><a href="#服务器目标" class="headerlink" title="服务器目标"></a>服务器目标</h2><p>服务器需要扮演的角色有：</p>
<ol>
<li>作为云化环境下的低层资源。</li>
<li>提供GPU计算能力给深度学习或者其他科学计算。</li>
</ol>
<hr>
<h2 id="硬件列表"><a href="#硬件列表" class="headerlink" title="硬件列表"></a>硬件列表</h2><p>首先，要作为一台PC，它的组成部分至少有，机箱、主板、CPU、内存、硬盘、电源和CPU散热器。</p>
<p>其次，作为需要提供GPU计算能力的服务器，那么它就需要GPU硬件。</p>
<ul>
<li>机箱</li>
<li>主板</li>
<li>CPU</li>
<li>GPU</li>
<li>内存</li>
<li>硬盘</li>
<li>电源</li>
<li>CPU散热</li>
</ul>
<p>下面，一个一个硬件的来记录调研的信息以及一些自己的理解。</p>
<p>首先可以参考一下<a href="http://timdettmers.com/2015/03/09/deep-learning-hardware-guide/">A Full Hardware Guide to Deep Learning-Tim Dettmers</a>，
其中比较详细的说了各个部分的问题。</p>
<hr>
<h2 id="PCIe"><a href="#PCIe" class="headerlink" title="PCIe"></a>PCIe</h2><p>首先，还是需要先了解一下PCIe通道，在主板、CPU、GPU的参数说明中通常会看到它，
在平常自己攒机的硬件选择时，通常都不用考虑它，因为你不会上多个GPU，但是一旦考虑到要装多个GPU的情景，
最好还是要了解一下。</p>
<p>PCI-Express (peripheral component interconnect express)，它是一种高速串行计算机扩展总线标准，
PCIe属于高速串行点对点双通道高带宽传输，所连接的设备分配独享通道带宽，不共享总线带宽，
主要支持主动电源管理，错误报告，端对端的可靠性传输，热插拔以及服务质量(QOS)等功能。</p>
<p>目前一般都是PCIe 3.0，下面的表来自百度百科：</p>
<table log-set-param="table_view" width="658" data-sort="sortDisabled"><tbody><tr><td width="101" align="center" valign="top" colspan="1" rowspan="2">PCI Express 版本</td><td width="70" align="center" valign="top" colspan="1" rowspan="2">行代码</td><td width="83" align="center" valign="top" colspan="1" rowspan="2">传输速率</td><td align="center" valign="top" colspan="4" rowspan="1">吞吐量</td></tr><tr><td width="102" align="center" valign="top" colspan="1" rowspan="1">×1</td><td width="102" align="center" valign="top" colspan="1" rowspan="1">×4</td><td width="103" align="center" valign="top" colspan="1" rowspan="1">×8</td><td width="101" align="center" valign="top" colspan="1" rowspan="1">×16</td></tr><tr><td width="70" align="center" valign="top">1.0</td><td width="83" align="center" valign="top">8b/10b</td><td width="96" align="center" valign="top">2.5<a target="_blank" href="/item/GT">GT</a>/s</td><td width="102" align="center" valign="top">250<a target="_blank" href="/item/MB">MB</a>/s</td><td width="102" align="center" valign="top">1<a target="_blank" href="/item/GB">GB</a>/s</td><td width="103" align="center" valign="top">2GB/s</td><td width="101" align="center" valign="top">4GB/s</td></tr><tr><td width="70" align="center" valign="top">2.0</td><td width="83" align="center" valign="top">8b/10b</td><td width="96" align="center" valign="top">5GT/s</td><td width="102" align="center" valign="top">500MB/s</td><td width="102" align="center" valign="top">2GB/s</td><td width="103" align="center" valign="top">4GB/s</td><td width="101" align="center" valign="top">8GB/s</td></tr><tr><td width="70" align="center" valign="top">3.0</td><td width="83" align="center" valign="top">128b/130b</td><td width="96" align="center" valign="top">8GT/s</td><td width="102" align="center" valign="top">984.6MB/s</td><td width="102" align="center" valign="top">3.938GB/s</td><td width="103" align="center" valign="top">7.877GB/s</td><td width="101" align="center" valign="top">15.754GB/s</td></tr><tr><td width="70" align="center" valign="top">4.0</td><td width="83" align="center" valign="top">128b/130b</td><td width="96" align="center" valign="top">16GT/s</td><td width="102" align="center" valign="top">1.969GB/s</td><td width="102" align="center" valign="top">7.877GB/s</td><td width="103" align="center" valign="top">15.754GB/s</td><td width="101" align="center" valign="top">31.508GB/s</td></tr><tr><td width="70" align="center" valign="top">5.0</td><td width="83" align="center" valign="top">128b/130b</td><td width="96" align="center" valign="top">32 or 25GT/s</td><td width="102" align="center" valign="top">3.9 or 3.08GB/s</td><td width="102" align="center" valign="top">15.8 or 12.3GB/s</td><td width="103" align="center" valign="top">31.5 or 24.6GB/s</td><td align="center" valign="top">63.0 or 49.2GB/s</td></tr></tbody></table>

<p>可以看到3.0单通道的传输速率为984.6MB/s。</p>
<p>简单说一下984.6MB/s是怎么和前面参数联系在一起的：</p>
<blockquote>
<p>这里的<code>行代码</code>为<code>128b/130b</code>，意思就是传输的<code>130bit</code>中有<code>128bit</code>是实际传输的数据，其中的<code>2bit</code>可能是附带的信息位什么的，
<code>传输速率</code>为<code>8GT/s</code>，意思是传输能力为<code>8Gbps</code>（我是这样理解的），注意到<code>Gbps</code>表示<code>1000兆比特</code>，所以：</p>
</blockquote>
<script type="math/tex; mode=display">
吞吐量 = \frac{8000 * 128}{130 * 8} =  984.6MB/s</script><p>通常，主板参数中会显示它的PCIe通道数，这表示它所能最大支持的通道数，其实就是PCIe插槽<strong>插满</strong>的通道数，
要注意到，PCIe插槽的长度并不固定，如下图所示：</p>
<div align="center"><img src="/images/guide/pcie.png"
style="zoom:50%" title="×4,×16,×1,×16,Conventional PCI. from Wikipedia" /></div>

<p>CPU的PCIe通道数表示CPU所包含的通道数，也就是CPU能够提供的PCIe通道数量，即使主板上有再多的PCIe插槽，
CPU的PCIe通道数不够也没用（这里不准确，可能主板支持PCIe扩展，但那好像也不能根本性解决问题）。</p>
<p>GPU的通道数表示GPU所需要使用的通道数，同时也表示插上它需要多大的PCIe插槽，通常都是x16的。
要注意到在PCIe3.0的时代，在深度学习方面，通常x16的通道GPU是用不完的，或许x8就已经足够了，
当然，如果PCIe通道能够完全满足是最好的。</p>
<p>PS：如果一颗CPU有<code>40</code>个PCIe通道，插入两块GPU是能够满足的，也就是<code>16 + 16</code>，如果插上3块GPU，
一般变成<code>16 + 8 + 8</code>，插上四块GPU时变成<code>8 + 8 + 8 + 8</code>。</p>
<p><strong>另外</strong>，PCIe通道不只是GPU能用，例如高端的固态硬盘使用的就是PCIe通道。</p>
<p>总结一下，也就两个问题：</p>
<ol>
<li>主板的PCIe插槽要够。</li>
<li>CPU能提供的PCIe通道要够。</li>
</ol>
<hr>
<h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>主板的选择主要考虑的点：</p>
<ol>
<li>PCIe插槽数，能否插下四张GPU。</li>
<li>CPU槽数，是否要插两个CPU。</li>
<li>最大内存容量。这个看实际的需求来选择即可。</li>
</ol>
<p>这里先说一说<strong>单CPU</strong>的主板选择：</p>
<p>大部分人的选择都是<code>华硕X99-E WS</code>，因为它支持<code>7×PCI-E X16显卡插槽</code>。</p>
<div align="center"><img src="/images/guide/华硕X99-E WS.png"
style="zoom:50%" title="华硕X99-E WS , from zol" /></div>


<p>也就是它有7个插槽，所以它能够插下4张GPU（并不是有多少插槽就能插多少张GPU，事实上空间不足导致有的插槽不能再插）。
如果考虑可能会插到4张GPU的话，这张板子会是不错的选择。</p>
<p>但是，考虑到机器并不光是提供深度学习计算能力，还要有足够的CPU资源来进行虚拟化，所以可能需要选择到两路CPU。</p>
<p>一旦扯到两路CPU，感觉就像进入了一个另外的领域似的，因为支持两路CPU的都是服务器主板，资料也不多，非常复杂。</p>
<p>目前一般自己组机的话推荐使用 C612 芯片组的板子，支持两路CPU，PCIe插槽也多。</p>
<div align="center"><img src="/images/guide/X10DRG-Q.png"
style="zoom:80%" title="超微X10DRG-Q, from taobao" /></div>

<p>总之主板这方面的知识目前还是非常的欠缺…</p>
<p>对于华硕主板的详细参数可以去华硕官网查看，<a href="https://www.asus.com.cn/">asus.com</a>，
另外<a href="https://www.supermicro.org.cn/index.cfm">supermicro.org</a>可以查到大部分主板的参数。</p>
<h3 id="内存插槽数-通道数："><a href="#内存插槽数-通道数：" class="headerlink" title="内存插槽数/通道数："></a>内存插槽数/通道数：</h3><p>考虑到内存的扩展性，自然需要考虑内存通道数量的问题。</p>
<p>内存通道这个概念很容易混淆，可以参考：</p>
<p><a href="https://www.zhihu.com/question/35625981">双通道内存有什么优点和缺点？-知乎</a></p>
<p><a href="https://www.zhihu.com/question/24510314?sort=created">为什么只支持双通道内存的主板会配四个内存插槽？-知乎</a></p>
<p>简单来说，现在的主板大多支持双通道，比较好的主板（例如x99，服务器主板）会可能支持到四通道（也有支持三通道的主板，但是很少见）。
那么只支持双通道但是有四个内存插槽的板子什么意思？十分简单的来说，就是一个通道可以插两块内存，
当两块内存插在同一个通道上的时候，它只是容量叠加，当两个通道分别插上一块或两块内存的时候，才会开启双通道。
也就是两个通道，每个通道两个插槽，自然就是四个插槽。</p>
<hr>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU的选择主要考虑两点：</p>
<ol>
<li>核心数，核心数越多并行能力就越强。</li>
<li>PCIe通道数，目前单颗CPU最多的能够支持到<strong>40</strong>个通道。</li>
<li>最大支持内存。</li>
</ol>
<p><strong>对于单CPU的选择</strong>，就没什么要求，看它够不够<strong>40</strong>个通道，然后才是频率与核心数量，
如果不考虑并行，在运行深度学习模型的时候，其实只使用了CPU单核心，因为大部分计算工作都是GPU做了，
CPU没有太大的任务，所以通常CPU核心数不关键，频率也不是很关键，不要太低就行了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>型号</th>
<th>核心数</th>
<th>PCIe通道数</th>
<th>最大内存支持</th>
<th>ECC内存支持</th>
</tr>
</thead>
<tbody>
<tr>
<td>i7-6850k</td>
<td>6核12线程</td>
<td>PCIe通道数40</td>
<td>最大内存支持128G</td>
<td>不支持ECC内存</td>
</tr>
<tr>
<td>i7-7800x</td>
<td>6核12线程</td>
<td>PCIe通道数28</td>
<td>最大内存支持128G</td>
<td>不支持ECC内存</td>
</tr>
<tr>
<td>E5-2620 v3</td>
<td>6核12线程</td>
<td>PCIe通道数40</td>
<td>最大内存支持768G</td>
<td>支持ECC内存</td>
</tr>
</tbody>
</table>
</div>
<p><strong>对于双路CPU来说</strong>，那都是E3/E5，这个通常也不用怎么考虑，选两个通道数够的，频率别太低的就行。</p>
<p>Intel的CPU参数查询可以去官网：<a href="https://ark.intel.com/zh-cn">intel.com</a>。</p>
<div align="center"><img src="/images/guide/i7-6850K.png"
style="zoom:50%" title="i7-6850K, from JD" /></div>

<hr>
<h2 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h2><p>对于选择GPU主要需要考虑的点：</p>
<ol>
<li>价格。毕竟GPU可能是整台主机最贵的硬件，一般还是要掂量掂量。</li>
<li>深度学习的计算能力。时间也是金钱。</li>
</ol>
<p>直接推荐阅读：</p>
<p><a href="https://blog.slavv.com/picking-a-gpu-for-deep-learning-3d4795c273b9">Picking a GPU for Deep Learning-Slav Ivanov</a></p>
<p><a href="http://timdettmers.com/2017/04/09/which-gpu-for-deep-learning/">Which GPU(s) to Get for Deep Learning: My Experience and Advice for Using GPUs in Deep Learning-Tim Dettmers</a></p>
<p>这里面讲了很多关于深度学习GPU选择的问题。</p>
<h3 id="AMD还是NVIDIA"><a href="#AMD还是NVIDIA" class="headerlink" title="AMD还是NVIDIA"></a>AMD还是NVIDIA</h3><p>在深度学习这个方面，目前不用考虑AMD。</p>
<h3 id="NVIDIA显卡的选择"><a href="#NVIDIA显卡的选择" class="headerlink" title="NVIDIA显卡的选择"></a>NVIDIA显卡的选择</h3><p>首先，所选择的型号需要支持<code>CUDA</code>，支持列表<a href="https://developer.nvidia.com/cuda-gpus">CUDA GPUs</a>。
深度学习需要用到<a href="https://developer.nvidia.com/cudnn">cuDNN</a>库，那么自然需要显卡支持<code>CUDA</code>。</p>
<p>另外，由于NVIDIA在10系列的显卡上发了力，这一代的提升完全是突破式的，导致在深度学习的机器门槛低了很多，
<code>1080</code>、<code>1080Ti</code>、<code>TITAN Xp</code>这些桌面用户级显卡现在也完全可以胜任深度学习的计算，
比起老架构的计算卡甚至可以快出很多倍。</p>
<div align="center"><img src="/images/guide/1080Ti.png"
style="zoom:70%" title="1080Ti, from NVIDIA" /></div>

<p>来看一看1080Ti与K80的比较：</p>
<div align="center"><img src="/images/guide/1080Ti VS K80.png"
style="zoom:70%" title="1080Ti VS K80, from Slav Ivanov" /></div>

<p>从上图中，大概可以估计1080Ti比K80在深度学习模型的训练上，要快4倍以上。（那么K80之类的计算卡现在还有什么竞争力？这里需要注意到计算卡是双精度的，但是1080Ti之类的是单精度的，但是在很多需要计算的领域，包括深度学习，只需要单精度就够了。）</p>
<p>正是由于10系列显卡的发力，所以现在很多人以及实验室都会自己组装深度学习的工作站，因为这实在比直接买带计算卡的服务器便宜多了。</p>
<h3 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h3><p>以2018年3月11日网上的价格为例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>型号</th>
<th>品牌</th>
<th>价格</th>
<th>网站</th>
</tr>
</thead>
<tbody>
<tr>
<td>1080</td>
<td>公版</td>
<td>$989.99</td>
<td>亚马逊</td>
</tr>
<tr>
<td>1080Ti</td>
<td>公版</td>
<td>￥10350.00</td>
<td>京东</td>
</tr>
<tr>
<td>TITAN Xp</td>
<td>公版</td>
<td>￥11999.00</td>
<td>京东</td>
</tr>
<tr>
<td>TITAN V</td>
<td>公版</td>
<td>￥26688.00</td>
<td>京东</td>
</tr>
<tr>
<td>K80</td>
<td>公版</td>
<td>$2298.00</td>
<td>亚马逊</td>
</tr>
<tr>
<td>P6000</td>
<td>公版</td>
<td>$4,669.00</td>
<td>亚马逊</td>
</tr>
</tbody>
</table>
</div>
<p>ps：价格都是随意看的，可能不准确，同时亚马逊到国内还有关税没有考虑。</p>
<p>之前<code>1080Ti</code>性价比是最高的，因为那时公版<code>1080Ti</code>也就5000~6000人民币，现在涨了快一倍，
感觉<code>TITAN Xp</code>也可以考虑了。当然，怎么都比计算卡性价比高。</p>
<hr>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>对于深度学习来说，内存其实并不重要，实际上训练数据都会读入到显存里面，
大部分装机建议内存至少要大于显存（显卡的内存总和），因为GPU显存大小并不大（以<code>TITAN X</code>为例，它的显存只有12G，也就是插4张也才48G显存，这时候64G的内存也是足够了）。</p>
<p>对于单CPU的主板来说，因为是大多是消费级，也基本不用至强CPU（不是所有主板都能插至强系列），所以基本不能使用ECC内存，
所以通常就直接考虑平常常见的内存就行，海盗船、金士顿、芝奇等的DDR4都可以。</p>
<div align="center"><img src="/images/guide/海盗船复仇者LPX DDR4 3000 32GB.png"
style="zoom:50%" title="海盗船复仇者LPX DDR4 3000 32GB, from JD" /></div>


<p>对于双路CPU的主板来说，一般都要使用服务器内存，也就是带ECC功能的内存，同时为了良好的扩展性，
最好是RDIMMs的（LRDIMMs更好），相关可以参考：</p>
<p><a href="https://baike.baidu.com/item/ECC%E5%86%85%E5%AD%98/1691343?fr=aladdin">ECC内存-百度百科</a></p>
<p><a href="https://www.anandtech.com/show/6068/lrdimms-rdimms-supermicros-latest-twin/2">LRDIMMs, RDIMMs, and Supermicro’s Latest Twin-AnandTech</a></p>
<p>另外简单说一下，对带有ECC的内存，还有一种是RECC内存（<code>Reg ECC</code>），它多比纯ECC内存要多带了一个<code>Register</code>，
它起到扩大内存容量的作用。</p>
<p>具体怎么选择，凭我的知识说不好。</p>
<div align="center"><img src="/images/guide/金士顿(Kingston)DDR4 2133 32G RECC.png"
style="zoom:50%" title="金士顿(Kingston)DDR4 2133 32G RECC, from JD" /></div>

<p><strong>————分割线————</strong></p>
<p>下面首先<strong>十分推荐阅读</strong><a href="https://zhuanlan.zhihu.com/p/26255460">内存系列一：快速读懂内存条标签-老狼</a>，
写得很好。</p>
<h3 id="内存条长短"><a href="#内存条长短" class="headerlink" title="内存条长短"></a>内存条长短</h3><p>内存条有好几种长度，也就是不同的插槽类型，这个需要与主板相匹配。</p>
<h3 id="内存频率："><a href="#内存频率：" class="headerlink" title="内存频率："></a>内存频率：</h3><p>内存频率类似于CPU频率，频率越高也运行越快，<strong>但是在内存的频率选择时，需要按主板的内存频率支持来选</strong>。</p>
<h3 id="内存容量："><a href="#内存容量：" class="headerlink" title="内存容量："></a>内存容量：</h3><p>内存容量都是2的次方的大小，平常PC使用的一般是4G或者8G的大小，但也有单条16G、32G的大小。</p>
<hr>
<h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>首先这里<strong>不讨论固态盘</strong>，硬盘的选择需要考虑下列问题：</p>
<ol>
<li>容量。</li>
<li>速度。</li>
</ol>
<p>首先，需要注意到PC硬盘的定位是有好几种的，最简单的，看硬盘颜色，
分为<strong>黑盘、蓝盘、绿盘、红盘、紫盘等</strong>，关于它们之间的区别，看一个小科普就好：</p>
<p><a href="http://www.sohu.com/a/168141788_524654">你知道电脑硬盘有几种颜色吗？有哪些用途及如何选用你知道吗？-sohu</a></p>
<p>至于选哪种硬盘，个人使用蓝盘就够了，要好一点就用企业级的。</p>
<p>然后简单的知道硬盘还有两种接口就行，SAS和SATA。</p>
<div align="center"><img src="/images/guide/西部数据(WD)红盘.png"
style="zoom:50%" title="西部数据(WD)红盘, from JD" /></div>

<hr>
<h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><ol>
<li>功率大小。</li>
<li>价格。</li>
</ol>
<p>首先，对于功率大小，就是要保证电源能够提供给各个部件足够的功率，功率计算网站：</p>
<p><a href="https://outervision.com/power-supply-calculator">OuterVision® Power Supply Calculator</a></p>
<p>电源功率一定不能选小了，否则就会很尴尬，而且还要考虑到多个显卡扩展的情况，</p>
<p>如果考虑到4显卡扩展，可能至少需要一个1600w的电源。</p>
<p>至于价格，一般情况下当然是电源越好，价格越高，考虑到可能不间断运行，在电源上就一定要舍得，
并且电源价格实际上也不算太高。</p>
<div align="center"><img src="/images/guide/EVGA 额定1600w 1600T2电源.png"
style="zoom:50%" title="EVGA 额定1600w 1600T2电源, from JD" /></div>

<hr>
<h2 id="CPU散热"><a href="#CPU散热" class="headerlink" title="CPU散热"></a>CPU散热</h2><ol>
<li>水冷：冷却效果好，安静，好看，但是可能漏液，导致BOOM。</li>
<li>风冷：冷却效果比不上水冷，声音稍大，安全性较好。</li>
</ol>
<p>这个就看个人喜好了，如果是实验室，当然还是风冷稳一点，品牌一般推荐猫头鹰。</p>
<div align="center"><img src="/images/guide/猫头鹰NH-D15.png"
style="zoom:50%" title="猫头鹰NH-D15, from JD" /></div>

<hr>
<h2 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h2><p>机箱的选择可能会简单一点，也就是要一个足够大的机箱，能够放下主板以及其它的硬件就好了。</p>
<p>如果是机房统一管理放置的情况下，一般都是机架式或刀片服务器，可以插在机架上，占用空间少，放便管理。
但是这类服务器机箱一般比较小，放不下普通消费级显卡。所以在这种情况下一般考虑塔式机箱，
也就类似平常PC机的主机。</p>
<p>对于个人组装单CPU型的，一般推荐海盗船AIR540。对于双CPU型的，不知道能否装下主板，
这可以在购买时咨询店家。</p>
<div align="center"><img src="/images/guide/海盗船AIR540.png"
style="zoom:50%" title="海盗船AIR540, from JD" /></div>

<p>双CPU所需的机箱不太清楚，可以在购买时询问一下店家。</p>
<hr>
<h2 id="最终建议"><a href="#最终建议" class="headerlink" title="最终建议"></a>最终建议</h2><p>如果是单CPU的深度学习工作站，那完全可以自己买配件组装：</p>
<ol>
<li>组装过程十分简单。即使没有装过，看看教程也能学会。</li>
<li>过程很有意思。</li>
<li>对于每天接触电脑的人来说，这些知识也算生活技能了。</li>
</ol>
<p>但是如果是双CPU，服务器主板，不太建议自己组装（可以买别的商家组好的），主要是：</p>
<ol>
<li>各个配件不熟。</li>
<li>配件不好买。</li>
<li>商家组好的那种也不算太坑，并且可以询问商家定制化配置，出了问题也好处理。</li>
</ol>
<hr>
<h2 id="所有参考资料"><a href="#所有参考资料" class="headerlink" title="所有参考资料"></a>所有参考资料</h2><p><a href="https://www.zhihu.com/question/33996159">如何配置一台适用于深度学习的工作站？-知乎</a></p>
<p><a href="http://timdettmers.com/2015/03/09/deep-learning-hardware-guide/">A Full Hardware Guide to Deep Learning-Tim Dettmers</a></p>
<p><a href="https://developer.nvidia.com/devbox">NVIDIA® DIGITS™ DevBox-NVIDIA</a></p>
<p><a href="https://superuser.com/questions/843344/what-is-a-pci-express-lane">What is a PCI-Express Lane?-superuser</a></p>
<p><a href="https://baike.baidu.com/item/pcie/2167538?fr=aladdin">pcie-百度百科</a></p>
<p><a href="http://blog.csdn.net/s_sunnyy/article/details/79027379">PCIe传输速率和可用带宽（吞吐量）计算-CSDN</a></p>
<p><a href="https://baike.baidu.com/item/ECC%E5%86%85%E5%AD%98/1691343?fr=aladdin">ECC内存-百度百科</a></p>
<p><a href="https://www.anandtech.com/show/6068/lrdimms-rdimms-supermicros-latest-twin/2">LRDIMMs, RDIMMs, and Supermicro’s Latest Twin-AnandTech</a></p>
<p><a href="https://www.zhihu.com/question/35625981">双通道内存有什么优点和缺点？-知乎</a></p>
<p><a href="https://www.zhihu.com/question/24510314?sort=created">为什么只支持双通道内存的主板会配四个内存插槽？-知乎</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/26255460">内存系列一：快速读懂内存条标签-老狼</a></p>
<p><a href="https://blog.slavv.com/picking-a-gpu-for-deep-learning-3d4795c273b9">Picking a GPU for Deep Learning-Slav Ivanov</a></p>
<p><a href="http://timdettmers.com/2017/04/09/which-gpu-for-deep-learning/">Which GPU(s) to Get for Deep Learning: My Experience and Advice for Using GPUs in Deep Learning-Tim Dettmers</a></p>
<p><a href="http://www.sohu.com/a/168141788_524654">你知道电脑硬盘有几种颜色吗？有哪些用途及如何选用你知道吗？-sohu</a></p>
]]></content>
      <categories>
        <category>guide</category>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>guide</tag>
      </tags>
  </entry>
  <entry>
    <title>2018华为软件精英挑战赛总结</title>
    <url>/2018/05/10/2018-05-10-hwrj-2018/</url>
    <content><![CDATA[<hr>
<p><a href="https://github.com/isadamu/2018-codecraft">github地址</a></p>
<p>总结一下自己2018年参见华为软挑的心里历程吧。</p>
<p>自己连续两年参加华为软挑，都止步于区域复赛，去年第9，今年第10。</p>
<p>第一年水平不够，第二年时间不够（当然主要是自己水平不够），也是有一点遗憾吧。
当然，自己参赛的目标就是进入复赛，所以也还好了。</p>
<p>下面内容分为初赛和复赛，但是预测部分单独拿出来，因为它前后的思路没有太大变化。</p>
<hr>
<h1 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h1><hr>
<h2 id="比赛题目"><a href="#比赛题目" class="headerlink" title="比赛题目"></a>比赛题目</h2><p><a href="http://codecraft.devcloud.huaweicloud.com/home/detail">赛事页面</a></p>
<blockquote>
<p>由于租户对ECS实例(虚拟机,VM)请求的行为具有一定规律,可以通过对历史ECS实例请求的分析,预测到未来一段时间的ECS实例请求,然后对预测的请求分配资源,这样可以
找到一个接近最优的分配策略,实现资源最大化利用,同时也能参考预测的结果制定云数据中心的建设计划。</p>
</blockquote>
<p>赛题分为两个部分，一个是虚拟机数量预测，一个是虚拟机最优化部署。</p>
<p>具体来说就是：</p>
<ol>
<li>一个数据中心的场景。</li>
<li>数据中心现在的业务是向客户出租虚拟机。</li>
<li>客户有多种规格的虚拟机可以选择。</li>
<li>出租虚拟机有一定的规律。</li>
<li>如果能够预测到未来一段时间需要出租的虚拟机，就可以提前针对进行部署。</li>
</ol>
<p>上面就是虚拟机数量预测的部分。</p>
<p>部署部分：</p>
<ol>
<li>有一堆虚拟机（多种不同规格）需要部署。</li>
<li>有不同规格的物理机提供挑选，使用数量没有限制。</li>
<li>主要考量两个资源维度，CPU以及内存。</li>
<li>假如考量的是CPU，那么，利用率为<code>虚拟机总CPU / 使用的物理机总CPU</code>。</li>
</ol>
<p>这一部分就是最优化部署部分。</p>
<p><strong>虚拟机规格：</strong>(题目中定死)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flavor1 1 1024</span><br><span class="line">flavor2 1 2048</span><br><span class="line">flavor3 1 4096</span><br><span class="line">flavor4 2 2048</span><br><span class="line">flavor5 2 4096</span><br><span class="line">flavor6 2 8192</span><br><span class="line">flavor7 4 4096</span><br><span class="line">flavor8 4 8192</span><br><span class="line">flavor9 4 16384</span><br><span class="line">flavor10 8 8192</span><br><span class="line">flavor11 8 16384</span><br><span class="line">flavor12 8 32768</span><br><span class="line">flavor13 16 16384</span><br><span class="line">flavor14 16 32768</span><br><span class="line">flavor15 16 65536</span><br></pre></td></tr></table></figure>
<p><strong>输入样例，分为train.txt和input.txt:</strong></p>
<p><code>train.txt</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">565f3813-9c5f	flavor6	2015-12-01 00:17:03</span><br><span class="line">565f3814-baad	flavor1	2015-12-01 01:14:34</span><br><span class="line">565f3815-a015	flavor9	2015-12-01 01:18:12</span><br><span class="line">565f3816-894d	flavor4	2015-12-01 08:05:41</span><br><span class="line">565f3817-b641	flavor2	2015-12-01 08:40:44</span><br><span class="line">565f3818-9c59	flavor2	2015-12-01 10:54:25</span><br><span class="line">565f3819-a5ba	flavor2	2015-12-01 10:54:28</span><br><span class="line">565f381a-bc52	flavor2	2015-12-01 10:54:28</span><br><span class="line">565f381b-be68	flavor2	2015-12-01 10:54:31</span><br><span class="line">565f381c-8308	flavor2	2015-12-01 15:38:31</span><br><span class="line">565f381d-aeb8	flavor1	2015-12-01 16:22:30</span><br><span class="line">565f381e-bbd7	flavor8	2015-12-01 17:38:09</span><br></pre></td></tr></table></figure>
<p>每一行就是在某个时间，有客户在某个时间租借了某个规格的虚拟机。</p>
<p>注意，可能规格会出现<code>flavor20</code>等情况，需自行处理。</p>
<p><code>input.txt</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">56 128 1200</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">flavor5 2 4096</span><br><span class="line">flavor10 8 8192</span><br><span class="line">flavor15 16 65536</span><br><span class="line"></span><br><span class="line">CPU</span><br><span class="line"></span><br><span class="line">2016-01-25 00:00:00</span><br><span class="line">2016-02-01 00:00:00</span><br></pre></td></tr></table></figure>
<p>第一行表示物理机的规格(CPU 内存 硬盘)，当然硬盘在本次比赛中就不需要考虑。</p>
<p>第二部分是需要预测的虚拟机，主要信息是哪几种规格的虚拟机需要预测，后面带的是虚拟机的cpu和内存（MB），
当然，这个规格信息也是多余的，因为这都是题目固定的规格。</p>
<p>这里的<code>CPU</code>就代表部署时考量<code>CPU</code>。</p>
<p>最后两个日期是需要预测的时间段。（一定会挨着最后的历史数据日期，时间段小于两周）</p>
<p><strong>输出样例，:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">flavor5  3</span><br><span class="line">flavor10  2</span><br><span class="line">flavor15  1</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">1  flavor5  2</span><br><span class="line">2  flavor5  1  flavor10  1</span><br><span class="line">3  flavor15  1</span><br><span class="line">4  flavor10  1</span><br></pre></td></tr></table></figure>
<p>第一部分，一共6台虚拟机，需要预测的规格每种各是多少（为0也要写）。</p>
<p>第二部分，使用4台物理机，怎么放。</p>
<p><strong>评分公式：</strong></p>
<p><img src="/images/competition/hwrj-2018_1.png" alt="score" title="score"></p>
<p>也就是预测部分要准确，部署部分最优化，才能达到比较高的分数。</p>
<hr>
<h2 id="部署部分思路"><a href="#部署部分思路" class="headerlink" title="部署部分思路"></a>部署部分思路</h2><p>先说部署部分，这一部分比较好说一点。</p>
<p>先看公式，利用率为<code>虚拟机总CPU / 使用的物理机总CPU</code>。</p>
<ol>
<li>在预测完毕之后，实际上虚拟机的数量和规格都确定了，那么分子实际上就确定了。</li>
<li>分母的大小和使用物理机总数有关。</li>
</ol>
<p>看上面两点可以发现，真正的目标其实是使用最少的物理机来进行部署，和分子大小无关，
所以究竟是考虑CPU还是内存，其实都是一样的优化目标，解出来的答案都是一样的。</p>
<p>那么，这个问题就变成了<strong>有一堆东西需要用背包装，使用背包个数越少越好</strong>，一想就是个背包问题，
当然，背包问题是问<strong>一个背包能装多少东西</strong>，这里是使用最少的背包来装东西，所以还是不太一样。</p>
<p>这里实际上应该是一个<strong>装箱问题</strong>，瞬间变成了一个<strong>NP难</strong>问题，只能使用近似解法来求解。</p>
<p>首先，第一种启发式解法就是，<strong>使用一个背包，尽量装满，然后换下一个背包</strong>，这里就把它叫做<strong>贪心背包</strong>。</p>
<p>然后参考:<a href="https://blog.csdn.net/x_i_y_u_e/article/details/46765093">装箱问题近似算法概述</a></p>
<p>那么这里的解法就有：</p>
<ol>
<li>贪心背包。</li>
<li>降序首次适应算法(FFD, First Fit Decreasing)。</li>
<li>降序最佳适应算法(BFD, Best Fit Decreasing)。</li>
<li>升序首次适应算法(FFI, First Fit Increasing)。</li>
<li>升序最佳适应算法(BFI, Best Fit Iecreasing)。</li>
</ol>
<p>而且这里的value值可以使用CPU，也可以使用内存，所以相当于<strong>一共有10种不同解法</strong>。</p>
<p>那么如何选择呢？当然是不选择，这些算法的运行速度都非常快，<strong>直接将它们全部用一遍</strong>，使用最好的那一个。</p>
<p><strong>trick:</strong></p>
<p>如果最后一台物理机只装了一个很小虚拟机，但是这已经是算法解出来最好的方式了，但是它拉低了总的利用率，怎么办？那么这里直接将这个虚拟机删除了就得了，
也就是对预测进行微小的修改。由于预测本来就不是很准，小修改并不会带来什么影响，但是能提升利用率。</p>
<hr>
<h1 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h1><hr>
<h2 id="题目变化"><a href="#题目变化" class="headerlink" title="题目变化"></a>题目变化</h2><p>复赛题目相比较初赛，只有一些小的变化。</p>
<ol>
<li>初赛物理机规格只有一种，这里变为三种。</li>
<li>部署同时考量CPU和内存。</li>
<li>预测时间段变为1~4星期，并且可能从训练数据结束后0~2星期内开始。</li>
<li>需要预测的虚拟机规格增加到18种。</li>
</ol>
<hr>
<h2 id="部署上的变化"><a href="#部署上的变化" class="headerlink" title="部署上的变化"></a>部署上的变化</h2><p>这里由于多了两种规格的物理机，而且同时考量的CPU和内存，所以这里就需要有所变化。</p>
<p>这里的优化目标相当于<code>最小化剩余资源的碎片大小</code>，考虑贪心背包方法，这里背包的value值就需要重新定义，
为了达到<code>最小化剩余资源的碎片大小</code>的目标，试着把一种规格的虚拟机value定义为：</p>
<p><code>虚拟机CPU/物理机CPU + 虚拟机内存/物理机内存</code></p>
<p>那么这里有三种规格的物理机，怎么选呢？在使用一个新背包来装的时候，将三个背包都试一遍，选择装的<strong>最满</strong>的那一个。</p>
<p>这个<strong>最满</strong>的定义就是碎片率最小，<code>物理机使用CPU/物理机CPU + 物理机使用内存/物理机内存</code>。</p>
<p>结果这里的效果非常好，基本能够达到部署分数97%以上…启发式有时候就是这样。</p>
<p><strong>PS:</strong></p>
<p>程序里面在两台物理机一样<strong>满</strong>的时候，还使用了一种奇葩的比较方式，而且思路上是写错了才出现的，结果效果更好了…</p>
<p>由于代码写错了导致看不懂思路，这里没法阐述…</p>
<p>总之通过这样的方法，在部署问题上的提升空间不大了。</p>
<hr>
<h1 id="预测部分"><a href="#预测部分" class="headerlink" title="预测部分"></a>预测部分</h1><p>其实就像上面部署所描述的，虽然部署是个<strong>NP难</strong>问题，但是其实部署很多时候都能接近最优或者是达到最优，
所以最难的部分还是在预测上面。</p>
<hr>
<h2 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h2><p>比赛给了一部分线下训练数据，当然只是用来进行线下的测试，测试现在的预测模型的效果，而不是用来训练模型，
因为这次比赛的训练阶段是放在线上进行的，会输入训练数据。而且线下的这部分训练数据并不多。</p>
<p>而且数据很奇怪，分成两个部分，<code>2015.01~2015.08</code>和<code>2015.12~2015.01</code>，这就导致第二部分的数据时间段较短，
并且与第一部分的数据差距很大。</p>
<p>这里为了连续性，所以只分析了<code>2015.01~2015.08</code>这一块数据。</p>
<p><strong>总体分布：</strong></p>
<p><img src="/images/competition/hwrj-2018_2.png" alt="images" title="总体分布"></p>
<p>可以看到每一天的VM数量都有很大的变化，看不出有什么规律。</p>
<p><strong>每周的VM数量：</strong></p>
<p><img src="/images/competition/hwrj-2018_4.png" alt="images" title="VM数量（每周）"></p>
<p>这个可以明显的感觉到后面的VM数量比前面的要多。</p>
<p><strong>VM数量累计和：</strong></p>
<p><img src="/images/competition/hwrj-2018_3.png" alt="images" title="VM数量累计"></p>
<p>上面的图看着就比较平滑，有一点线性增长的感觉，当然图上略微比线性增长快一点。</p>
<p>下面分布画出几种flavor的数据分布情况。</p>
<p><strong>flavor1:</strong></p>
<p><img src="/images/competition/hwrj-2018_5.png" alt="images" title="flavor1总体数量"></p>
<p><img src="/images/competition/hwrj-2018_6.png" alt="images" title="flavor1累计"></p>
<p><strong>flavor2:</strong></p>
<p><img src="/images/competition/hwrj-2018_7.png" alt="images" title="flavor2总体数量"></p>
<p><img src="/images/competition/hwrj-2018_8.png" alt="images" title="flavor2累计"></p>
<p><strong>flavor8:</strong></p>
<p><img src="/images/competition/hwrj-2018_9.png" alt="images" title="flavor8总体数量"></p>
<p><img src="/images/competition/hwrj-2018_10.png" alt="images" title="flavor8累计"></p>
<p>上面没有把所有都画出来，但是实际上差不多，可以发现数量分布很不均匀，有的flavor数量多，
画图看起来就比较平滑，有的flavor数量少，看起来很难看。</p>
<p>这也导致了模型很难达到较高的精度，因为数据本来就带有了太多的随机性。</p>
<hr>
<h2 id="基本模型思路"><a href="#基本模型思路" class="headerlink" title="基本模型思路"></a>基本模型思路</h2><p>这里首先就会想到使用线性回归，当然，这里的线性回归可能有两种理解，</p>
<p><strong>线性回归理解1</strong>：</p>
<p>样本有n个属性，通过n个属性乘上n个权重相加得到y。</p>
<script type="math/tex; mode=display">
w_1 x_1 + w_2 x_2 + ... + w_n x_n = y</script><p>那么可以把前面n天的VM数量作为样本属性，后面接着一段时间的vm数量作为样本y，来进行模型训练。</p>
<p><strong>线性回归理解2</strong>：</p>
<p>就是一条直线，</p>
<script type="math/tex; mode=display">
y = kx + b</script><p>那么也就是 x 就是某一天（或者某段时间）， y就是这一天（或这段时间）的VM数量。</p>
<p>这里为了简单，我把<code>线性回归理解2</code>叫做<strong>真线性回归</strong>。</p>
<p>这里当然还可以使用别的模型，例如，</p>
<p><strong>二次函数回归：</strong></p>
<script type="math/tex; mode=display">
y = a x^2 + bx + c</script><p>这个就类似真线性回归，只不过使用二次曲线来拟合。</p>
<p><strong>LSTM：</strong></p>
<p>这种时间序列的肯定会想到LSTM，但是这里数据量太少，直接PASS。</p>
<p><strong>神经网络：</strong></p>
<p>同样的这里数据量太少，直接PASS。</p>
<p><strong>arima：</strong></p>
<p>写起来可能比较复杂，而且效果可能也不会好，感觉这里数据没太多内在规律，数量量也不够。
究竟怎么样，这里没有尝试，不得而知。</p>
<p><strong>直接平均法：</strong></p>
<p>直接使用平均算出每一天或者每一周一种VM的数量，实际上效果还行。</p>
<p><strong>加权平均法：</strong></p>
<p>和平均的思想一样，但是越往后的天数权重越大，因为间隔时间越近的数据之间相关性肯定是越强。效果好于直接平均法。</p>
<p><strong>直接(加权)平均乘系数法：</strong></p>
<p>直接(加权)平均挺好的，但是通常结果偏小，因为VM增加越来越快，所以可以在直接平均的基础上再乘上一个大于1的系数。
<strong>事实上，大部分人使用的都是这个方法，系数完全靠猜。</strong>好吧，我们也是使用这样的方法进入复赛的。</p>
<hr>
<h2 id="基本采样思路"><a href="#基本采样思路" class="headerlink" title="基本采样思路"></a>基本采样思路</h2><p>采样应该依据模型来进行，不同模型对于采样的要求不一样，对比线性回归和真线性回归，
它两之间对于采样就有不一样的要求。</p>
<p>还需要注意的是，从上面图就可以看出，采样以天为基本单位，效果可能很差，因为变化太大了。
而且，<strong>星期六与星期天的VM数量较少</strong>。</p>
<p>所以采样可以用周作为单位来采样。</p>
<h3 id="时间段采样"><a href="#时间段采样" class="headerlink" title="时间段采样"></a>时间段采样</h3><p><img src="/images/competition/hwrj-2018_11.png" alt="images" title="时间段采样(样本1)"></p>
<p><img src="/images/competition/hwrj-2018_12.png" alt="images" title="时间段采样(样本2)"></p>
<p>上图的采样方式以某几天作为X，后面几天作为Y，当然作为Y的这”几天”的长度一般设置为等于输入需要预测的时间段长度。</p>
<p>这里对每种VM的数量进行区分。</p>
<p>这样的采样方式得到的样本就比较适合线性回归、神经网络等模型。</p>
<p>图中X的某一列就是某一天VM的发生数量。这里为了平滑<code>X</code>的属性，可以将这一列的数值转化为<strong>以这一天为结束的前一周的VM总和</strong>。</p>
<h3 id="按周采样"><a href="#按周采样" class="headerlink" title="按周采样"></a>按周采样</h3><p><img src="/images/competition/hwrj-2018_13.png" alt="images" title="按周采样"></p>
<p>图中以每一周作为一个x坐标，这周的VM数量作为y。</p>
<p>这里对每种VM的数量进行区分。</p>
<p>这种采样方式就比较适合真线性回归，学习出来的直线就类似图中的红线。</p>
<h3 id="VM总和采样"><a href="#VM总和采样" class="headerlink" title="VM总和采样"></a>VM总和采样</h3><p><img src="/images/competition/hwrj-2018_14.png" alt="images" title="VM总和采样"></p>
<p>这里的采样以每一天为一个单位，但是这里的y表示<strong>从开始到这一天，flavor数量的累计</strong>。</p>
<p>这里对每种VM的数量进行区分。</p>
<p>这样采样的目的是为了使得样本更加平滑，适合真线性回归模型。</p>
<p>图上的红线就是真线性回归，蓝线就是二次回归。</p>
<h3 id="不区分VM的种类"><a href="#不区分VM的种类" class="headerlink" title="不区分VM的种类"></a>不区分VM的种类</h3><p>上面的采样都是对VM的种类进行了区分的，这里还有一种思路，就是不对VM的种类进行区分，
采样直接针对<strong>所有VM的数量之和</strong>。</p>
<p>那么这样学习出来的模型只能预测出所有种类的VM总量，但是题目需要的是某一种VM的数量，
怎么办？</p>
<p>这里可以通过历史数据，统计每一种VM所占总量的百分比，然后将预测出来的结果乘上相应比例，得到对于VM的数量。</p>
<p>这样<strong>不区分VM的种类</strong>的好处，就是能使得数量变化更加平滑，真线性回归能有更好的学习效果。</p>
<p><strong>PS:</strong></p>
<p>这里进行模型学习的时候，使用的都是随机梯度下降(SGD)，当然，对于真线性回归来说，可以直接使用直接求解得到最优解，
但是这里没有使用，因为试了一下效果反而变差了，不知道为什么。</p>
<hr>
<h2 id="最终提交模型"><a href="#最终提交模型" class="headerlink" title="最终提交模型"></a>最终提交模型</h2><p>初赛如上面所说，使用的是<strong>加权平均乘系数法</strong>。</p>
<p>在复赛中，尝试了几种模型，包括<strong>加权平均法乘系数</strong>，效果都不好。</p>
<p>最后一次提交的模型效果好一点，要不连第10名都没有，这个模型是：</p>
<p><strong>不区分VM的总和采样</strong> + <strong>真线性回归</strong> + <strong>直接平均法</strong> + <strong>只使用最近两个月的数据</strong></p>
<p>这里对于占总量的比例大于<code>0.02</code>的VM，使用<strong>真线性回归</strong>得到的预测结果，但是对于小于<code>0.02</code>的VM，
使用的是<strong>直接平均法</strong>。对于离得太远的数据，使用之后反而会使得效果变差，所以通常都不会把所有的训练数据都用上。</p>
<p>最后只得到了第10名，很遗憾没有进入复赛。</p>
<p>有空再看看别人的博客吧。</p>
<hr>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>competition</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph+iscsi的简单使用</title>
    <url>/2019/08/06/2019-08-06-ceph-iscsi/</url>
    <content><![CDATA[<hr>
<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><p>首先看到ceph官网给出的大体结构：</p>
<p><img src="/images/linux/ceph/ceph-iscsi-1.png" alt="image" title="大体结构"></p>
<p>可以看到主要分为ceph集群、rbd、iscsi网关、initiator（也就是客户端）构成。</p>
<p>那么所需的准备就如下：</p>
<ul>
<li>一个<strong>HEALTH_OK</strong>的ceph集群，还有剩余的存储空间（给创建的rbd使用）。</li>
</ul>
<p>这里是我所搭建的集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph -s</span></span><br><span class="line"></span><br><span class="line">  cluster:</span><br><span class="line">    id:     51e9f534-b15a-4273-953c-9b56e9312510</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"> </span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum node1,node2,node3</span><br><span class="line">    mgr: node1(active), standbys: node2, node3</span><br><span class="line">    mds: cephfs-1/1/1 up  &#123;0=node1=up:active&#125;</span><br><span class="line">    osd: 6 osds: 6 up, 6 in</span><br><span class="line"> </span><br><span class="line">  data:</span><br><span class="line">    pools:   2 pools, 64 pgs</span><br><span class="line">    objects: 508  objects, 1.9 GiB</span><br><span class="line">    usage:   26 GiB used, 6.0 TiB / 6.0 TiB avail</span><br><span class="line">    pgs:     64 active+clean</span><br></pre></td></tr></table></figure>
<ul>
<li><p>两台linux主机，作为iscsi网关，可以是集群中的主机。</p>
</li>
<li><p>一台linux主机，作为linux系统下的客户端。</p>
</li>
<li><p>一台windows主机，作为windows系统下的客户端。</p>
</li>
</ul>
<hr>
<h2 id="配置ceph-iscsi网关"><a href="#配置ceph-iscsi网关" class="headerlink" title="配置ceph-iscsi网关"></a>配置ceph-iscsi网关</h2><hr>
<h3 id="修改osd配置"><a href="#修改osd配置" class="headerlink" title="修改osd配置"></a>修改osd配置</h3><p>安装官网所述，先修改osd的配置：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[osd]</span><br><span class="line">osd heartbeat grace = 20</span><br><span class="line">osd heartbeat interval = 5</span><br></pre></td></tr></table></figure>
<p>将上述配置添加到所有ceph节点的<code>/etc/ceph/ceph.conf</code>文件中，
当然可以使用ceph-deploy来推送。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim ceph.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat ceph.conf</span></span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">fsid = 51e9f534-b15a-4273-953c-9b56e9312510</span><br><span class="line">mon_initial_members = node1, node2, node3</span><br><span class="line">mon_host = 192.168.90.233,192.168.90.234,192.168.90.235</span><br><span class="line">auth_cluster_required = cephx</span><br><span class="line">auth_service_required = cephx</span><br><span class="line">auth_client_required = cephx</span><br><span class="line">public_network = 192.168.0.0/16</span><br><span class="line"></span><br><span class="line">[osd]</span><br><span class="line">osd heartbeat grace = 20</span><br><span class="line">osd heartbeat interval = 5</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ceph-deploy --overwrite-conf config push node1 node2 node3</span></span><br></pre></td></tr></table></figure></h2><h3 id="下载所需要的相关rpm包"><a href="#下载所需要的相关rpm包" class="headerlink" title="下载所需要的相关rpm包"></a>下载所需要的相关rpm包</h3><p>这里直接选择<strong>Using the Command Line Interface</strong>，感觉这个更靠谱一些。</p>
<p>按照官网所述，yum的repo中需要有以下rpm包：</p>
<p><img src="/images/linux/ceph/ceph-iscsi-2.png" alt="image" title="所需rpm包"></p>
<p>直接<code>yum install</code>试试可以发现，只有<strong>targetcli</strong>和<strong>python-rtslib</strong>能装上，而且版本都比官网说的要低，好吧，麻烦来了。</p>
<p>经过一段<strong>几个小时*</strong>的搜索……从下面链接中找到了rpm包：</p>
<ul>
<li><a href="https://github.com/ceph/ceph-iscsi/issues/64">Build new RPM for 3.0</a></li>
<li><a href="https://github.com/ceph/ceph-ansible/issues/2707">Missing ceph-iscsi-cli package</a></li>
</ul>
<p>新建repo文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/yum.repo.d/iscsi.repo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/yum.repo.d/iscsi.repo</span></span><br><span class="line"></span><br><span class="line">[ceph-iscsi]</span><br><span class="line">name=Ceph-iscsi</span><br><span class="line">baseurl=https://4.chacra.ceph.com/r/ceph-iscsi/master/88f3f67981c7da15448f140f711a1a8413d450b0/centos/7/flavors/default/noarch/</span><br><span class="line">priority=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line">[tcmu-runner]</span><br><span class="line">name=tcmu-runner</span><br><span class="line">baseurl=https://3.chacra.ceph.com/r/tcmu-runner/master/eef511565078fb4e2ed52caaff16e6c7e75ed6c3/centos/7/flavors/default/x86_64/</span><br><span class="line">priority=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line">[python-rtslib]</span><br><span class="line">name=python-rtslib</span><br><span class="line">baseurl=https://2.chacra.ceph.com/r/python-rtslib/master/67eb1605c697b6307d8083b2962f5170db13d306/centos/7/flavors/default/noarch/</span><br><span class="line">priority=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure>
<p>这里我使用的是本地源，将上面的包下载到本地源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install --downloadonly --downloaddir=yum/ceph-iscsi/ targetcli python-rtslib tcmu-runner ceph-iscsi</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> createrepo -p -d -o yum/ yum/</span></span><br></pre></td></tr></table></figure>
<p>注意到这里没有包含<strong>targetcli</strong>的repo，因为没有找到，使用yum基础的Base源或者是Ceph源可以安装<code>targetcli-2.1.fb46-7.el7.noarch.rpm</code>，
虽然官网需要的是<code>targetcli-2.1.fb47 or newer package</code>，但在后续使用中发现没有影响，所以这里就不用管<strong>targetcli</strong>了。</p>
<p>那么这里下载下来的就是：</p>
<ul>
<li>targetcli-2.1.fb46-7.el7.noarch.rpm</li>
<li>python-rtslib-2.1.fb68-1.noarch.rpm</li>
<li>tcmu-runner-1.4.0-0.1.51.geef5115.el7.x86_64.rpm</li>
<li>ceph-iscsi-3.2-8.g88f3f67.el7.noarch.rpm</li>
</ul>
<hr>
<h3 id="ceph-iscsi网关初始配置"><a href="#ceph-iscsi网关初始配置" class="headerlink" title="ceph-iscsi网关初始配置"></a>ceph-iscsi网关初始配置</h3><p>如果使用的不是集群内的节点作为ceph-iscsi网关，那就需要进行一些初始的配置。</p>
<ol>
<li>安装ceph。</li>
<li>从集群中的一台机器上拷贝<code>/etc/ceph/ceph.conf</code>到本机的<code>/etc/ceph/ceph.conf</code>。</li>
<li>从集群中的一台机器上拷贝<code>/etc/ceph/ceph.client.admin.keyring</code>到本机的<code>/etc/ceph/ceph.client.admin.keyring</code>。</li>
</ol>
<p>当然第2和3步可以直接在deploy节点使用<code>ceph-deploy admin &#123;node-gateway&#125;</code>，<code>&#123;node-gateway&#125;</code>就表示网关节点的名字。</p>
<p>可见这里就是为了将ceph-iscsi网关节点变成一个admin节点。</p>
<p>这时在网关节点上应该可以执行相关命令操作ceph集群，例如<code>sudo ceph -s</code>查询当前集群的状态。</p>
<hr>
<h3 id="安装配置iscsi"><a href="#安装配置iscsi" class="headerlink" title="安装配置iscsi"></a>安装配置iscsi</h3><p>这里官网建议先切换到root用户，方便一点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> su root</span></span><br></pre></td></tr></table></figure>
<p>在两个网关节点上都安装iscsi（注意到上面已经将相关包下载到了本地源，所以可以直接yum安装）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install -y ceph-iscsi</span></span><br></pre></td></tr></table></figure>
<p><strong>服务启动：</strong></p>
<p>先创建<code>rbd pool</code>，如果没有的话。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ceph osd lspools</span></span><br><span class="line"></span><br><span class="line">1 cephfs_data</span><br><span class="line">2 cephfs_metadata</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ceph osd pool create rbd 128</span></span><br><span class="line"></span><br><span class="line">pool &#x27;rbd&#x27; created</span><br></pre></td></tr></table></figure>
<p>创建并修改<code>/etc/ceph/iscsi-gateway.cfg</code>文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/ceph/iscsi-gateway.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/ceph/iscsi-gateway.cfg</span></span><br><span class="line"></span><br><span class="line">[config]</span><br><span class="line"><span class="meta">#</span><span class="bash"> Name of the Ceph storage cluster. A suitable Ceph configuration file allowing</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> access to the Ceph storage cluster from the gateway node is required, <span class="keyword">if</span> not</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> colocated on an OSD node.</span></span><br><span class="line">cluster_name = ceph</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Place a copy of the ceph cluster<span class="string">&#x27;s admin keyring in the gateway&#x27;</span>s /etc/ceph</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drectory and reference the filename here</span></span><br><span class="line">gateway_keyring = ceph.client.admin.keyring</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> API settings.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The API supports a number of options that allow you to tailor it to your</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">local</span> environment. If you want to run the API under https, you will need to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> create cert/key files that are compatible <span class="keyword">for</span> each iSCSI gateway node, that is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> not locked to a specific node. SSL cert and key files *must* be called</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&#x27;iscsi-gateway.crt&#x27;</span> and <span class="string">&#x27;iscsi-gateway.key&#x27;</span> and placed <span class="keyword">in</span> the <span class="string">&#x27;/etc/ceph/&#x27;</span> directory</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> on *each* gateway node. With the SSL files <span class="keyword">in</span> place, you can use <span class="string">&#x27;api_secure = true&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to switch to https mode.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> To support the API, the bear minimum settings are:</span></span><br><span class="line">api_secure = false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Additional API configuration options are as follows, defaults shown.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> api_user = admin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> api_password = admin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> api_port = 5001</span></span><br><span class="line">trusted_ip_list = 192.168.90.234,192.168.90.235</span><br></pre></td></tr></table></figure>
<p>上面<code>trusted_ip_list</code>填写的就是两台网关的ip（这里不讨论多网卡的情况）。</p>
<p>在另外一台网关上复制这个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo scp cluster@node2:/etc/ceph/iscsi-gateway.cfg /etc/ceph/iscsi-gateway.cfg</span></span><br></pre></td></tr></table></figure>
<p>在两台网关上都开启rbd-target-api服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl daemon-reload</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> rbd-target-api</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl start rbd-target-api</span></span><br></pre></td></tr></table></figure>
<p><strong>配置：（在其中一台网关配置就行）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gwcli</span></span><br><span class="line"><span class="meta">/&gt;</span><span class="bash"> <span class="built_in">cd</span> /iscsi-targets</span></span><br><span class="line"></span><br><span class="line"><span class="meta">/iscsi-targets&gt;</span><span class="bash"> create iqn.2003-01.com.redhat.iscsi-gw:iscsi-igw</span></span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="meta">/iscsi-targets&gt;</span><span class="bash"> <span class="built_in">cd</span> iqn.2003-01.com.redhat.iscsi-gw:iscsi-igw/gateways</span></span><br><span class="line"></span><br><span class="line">/iscsi-target...-igw/gateways&gt; create node2 192.168.90.234</span><br><span class="line">Adding gateway, sync&#x27;ing 0 disk(s) and 0 client(s)</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">/iscsi-target...-igw/gateways&gt; create node3 192.168.90.235</span><br><span class="line">Adding gateway, sync&#x27;ing 0 disk(s) and 0 client(s)</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">/iscsi-target...-igw/gateways&gt; cd /disks</span><br><span class="line"></span><br><span class="line"><span class="meta">/disks&gt;</span><span class="bash"> create pool=rbd image=disk_1 size=200G</span></span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="meta">/disks&gt;</span><span class="bash"> <span class="built_in">cd</span> /iscsi-targets/iqn.2003-01.com.redhat.iscsi-gw:iscsi-igw/hosts</span></span><br><span class="line"></span><br><span class="line">/iscsi-target...csi-igw/hosts&gt; create iqn.1994-05.com.redhat:rh7-client</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">/iscsi-target...at:rh7-client&gt; auth username=myiscsiusername password=myiscsipassword</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">/iscsi-target...at:rh7-client&gt; disk add rbd/disk_1</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p>配置完成，可以看到我当前的目录结构：</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">/&gt;</span><span class="bash"> ls</span></span><br><span class="line">o- / ......................................................................... [...]</span><br><span class="line">  o- cluster ......................................................... [Clusters: 1]</span><br><span class="line">  | o- ceph .......................................................... [HEALTH_WARN]</span><br><span class="line">  |   o- pools .......................................................... [Pools: 3]</span><br><span class="line">  |   | o- cephfs_data ... [(x3), Commit: 0.00Y/2028052096K (0%), Used: 2029431878b]</span><br><span class="line">  |   | o- cephfs_metadata .... [(x3), Commit: 0.00Y/2028052096K (0%), Used: 77834b]</span><br><span class="line">  |   | o- rbd ................ [(x3), Commit: 200G/2028052096K (10%), Used: 15352b]</span><br><span class="line">  |   o- topology ................................................ [OSDs: 6,MONs: 3]</span><br><span class="line">  o- disks ........................................................ [200G, Disks: 1]</span><br><span class="line">  | o- rbd ............................................................ [rbd (200G)]</span><br><span class="line">  |   o- disk_1 ................................................ [rbd/disk_1 (200G)]</span><br><span class="line">  o- iscsi-targets ............................... [DiscoveryAuth: None, Targets: 1]</span><br><span class="line">    o- iqn.2003-01.com.redhat.iscsi-gw:iscsi-igw ..................... [Gateways: 2]</span><br><span class="line">      o- disks .......................................................... [Disks: 1]</span><br><span class="line">      | o- rbd/disk_1 ............................................... [Owner: node3]</span><br><span class="line">      o- gateways ............................................ [Up: 2/2, Portals: 2]</span><br><span class="line">      | o- node2 ............................................. [192.168.90.234 (UP)]</span><br><span class="line">      | o- node3 ............................................. [192.168.90.235 (UP)]</span><br><span class="line">      o- host-groups .................................................. [Groups : 0]</span><br><span class="line">      o- hosts .............................................. [Hosts: 1: Auth: CHAP]</span><br><span class="line">        o- iqn.1994-05.com.redhat:rh7-client .......... [Auth: CHAP, Disks: 1(200G)]</span><br><span class="line">          o- lun 0 ................................ [rbd/disk_1(200G), Owner: node3]</span><br></pre></td></tr></table></figure></h2><h2 id="linux客户端配置"><a href="#linux客户端配置" class="headerlink" title="linux客户端配置"></a>linux客户端配置</h2><p>在作为客户端的linux主机上。</p>
<p>安装相关组件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y iscsi-initiator-utils</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y device-mapper-multipath</span></span><br></pre></td></tr></table></figure>
<p>开启multipathd服务并进行配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mpathconf --<span class="built_in">enable</span> --with_multipathd y</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/multipath.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cat /etc/multipath.conf</span></span><br><span class="line"></span><br><span class="line">devices &#123;</span><br><span class="line">        device &#123;</span><br><span class="line">                vendor                 &quot;LIO-ORG&quot;</span><br><span class="line">                hardware_handler       &quot;1 alua&quot;</span><br><span class="line">                path_grouping_policy   &quot;failover&quot;</span><br><span class="line">                path_selector          &quot;queue-length 0&quot;</span><br><span class="line">                failback               60</span><br><span class="line">                path_checker           tur</span><br><span class="line">                prio                   alua</span><br><span class="line">                prio_args              exclusive_pref_bit</span><br><span class="line">                fast_io_fail_tmo       25</span><br><span class="line">                no_path_retry          queue</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改客户端名称：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/iscsi/initiatorname.iscsi</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cat /etc/iscsi/initiatorname.iscsi</span></span><br><span class="line"></span><br><span class="line">InitiatorName=iqn.1994-05.com.redhat:rh7-client</span><br></pre></td></tr></table></figure>
<p>修改chap认证配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/iscsi/iscsid.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cat /etc/iscsi/iscsid.conf</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> *************</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CHAP Settings</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> *************</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> To <span class="built_in">enable</span> CHAP authentication <span class="built_in">set</span> node.session.auth.authmethod</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to CHAP. The default is None.</span></span><br><span class="line">node.session.auth.authmethod = CHAP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> To <span class="built_in">set</span> a CHAP username and password <span class="keyword">for</span> initiator</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> authentication by the target(s), uncomment the following lines:</span></span><br><span class="line">node.session.auth.username = myiscsiusername</span><br><span class="line">node.session.auth.password = myiscsipassword</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>发现target：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo iscsiadm -m discovery -t st -p 192.168.90.234</span></span><br><span class="line"></span><br><span class="line">192.168.90.234:3260,1 iqn.2003-01.org.linux-iscsi.rheln1</span><br><span class="line">192.168.90.235:3260,2 iqn.2003-01.org.linux-iscsi.rheln1</span><br></pre></td></tr></table></figure>
<p>登入target：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo iscsiadm -m node -T iqn.2003-01.org.linux-iscsi.rheln1 -l</span></span><br></pre></td></tr></table></figure>
<p>查看是否成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo multipath -ll</span></span><br><span class="line">mpatha (360014050fedd563975249adb2e84e978) dm-2 LIO-ORG ,TCMU device     </span><br><span class="line">size=200G features=&#x27;1 queue_if_no_path&#x27; hwhandler=&#x27;1 alua&#x27; wp=rw</span><br><span class="line">|-+- policy=&#x27;queue-length 0&#x27; prio=50 status=active</span><br><span class="line">| `- 3:0:0:0 sdc 8:32 active ready running</span><br><span class="line">`-+- policy=&#x27;queue-length 0&#x27; prio=10 status=enabled</span><br><span class="line">  `- 2:0:0:0 sdb 8:16 active ready running</span><br></pre></td></tr></table></figure>
<p>在fdisk中就可以直接看到这个“硬盘”：</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo fdisk -l</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Disk /dev/mapper/mpatha: 10.7 GB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 524288 bytes</span><br><span class="line">...</span><br></pre></td></tr></table></figure></h2><h2 id="windows客户端配置"><a href="#windows客户端配置" class="headerlink" title="windows客户端配置"></a>windows客户端配置</h2><p>在<code>控制面板-&gt;管理工具-&gt;iSCSI 发起程序</code>：</p>
<p><img src="/images/linux/ceph/ceph-iscsi-3.png" alt="image" title="控制面板-&gt;管理工具"></p>
<p><img src="/images/linux/ceph/ceph-iscsi-4.png" alt="image" title="管理工具-&gt;iSCSI 发起程序"></p>
<p>修改发起程序名称：</p>
<p><img src="/images/linux/ceph/ceph-iscsi-5.png" alt="image" title="发起程序名称"></p>
<p>添加发现目标门户：</p>
<p><img src="/images/linux/ceph/ceph-iscsi-6.png" alt="image" title="添加发现目标门户"></p>
<p>可以看到出现目标：</p>
<p><img src="/images/linux/ceph/ceph-iscsi-7.png" alt="image" title="出现目标"></p>
<p>连接到该目标：</p>
<p><img src="/images/linux/ceph/ceph-iscsi-8.png" alt="image" title="连接目标"></p>
<p>修改高级设置：</p>
<p><img src="/images/linux/ceph/ceph-iscsi-9.png" alt="image" title="修改高级设置"></p>
<p>可以看到已连接：</p>
<p><img src="/images/linux/ceph/ceph-iscsi-10.png" alt="image" title="可以看到已连接"></p>
<p>可以在磁盘管理中看到硬盘已经连接：</p>
<p><img src="/images/linux/ceph/ceph-iscsi-11.png" alt="image" title="磁盘管理"></p>
<p>这里将它分为F盘，并且成功往里面放了一个文件：</p>
<p><img src="/images/linux/ceph/ceph-iscsi-12.png" alt="image" title="分配成为F盘"></p>
<p><img src="/images/linux/ceph/ceph-iscsi-13.png" alt="image" title="放入文件成功"></p>
<hr>
<h2 id="Health-Warning"><a href="#Health-Warning" class="headerlink" title="Health Warning"></a>Health Warning</h2><p>注意到此时ceph集群可能会出现一个<code>Health Warning</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph -s</span></span><br><span class="line"></span><br><span class="line">  cluster:</span><br><span class="line">    id:     51e9f534-b15a-4273-953c-9b56e9312510</span><br><span class="line">    health: HEALTH_WARN</span><br><span class="line">            application not enabled on 1 pool(s)</span><br><span class="line"> </span><br><span class="line">  services:</span><br><span class="line">    mon:         3 daemons, quorum node1,node2,node3</span><br><span class="line">    mgr:         node1(active), standbys: node2, node3</span><br><span class="line">    mds:         cephfs-1/1/1 up  &#123;0=node1=up:active&#125;</span><br><span class="line">    osd:         6 osds: 6 up, 6 in</span><br><span class="line">    tcmu-runner: 2 daemons active</span><br><span class="line"> </span><br><span class="line">  data:</span><br><span class="line">    pools:   3 pools, 192 pgs</span><br><span class="line">    objects: 559  objects, 2.1 GiB</span><br><span class="line">    usage:   27 GiB used, 6.0 TiB / 6.0 TiB avail</span><br><span class="line">    pgs:     192 active+clean</span><br><span class="line"> </span><br><span class="line">  io:</span><br><span class="line">    client:   2.5 KiB/s rd, 2 op/s rd, 0 op/s wr</span><br></pre></td></tr></table></figure>
<p>从官网中可以看到这个warning发生的原因<a href="https://ceph.io/community/new-luminous-pool-tags/">New in Luminous: pool tags</a>，
另外使用<code>ceph health detail</code>也可以看到解决方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph health detail</span></span><br><span class="line"></span><br><span class="line">HEALTH_WARN application not enabled on 1 pool(s)</span><br><span class="line">POOL_APP_NOT_ENABLED application not enabled on 1 pool(s)</span><br><span class="line">    application not enabled on pool &#x27;rbd&#x27;</span><br><span class="line">    use &#x27;ceph osd pool application enable &lt;pool-name&gt; &lt;app-name&gt;&#x27;, where &lt;app-name&gt; is &#x27;cephfs&#x27;, &#x27;rbd&#x27;, &#x27;rgw&#x27;, or freeform for custom applications.</span><br></pre></td></tr></table></figure>
<p>这里就将所建立的<code>rbd</code>池标记为<strong>rbd</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph osd pool application <span class="built_in">enable</span> rbd rbd</span></span><br><span class="line"></span><br><span class="line">enabled application &#x27;rbd&#x27; on pool &#x27;rbd&#x27;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ceph -s</span></span><br><span class="line"></span><br><span class="line">  cluster:</span><br><span class="line">    id:     51e9f534-b15a-4273-953c-9b56e9312510</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"> </span><br><span class="line">  services:</span><br><span class="line">    mon:         3 daemons, quorum node1,node2,node3</span><br><span class="line">    mgr:         node1(active), standbys: node2, node3</span><br><span class="line">    mds:         cephfs-1/1/1 up  &#123;0=node1=up:active&#125;</span><br><span class="line">    osd:         6 osds: 6 up, 6 in</span><br><span class="line">    tcmu-runner: 2 daemons active</span><br><span class="line"> </span><br><span class="line">  data:</span><br><span class="line">    pools:   3 pools, 192 pgs</span><br><span class="line">    objects: 559  objects, 2.1 GiB</span><br><span class="line">    usage:   27 GiB used, 6.0 TiB / 6.0 TiB avail</span><br><span class="line">    pgs:     192 active+clean</span><br><span class="line"> </span><br><span class="line">  io:</span><br><span class="line">    client:   2.0 KiB/s rd, 1 op/s rd, 0 op/s wr</span><br></pre></td></tr></table></figure>
<p>问题解决。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.ceph.com/docs/master/rbd/iscsi-overview/">CEPH ISCSI GATEWAY</a></p>
<p><a href="https://blog.51cto.com/devingeng/2125656">看Ceph如何实现原生的ISCSI</a></p>
<p><a href="https://github.com/ceph/ceph-iscsi/issues/64">Build new RPM for 3.0</a></p>
<p><a href="https://github.com/ceph/ceph-ansible/issues/2707">Missing ceph-iscsi-cli package</a></p>
<p><a href="https://ceph.io/community/new-luminous-pool-tags/">New in Luminous: pool tags</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>ceph</tag>
        <tag>iscsi</tag>
      </tags>
  </entry>
  <entry>
    <title>练习使用FFmpeg将视频转码为hls，并添加水印</title>
    <url>/2019/08/08/2019-08-08-ffmpeg-practice/</url>
    <content><![CDATA[<hr>
<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><ul>
<li>一个高清的视频（这样转分辨率后起码不会糊）。</li>
<li>一个高清的水印图片（理由同上）。</li>
<li>FFmpeg，直接官网下一个就可以，这里我使用的就是FFmpeg.exe。</li>
</ul>
<p>下面将各个部分拆开练习，最后再合在一起。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 11.mp4 </span><br><span class="line">-vf &quot;movie&#x3D;wm.png [logo];[logo][in]scale2ref&#x3D;w&#x3D;oh*mdar:h&#x3D;ih&#x2F;10[logo-rescale][video-out];[video-out][logo-rescale]overlay&#x3D;x&#x3D;main_w&#x2F;10-w&#x2F;2:y&#x3D;main_h&#x2F;10-h&#x2F;2 [out]&quot;</span><br><span class="line">-codec:v libx264 -s 1920x1080 -codec:a mp3 </span><br><span class="line">-map 0 -f ssegment -segment_format mpegts -segment_list playlist.m3u8 -segment_time 10 1080P%03d.ts</span><br></pre></td></tr></table></figure></h2><h2 id="一些基本命令"><a href="#一些基本命令" class="headerlink" title="一些基本命令"></a>一些基本命令</h2><hr>
<h3 id="1-转格式（容器转换）"><a href="#1-转格式（容器转换）" class="headerlink" title="1.转格式（容器转换）"></a>1.转格式（容器转换）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 11.mp4 out.avi</span></span><br></pre></td></tr></table></figure>
<p>直接在输出文件的后缀指定需要转的格式（容器）就行。</p>
<p><strong>这样转码是会使用默认编码器，需要设置转码为copy来达到视频质量无损失。参考设置视频编码。</strong></p>
<hr>
<h3 id="2-转分辨率"><a href="#2-转分辨率" class="headerlink" title="2.转分辨率"></a>2.转分辨率</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 11.mp4 -s 1280x720 out.mp4</span></span><br></pre></td></tr></table></figure>
<p>通过<code>-s 1280x720</code>指定分辨率为720P。</p>
<hr>
<h3 id="3-设置视频编码"><a href="#3-设置视频编码" class="headerlink" title="3.设置视频编码"></a>3.设置视频编码</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 11.mp4 -s 1280x720 -codec:v libx264 -codec:a mp3 out.mp4</span></span><br></pre></td></tr></table></figure>
<p>这里通过<code>-codec:v libx264</code>指定视频编码格式为<code>x264</code>，通过<code>-codec:a mp3</code>指定音频编码格式为<code>mp3</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 4K_BXJG.mp4 -codec:v copy -codec:a copy out.avi</span></span><br></pre></td></tr></table></figure>
<p>这里的转码格式被指定为<code>copy</code>，实际上FFmpeg就会省去编解码过程，速度非常快。</p>
<blockquote>
<p>Stream copy is a mode selected by supplying the copy parameter to the -codec option. It makes ffmpeg omit the decoding and encoding step for the specified stream, so it does only demuxing and muxing. It is useful for changing the container format or modifying container-level metadata.</p>
<p>Since there is no decoding or encoding, it is very fast and there is no quality loss. </p>
</blockquote>
<p>上面是官网中的描述，可以看到使用copy可以无损的转化容器格式。</p>
<hr>
<h3 id="4-转图片分辨率"><a href="#4-转图片分辨率" class="headerlink" title="4.转图片分辨率"></a>4.转图片分辨率</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i wm.png -s 100x100 out.png</span></span><br></pre></td></tr></table></figure>
<p>可以看到转图片其实和转视频是同理的。</p>
<h3 id="5-流选择"><a href="#5-流选择" class="headerlink" title="5.流选择"></a>5.流选择</h3><p>一个正常的视频至少有两个流，一个视频流，一个音频流。</p>
<p>通过输入而不输出可以查看媒体文件信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 4K_BXJG.mp4</span></span><br><span class="line"></span><br><span class="line">Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &#x27;4K_BXJG.mp4&#x27;:</span><br><span class="line">  Metadata:</span><br><span class="line">    major_brand     : mp42</span><br><span class="line">    minor_version   : 0</span><br><span class="line">    compatible_brands: mp42mp41</span><br><span class="line">    creation_time   : 2017-02-04T16:09:19.000000Z</span><br><span class="line">  Duration: 00:00:54.02, start: 0.000000, bitrate: 39655 kb/s</span><br><span class="line">    Stream #0:0(eng): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709), 3840x2160 [SAR 1:1 DAR 16:9], 39366 kb/s, 23.98 fps, 23.98 tbr, 24k tbn, 47.95 tbc (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      creation_time   : 2017-02-04T16:09:19.000000Z</span><br><span class="line">      handler_name    : ?Mainconcept Video Media Handler</span><br><span class="line">      encoder         : AVC Coding</span><br><span class="line">    Stream #0:1(eng): Audio: aac (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 317 kb/s (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      creation_time   : 2017-02-04T16:09:19.000000Z</span><br><span class="line">      handler_name    : #Mainconcept MP4 Sound Media Handler</span><br></pre></td></tr></table></figure>
<p>可以看到这个mp4文件包含两个流，0号流为视频流，1号流为音频流。</p>
<p>同时输入两个媒体文件试试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  ffmpeg -i 4K_Z4.mp4 -i 4K_BXJG.mp4</span></span><br><span class="line"></span><br><span class="line">Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &#x27;4K_Z4.mp4&#x27;:</span><br><span class="line">  Metadata:</span><br><span class="line">    major_brand     : isom</span><br><span class="line">    minor_version   : 512</span><br><span class="line">    compatible_brands: mp41mp42</span><br><span class="line">    creation_time   : 2015-01-05T13:14:01.000000Z</span><br><span class="line">  Duration: 00:02:22.56, start: 0.000000, bitrate: 44851 kb/s</span><br><span class="line">    Stream #0:0(eng): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709), 3840x2160 [SAR 1:1 DAR 16:9], 44717 kb/s, 50 fps, 50 tbr, 30k tbn, 100 tbc (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      creation_time   : 2015-01-05T13:14:01.000000Z</span><br><span class="line">      encoder         : AVC Coding</span><br><span class="line">    Stream #0:1(eng): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 128 kb/s (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      creation_time   : 2015-01-05T13:14:01.000000Z</span><br><span class="line">Input #1, mov,mp4,m4a,3gp,3g2,mj2, from &#x27;4K_BXJG.mp4&#x27;:</span><br><span class="line">  Metadata:</span><br><span class="line">    major_brand     : mp42</span><br><span class="line">    minor_version   : 0</span><br><span class="line">    compatible_brands: mp42mp41</span><br><span class="line">    creation_time   : 2017-02-04T16:09:19.000000Z</span><br><span class="line">  Duration: 00:00:54.02, start: 0.000000, bitrate: 39655 kb/s</span><br><span class="line">    Stream #1:0(eng): Video: h264 (High) (avc1 / 0x31637661), yuv420p(tv, bt709), 3840x2160 [SAR 1:1 DAR 16:9], 39366 kb/s, 23.98 fps, 23.98 tbr, 24k tbn, 47.95 tbc (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      creation_time   : 2017-02-04T16:09:19.000000Z</span><br><span class="line">      handler_name    : ?Mainconcept Video Media Handler</span><br><span class="line">      encoder         : AVC Coding</span><br><span class="line">    Stream #1:1(eng): Audio: aac (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 317 kb/s (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      creation_time   : 2017-02-04T16:09:19.000000Z</span><br><span class="line">      handler_name    : #Mainconcept MP4 Sound Media Handler</span><br></pre></td></tr></table></figure>
<p>可以发现流编号上面的规律，<code>0:0</code>、<code>0:1</code>表示第一个文件的两个流，<code>1:0</code>、<code>1:1</code>则表示第二个文件的两个流。</p>
<p><strong>提取视频流：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 1080_BXJG.mp4 -map 0:0 -codec copy out.mp4</span></span><br></pre></td></tr></table></figure>
<p>上面的命令将原视频的视频流单独分离出来。</p>
<p><strong>合并音视频流：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 1080_BXJG.mp4 -i 4K_Z4.mp4 -map 0:0 -codec copy -map 1:1 -codec copy out.mp4</span></span><br></pre></td></tr></table></figure>
<p>提取第一个视频的视频流，第二个视频的音频流，合并为out.mp4。</p>
<hr>
<hr>
<hr>
<h2 id="filter设置"><a href="#filter设置" class="headerlink" title="filter设置"></a>filter设置</h2><hr>
<h3 id="1-过滤器图"><a href="#1-过滤器图" class="headerlink" title="1.过滤器图"></a>1.过滤器图</h3><p>先看官方文档说的：</p>
<blockquote>
<p>Filtering in FFmpeg is enabled through the libavfilter library.</p>
<p>In libavfilter, a filter can have multiple inputs and multiple outputs. To illustrate the sorts of things that are possible, we consider the following filtergraph.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">                [main]</span><br><span class="line">input --&gt; split ---------------------&gt; overlay --&gt; output</span><br><span class="line">            |                             ^</span><br><span class="line">            |[tmp]                  [flip]|</span><br><span class="line">            +-----&gt; crop --&gt; vflip -------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>This filtergraph splits the input stream in two streams, then sends one stream through the crop filter and the vflip filter, before merging it back with the other stream by overlaying it on top. </p>
</blockquote>
<p>filter即常说的滤镜，Filtering过程可以是一个多输入多输出的过程，多个输入的视频经过处理合并成一个或多个输出。</p>
<p>上面的过程的命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i INPUT -vf <span class="string">&quot;split [main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip]; [main][flip] overlay=0:H/2&quot;</span> OUTPUT</span></span><br></pre></td></tr></table></figure>
<p>它的效果如下：</p>
<p><img src="/images/media/FFmpeg/1-1.png" alt="image" title="原视频"></p>
<p><img src="/images/media/FFmpeg/1-2.png" alt="image" title="转码后"></p>
<p>它将原视频复制（split），裁剪一半（crop），反转（cflip），覆盖（overlay）到原视频之上。</p>
<p>可以看到主要的处理过程在<code>-vf</code>之后，它就代表<code>filtergraph</code>也就是<strong>过滤器图</strong>（相似的还有<code>-filter_complex</code>），相当于定义了一个视频处理的过程。</p>
<p><strong>注意到：<code>-vf</code>不能有多个输入，而<code>-filter_complex</code>可以。</strong></p>
<hr>
<h3 id="2-label（标签）"><a href="#2-label（标签）" class="headerlink" title="2.label（标签）"></a>2.label（标签）</h3><p>标签用于对流进行标记，目前我只知道它一些简单的用法。</p>
<p>例如上面的命令中的过滤器图：</p>
<p><code>&quot;split [main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip]; [main][flip] overlay=0:H/2&quot;</code></p>
<ol>
<li>它将原视频进行split，将它复制为两个流，一个命名为<code>[main]</code>，一个命名为<code>[tmp]</code>。</li>
<li>它将<code>[tmp]</code>流进行crop操作和vfilp操作，处理之后的流命名为<code>[flip]</code>。</li>
<li>输入<code>[main]</code>和<code>[flip]</code>流，进行overlay（覆盖）操作，根据这里<code>[main][flip]</code>的先后关系，这里将<code>[flip]</code>覆盖到<code>[main]</code>之上。</li>
</ol>
<p>例如下面的命令，将第二个输入视频分辨率降低一半，然后覆盖到第一个视频之上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 1080_BXJG.mp4 -i 1080_BXJG.mp4 -filter_complex <span class="string">&quot;[1:0]scale=w=iw/2:h=ih/2[scaled]; [0][scaled] overlay&quot;</span> tmp1.mp4</span></span><br></pre></td></tr></table></figure>
<p>其中<code>&quot;[1:0]scale=w=iw/2:h=ih/2[scaled]; [0][scaled] overlay&quot;</code>：</p>
<ol>
<li><code>[1:0]</code>代表第二个视频的第一个流（视频流），将它的scale变为一半（<code>iw/2</code>和<code>ih/2</code>），然后标记为<code>[scaled]</code>。</li>
<li><code>[0]</code>就代表第一个输入的媒体文件，将<code>[scaled]</code>置于它之上然后输出。</li>
</ol>
<hr>
<h3 id="3-将视频分辨率降低一半"><a href="#3-将视频分辨率降低一半" class="headerlink" title="3.将视频分辨率降低一半"></a>3.将视频分辨率降低一半</h3><p>可以利用scale来完成，其中<code>iw</code>、<code>ih</code>分别代表输入的宽和高。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 11.mp4 -vf <span class="string">&quot;[in]scale=w=iw/2:h=ih/2[out]&quot;</span> out.mp4</span></span><br></pre></td></tr></table></figure>
<p>为了展示效果，这里将降低了分辨率的视频覆盖到原视频之上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 1080_BXJG.mp4 -filter_complex <span class="string">&quot;[0:0]scale=w=iw/2:h=ih/2[scaled]; [0][scaled] overlay&quot;</span> tmp1.mp4</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/media/FFmpeg/1-3.png" alt="image" title="分辨率降低一半"></p>
<hr>
<h3 id="4-为视频添加水印"><a href="#4-为视频添加水印" class="headerlink" title="4.为视频添加水印"></a>4.为视频添加水印</h3><p>为视频添加水印，也就是将水印覆盖到原视频之上，即<code>overlay</code>滤镜。</p>
<p><strong>简单覆盖：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 1080_BXJG.mp4 -i wm.png -filter_complex overlay out.mp4</span></span><br></pre></td></tr></table></figure>
<p>简单覆盖时，没有对水印大小进行调整，会造成下面的结果：</p>
<p><img src="/images/media/FFmpeg/1-4.png" alt="image" title="简单覆盖"></p>
<p><strong>大小调整-1：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 1080_BXJG.mp4 -i logo.png -filter_complex <span class="string">&#x27;[1]scale=w=200:h=-1[scaled]; [0][scaled]overlay&#x27;</span> out.mp4</span></span><br></pre></td></tr></table></figure>
<p>使用<code>scale</code>滤镜来进行分辨率的调整，再将它覆盖到原视频之上：</p>
<p><img src="/images/media/FFmpeg/1-5.png" alt="image" title="水印分辨率调整"></p>
<p>可以看到这里成功的对水印的大小进行了调整，<strong>但是</strong>又有一点太小了。</p>
<p>那么问题来了，难道要不断的试来找到一个健康的分辨率吗？</p>
<p><strong>大小调整-2：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 1080_BXJG.mp4 -i logo.png -filter_complex <span class="string">&#x27;[1][0]scale2ref=w=oh*mdar:h=ih/8[scaled][0-out]; [0-out][scaled]overlay&#x27;</span> out.mp4</span></span><br></pre></td></tr></table></figure>
<p><code>scale2ref</code>滤镜有两个输入，它对第一个输入进行rescale，
但它与<code>scale</code>滤镜的区别在于，它使用第二个输入作为参考，来进行第一个输入的rescale。</p>
<p>这里的<code>[1][0]scale2ref=w=oh*mdar:h=ih/8[scaled][0-out]</code>中，ih指的就是参考输入<code>[0]</code>的宽度，
为了保证水印的横纵比，这里使用<code>oh*mdar</code>来定义水印的宽度。</p>
<p><img src="/images/media/FFmpeg/1-6.png" alt="image" title="水印分辨率调整"></p>
<p><strong>水印位置调整-1：</strong></p>
<p>可以看到上面水印都是贴着视频的左上角的，这里来对它的位置进行调整：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 1080_BXJG.mp4 -i logo.png -filter_complex <span class="string">&#x27;[1][0]scale2ref=w=oh*mdar:h=ih/8[scaled][0-out]; [0-out][scaled]overlay=x=300:y=300&#x27;</span> out.mp4</span></span><br></pre></td></tr></table></figure>
<p>可以通过指定overlay的坐标来确定水印覆盖的位置（默认x=0，y=0，即左上角），这里将坐标指定在300，300，效果如下：</p>
<p><img src="/images/media/FFmpeg/1-7.png" alt="image" title="水印位置调整"></p>
<p><strong>水印位置调整-2：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 1080_BXJG.mp4 -i logo.png -filter_complex <span class="string">&#x27;[1][0]scale2ref=w=oh*mdar:h=ih/8[scaled][0-out]; [0-out][scaled]overlay=x=main_w/10-w/2:y=main_h/10-h/2&#x27;</span> out.mp4</span></span><br></pre></td></tr></table></figure>
<p>这里<code>main_w</code>和<code>main_h</code>指的就是视频输入（<code>[0-out]</code>）的宽和高，<code>w</code>和<code>h</code>则是水印输入（<code>[scaled]</code>）的宽和高，
这里将水印的中心点指定在视频输入的1/10宽和1/10高的位置。</p>
<p><img src="/images/media/FFmpeg/1-8.png" alt="image" title="水印位置调整"></p>
<hr>
<h2 id="转hls"><a href="#转hls" class="headerlink" title="转hls"></a>转hls</h2><p>hls即包括一个m3u(8)的索引文件，TS媒体分片文件和key加密串文件。</p>
<p>在ffmpeg中可以使用hls或者segment来实现。</p>
<hr>
<h3 id="使用segment-muxer"><a href="#使用segment-muxer" class="headerlink" title="使用segment muxer"></a>使用segment muxer</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 1080_BXJG.mp4 -f segment -segment_format mpegts -segment_list playlist.m3u8 -segment_list_size 0 -segment_time 5 out%03d.ts</span></span><br></pre></td></tr></table></figure>
<p>上面的命令将输入视频切割为5秒一片的ts文件。其中，<code>-segment_list playlist.m3u8</code>设置文件list输出到playlist.m3u8，
<code>-segment_list_size 0</code>设置playlist.m3u8里面将包含所有切分出来的分片，
<code>-segment_time 5</code>设置分片大小为5秒。</p>
<p>得到如下结果：</p>
<p><img src="/images/media/FFmpeg/1-9.png" alt="image" title="segment muxer切分"></p>
<hr>
<h3 id="使用hls-muxer"><a href="#使用hls-muxer" class="headerlink" title="使用hls muxer"></a>使用hls muxer</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 1080_BXJG.mp4 -map 0 -f hls -hls_segment_type mpegts -hls_list_size 6 -hls_time 5 -hls_segment_filename <span class="string">&#x27;out%03d.ts&#x27;</span> playlist.m3u8</span></span><br></pre></td></tr></table></figure>
<p>参数基本一样，就不多解释了，效果如下：</p>
<p><img src="/images/media/FFmpeg/1-10.png" alt="image" title="hls muxer切分"></p>
<hr>
<h2 id="转码，水印，hls"><a href="#转码，水印，hls" class="headerlink" title="转码，水印，hls"></a>转码，水印，hls</h2><p>将上面的命令进行总结，可以融合得到下面这条命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i 1080_BXJG.mp4 -i logo.png \</span></span><br><span class="line"><span class="bash">    -filter_complex <span class="string">&#x27;[1][0]scale2ref=w=oh*mdar:h=ih/8[scaled][0-out]; \</span></span></span><br><span class="line"><span class="bash">    [0-out][scaled]overlay=x=main_w/10-w/2:y=main_h/10-h/2[over];[over]scale=w=1920:h=-1[out]<span class="string">&#x27; \</span></span></span><br><span class="line"><span class="bash">    -map [out] -c:v h264 -c:a mp3 \</span></span><br><span class="line"><span class="bash">    -f hls -hls_segment_type mpegts -hls_list_size 0 -hls_time 5 -hls_segment_filename <span class="string">&#x27;out%03d.ts&#x27;</span> playlist.m3u8</span></span><br></pre></td></tr></table></figure>
<p>这条命令将一个视频文件添加水印，并切割为5秒的ts小文件，同时将分辨率调整为1080P。</p>
<hr>
<h2 id="基于nginx的m3u8的点播、直播的实现"><a href="#基于nginx的m3u8的点播、直播的实现" class="headerlink" title="基于nginx的m3u8的点播、直播的实现"></a>基于nginx的m3u8的点播、直播的实现</h2><p>首先看我这里nginx的配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/nginx/nginx.conf</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       11111 default_server;</span><br><span class="line">        listen       [::]:11111 default_server;</span><br><span class="line">        server_name  long;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root html;</span><br><span class="line">            index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /hls &#123;</span><br><span class="line">            types &#123;</span><br><span class="line">                application/vnd.apple.mpegusr m3u8;</span><br><span class="line">                video/mp2t ts;</span><br><span class="line">            &#125;</span><br><span class="line">            root /mycephfs;</span><br><span class="line">            add_header Cache-Control no-cache;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>我这里将nginx的服务起在11111端口，文件目录为/mycephfs/hls，浏览器打开<code>192.168.90.233:11111</code>：</p>
<p><img src="/images/media/FFmpeg/1-11.png" alt="image" title="nginx"></p>
<p><strong>点播：</strong></p>
<p>将对应的hls文件放入nginx的文件目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ll /mycephfs/hls/videos/BXJG-hls/</span></span><br><span class="line"></span><br><span class="line">-rw-rw-r-- 1 cluster cluster 3938600 Aug 13 12:47 out000.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 1366196 Aug 13 12:47 out001.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster  926088 Aug 13 12:47 out002.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 3286992 Aug 13 12:47 out003.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 7581852 Aug 13 12:47 out004.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 1721516 Aug 13 12:47 out005.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 3373848 Aug 13 12:48 out006.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 3193556 Aug 13 12:48 out007.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 5041220 Aug 13 12:48 out008.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 3229088 Aug 13 12:48 out009.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster     370 Aug 13 12:48 playlist.m3u8</span><br></pre></td></tr></table></figure>
<p>直接使用potplayer打开链接<code>http://192.168.90.233:11111/hls/videos/BXJG-hls/playlist.m3u8</code>：</p>
<p><img src="/images/media/FFmpeg/1-12.png" alt="image" title="点播"></p>
<p>点播效果完成。</p>
<p><strong>直播：</strong></p>
<p>这里直播和点播的十分相似，它通过不断的修改<code>.m3u8</code>文件来达到直播的目的。</p>
<p>同样的，使用一个本地的视频文件当作输入流来进行直播，需要加入<code>-re</code>来模拟直播流的输入速度，<code>-stream_loop</code>来不断重复输入。
另外，这个过程会不断产生新的ts文件，需要将使用过的小文件删除，添加<code>-hls_list_size 5</code>将<code>.m3u8</code>文件中的数量控制为5个，
添加<code>-hls_flags delete_segments</code>开启自动删除过时的ts小文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -re -stream_loop -1 -i 1080_MS.mp4 -i logo.png \</span></span><br><span class="line"><span class="bash">  -filter_complex <span class="string">&#x27;[1][0]scale2ref=w=oh*mdar:h=ih/8[scaled][0-out];[0-out][scaled]overlay=x=main_w/10-w/2:y=main_h/10-h/2[over]&#x27;</span> \</span></span><br><span class="line"><span class="bash">  -map [over] -c:v h264 -map 0 -c:a copy \</span></span><br><span class="line"><span class="bash">  -f hls -hls_segment_type mpegts -hls_flags delete_segments -hls_list_size 5 -hls_time 10 -hls_segment_filename <span class="string">&#x27;out%05d.ts&#x27;</span> live.m3u8</span></span><br></pre></td></tr></table></figure>
<p>产生ts小文件的效果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /mycephfs/hls/videos/MS/</span></span><br><span class="line"></span><br><span class="line">total 49306</span><br><span class="line">-rw-rw-r-- 1 cluster cluster     227 Aug 14 16:41 live.m3u8</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 6638092 Aug 14 16:40 out00017.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 6406100 Aug 14 16:40 out00018.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 7560044 Aug 14 16:40 out00019.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 7581664 Aug 14 16:41 out00020.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 9148832 Aug 14 16:41 out00021.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 8171984 Aug 14 16:41 out00022.ts</span><br><span class="line">-rw-rw-r-- 1 cluster cluster 4980736 Aug 14 16:41 out00023.ts</span><br></pre></td></tr></table></figure>
<p>可以看到ffmpeg同一时刻只会保留6个ts文件。</p>
<p>同样的，使用potplayer打开连接<code>http://192.168.90.233:11111/hls/videos/MS/live.m3u8</code>，就可以看到直播，
和点播十分相似，不同之处在于，这里会不断的播放下去：</p>
<p><img src="/images/media/FFmpeg/1-13.png" alt="image" title="直播"></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ffmpeg.org/documentation.html">FFmpeg Documentation</a></p>
<p><a href="https://www.cnblogs.com/my_life/articles/6520155.html">使用FFMPEG生成HLS</a></p>
]]></content>
      <categories>
        <category>media</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP详解卷1：协议 第19、20、21章笔记</title>
    <url>/2019/08/14/2019-08-14-TCP-IP-19-20-21/</url>
    <content><![CDATA[<hr>
<h2 id="第19章-TCP的交互数据流"><a href="#第19章-TCP的交互数据流" class="headerlink" title="第19章 TCP的交互数据流"></a>第19章 TCP的交互数据流</h2><p>首先，上面叫交互数据流，原文解释：</p>
<ul>
<li>块数据：如FTP、电子邮件和Usenet新闻。</li>
<li>交互数据：如Telnet和Rlogin。</li>
</ul>
<p>那么交互数据流就是客户端与服务端需要频繁交互数据的那种数据流。</p>
<p>这一章主要以Rlogin举例，也就是远程登录。</p>
<hr>
<h3 id="信息交互过程"><a href="#信息交互过程" class="headerlink" title="信息交互过程"></a>信息交互过程</h3><p><img src="/images/network/tcp-ip/1-1.png" alt="image" title="信息交互过程"></p>
<p>在Rlogin的交互中，需要进行图上的信息传递：</p>
<ol>
<li>客户端告知服务端按键信息。</li>
<li>服务端的对按键信息的确认。</li>
<li>服务器告知客户端的按键显示信息（回显）。</li>
<li>客户端对按键显示信息的确认。</li>
</ol>
<p>在我们平常使用ssh的过程中可能感觉不到，这里每次只传送一个按键信息。</p>
<hr>
<h3 id="经受时延的确认"><a href="#经受时延的确认" class="headerlink" title="经受时延的确认"></a>经受时延的确认</h3><p>考虑到上面的交互过程，2和3步服务器有两个信息要传递给客户端，一个ACK信息，一个数据信息。</p>
<p>那么十分自然的想法，这两个信息如果用两个报文来传递有点浪费资源，因为它们可以不冲突的放在以一个报文里面。
（即<strong>数据捎带ACK</strong>）</p>
<p><img src="/images/network/tcp-ip/1-2.png" alt="image" title="ACK数据捎带"></p>
<p>如果要做到这一点，就要想到，服务器在收到按键信息后，需要经过一定时间的处理，然后才会发出回显信息，
那么很明显的，按键确认信息要比回显信息先构建出来，它们之间差多少时间无法确定，所以就有了这里<strong>经受时延的确认</strong>。</p>
<p><strong>经受时延的确认：</strong></p>
<blockquote>
<p>通常TCP在接收到数据时并不立即发送ACK；相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送（有时
称这种现象为数据捎带ACK）。绝大多数实现采用的时延为200ms，也就是说，TCP将以最大200ms的时延等待是否有数据一起发送。</p>
</blockquote>
<p>注意到这里说的是<strong>最大</strong>200ms时延，也就是这里有一个200ms定时器，但是<code>TCP使用了一个200 ms的定时器，该定时器以相对于内核引导的200 ms固定时间溢出</code>，
所以这个定时器不是在ACK开始等待的时候触发的，而是一定有的，ACK在等待的时候，就可能会在1~200ms的任意时刻碰到定时器溢出。</p>
<p>看书上给出的例子：</p>
<p><img src="/images/network/tcp-ip/1-3.png" alt="image" title="所等待的时延"></p>
<p>ACK等待时间为：123.5、65.6、109.0、132.2、42.0、140.3和195.8ms。
ACK发出时间为：139.9、539.3、940.1、1339.9、1739.9、1940.1和2140.1ms。</p>
<p>ACK发出时间相差均为200的整数倍，证明了这个200ms的定时器与ACK开始等待的时间无关，而是在200ms固定时间间隔溢出。</p>
<hr>
<h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><p>正如上面说的，Rlogin交互过程中<strong>每次只传送一个按键信息</strong>，比如你一瞬间打（粘贴）了个<code>abcdefg</code>，
结果它竟然是发送7个报文，分别报告这几个字母，如果网络资源并不是那么丰富的情况下，就有点太浪费了。
那么我们自然就想一次多发送几个字母过去，也就是Nagle算法做的事情。</p>
<p><strong>Nagle算法：</strong></p>
<blockquote>
<p>该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。
相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去。</p>
</blockquote>
<p>也就是当你按下字母<code>a</code>时，报文被发送，再按下<code>bcdefg</code>时，它们不会被发送，直到收到报文<code>a</code>的ACK，
这时就将<code>bcdefg</code>放在一个报文里面发送出去。</p>
<blockquote>
<p>该算法的优越之处在于它是自适应的：确认到达得越快，数据也就发送得越快。</p>
</blockquote>
<p>Nagle算法的目的在于减少网络中小分组的数目，但是实际上会增加整个发送过程的时延，
在延迟比较敏感的场景下，禁用它能提升体验。</p>
<hr>
<h3 id="窗口大小通告"><a href="#窗口大小通告" class="headerlink" title="窗口大小通告"></a>窗口大小通告</h3><p><img src="/images/network/tcp-ip/1-4.png" alt="image" title="窗口大小通告"></p>
<p>图中的<code>win 4096</code>、<code>win 8192</code>等就是窗口大小的通告，代表的是自己的接收窗口还有多少<strong>剩余空间</strong>。</p>
<p>注意上图的14~18报文：</p>
<ul>
<li><p>客户端通过14、15报文一共发送了4个字节（<code>14:18(4)</code>）的数据到服务器。</p>
</li>
<li><p>服务器回复<code>ACK 18</code>，表示收到了这4个字节的数据，但是只回显了3个字节<code>56:59(3)</code>，所以还留有1个字节数据未处理，此时窗口大小为$8191 = 8192 - 1$。</p>
</li>
<li><p>客户端确认回显（<code>ACK 59</code>），并继续发送3字节（<code>18:21(3)</code>）数据，但是窗口大小$4093 = 4096 - 3$，说明收到的3字节回显还没有处理。</p>
</li>
<li><p>服务器回复<code>ACK 21</code>，并发送回显1个字节<code>59:60(1)</code>，那么<code>18:21(3)</code>这3字节数据都还没处理，所以窗口大小为$8189 = 8192 - 3$。</p>
</li>
</ul>
<hr>
<h3 id="wireshark抓包测试"><a href="#wireshark抓包测试" class="headerlink" title="wireshark抓包测试"></a>wireshark抓包测试</h3><p>首先先建立一个ssh连接：</p>
<p><img src="/images/network/tcp-ip/1-6.png" alt="image" title="建立ssh链接"></p>
<p>开启wireshark抓包：</p>
<p><img src="/images/network/tcp-ip/1-7.png" alt="image" title="开始抓包"></p>
<p>敲一个a看什么效果：</p>
<p><img src="/images/network/tcp-ip/1-8.png" alt="image" title="输入a"></p>
<p><img src="/images/network/tcp-ip/1-9.png" alt="image" title="报文抓取"></p>
<p>可以看到一共发送了三个报文，和书上所述一致。</p>
<p>这里直接粘贴一个字符串<code>TCP</code>进去，结果如下：</p>
<p><img src="/images/network/tcp-ip/1-10.png" alt="image" title="粘贴TCP"></p>
<p><img src="/images/network/tcp-ip/1-11.png" alt="image" title="报文抓取"></p>
<p>可以看到这里显然同时为T、C、P三个字符分别发送了报文，可以看出，这里显然关闭了Nagle算法。</p>
<p>另外<code>.233</code>发送了三个回显报文，但是<code>.150</code>只发送了2个ACK，这显然是<code>经受时延的确认</code>带来的效果。</p>
<hr>
<hr>
<hr>
<h2 id="TCP的成块数据流"><a href="#TCP的成块数据流" class="headerlink" title="TCP的成块数据流"></a>TCP的成块数据流</h2><p>在上一节说的是有关于交互数据流的一些东西，这一节介绍了关于成块数据流上的一些东西。</p>
<p>这一章介绍了滑动窗口协议、PUSH标志、慢启动和紧急方式，这些概念。</p>
<hr>
<h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><p>在滑动窗口之前，书上已经介绍了停止等待协议（停等协议），这个协议十分简单：
<code>发送方发送一个报文之后，必须等到这个报文的ACK到来，才能发送下一个报文</code>。</p>
<p>在成块数据传输时（例如传一个文件），如果使用停等协议来进行传输，那么速度就太慢了，相当于每个RTT时间只能传输一个报文，
传输效率基本只与RTT时间有关，链路容量再大也是白给。所以这时候就需要同时传输多个报文，也就形成了滑动窗口协议。</p>
<p><img src="/images/network/tcp-ip/1-5.png" alt="image" title="滑动窗口"></p>
<p>如书中所给的图，1、2、3…10、11…等就表示报文，数字就是它们的序号。方框就表示当前时刻窗口的位置，
可以看到窗口外的左边是<strong>已发送并且已确认</strong>的报文，窗口外的右边是<code>还未发送也不能发送</code>的报文，
窗口内的左右两边则是<code>已发送但还未确认</code>、<code>未发送但可以发送</code>的报文。</p>
<p>显然之所以叫做滑动窗口，就是因为它会随着报文的发送确认而不断的向右滑动。</p>
<p>书中使用三个术语来描述窗口左右边沿的运动：</p>
<blockquote>
<ol>
<li>称窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。</li>
<li>当窗口右边沿向右移动时将允许发送更多的数据，我们称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了T C P的接收缓存时。</li>
<li>当右边沿向左移动时，我们称之为窗口收缩。<code>Host Requirements RFC</code>强烈建议不要使用这种方式。但TCP必须能够在某一端产生这种情况时进行处理。</li>
</ol>
</blockquote>
<p>另外注意到，<strong>一个ACK是对它之前所有报文的确认</strong>。</p>
<p><strong>窗口大小：</strong></p>
<p>需要注意到的是，滑动窗口<strong>存在于发送方</strong>，但是它的窗口的大小是由<strong>接收方提供的</strong>。</p>
<p>观察书中给出的例子：</p>
<p><img src="/images/network/tcp-ip/1-12.png" alt="image" title="窗口大小"></p>
<ul>
<li>在第二个报文（SYN）中，接收方通报窗口大小为<code>6144</code>，mss大小为<code>1024</code>。</li>
<li>由于窗口大小为<code>6144</code>，发送方直接发送了6个1024大小的报文。</li>
<li>接收方发出<code>ACK 6145</code>，通报窗口大小为<code>2048</code>。</li>
<li>发送方收到<code>ACK 6145</code>，刚才窗口内的6个报文全部被确认，窗口左边直接移动到6145字节位置，由于通报窗口大小为<code>2048</code>，窗口右边沿移动到<code>8192</code>位置。</li>
<li>发送方将现在窗口里面的两个报文发出。</li>
<li>接收方不断发出ACK，确认报文接收以及通报窗口大小，可惜发送方已经没有更多的数据发送了。</li>
</ul>
<hr>
<h3 id="PUSH标志"><a href="#PUSH标志" class="headerlink" title="PUSH标志"></a>PUSH标志</h3><p>可以看到上面的例子中，一些报文被设置了PSH标志，直接引用书中所述，描述了PUSH标志的作用：</p>
<blockquote>
<p>发送方使用该标志通知接收方将所收到的数据全部提交给接收进程。
这里的数据包括与PUSH一起传送的数据以及接收方TCP已经为接收进程收到的其他数据。</p>
</blockquote>
<p>这里描述了PUSH标志的用途：</p>
<blockquote>
<p>通过允许客户应用程序通知其TCP设置PUSH标志，
客户进程通知TCP在向服务器发送一个报文段时不要因等待额外数据而使已提交数据在缓存中滞留。
类似地，当服务器的TCP接收到一个设置了PUSH标志的报文段时，
它需要立即将这些数据递交给服务器进程而不能等待判断是否还会有额外的数据到达。</p>
</blockquote>
<p>也就是说，在没有设置PUSH的情况下，TCP收到数据之后，可能并不会立即上传给应用，也许它想要等到更多的数据到来再一起上传给应用，
以提高效率。</p>
<p>但是例如Rlogin这种交互式应用，每次就发送一个字节的数据过去，如果TCP想要等待更多的数据到来，则可能会增大延迟，
这时就需要PUSH标志来告知TCP不要进行等待，即使只收到一个字节数据，也要立即上传给应用。</p>
<p>但是书中又说了:</p>
<blockquote>
<p>然而，目前大多数的API没有向应用程序提供通知其TCP设置PUSH标志的方法。的确，
许多实现程序认为PUSH标志已经过时，一个好的TCP实现能够自行决定何时设置这个标志。</p>
</blockquote>
<p>需要注意到不同的TCP实现方式处理PUSH标志时可能也有所不同，
例如<code>由于源于伯克利的实现一般从不将接收到的数据推迟交付给应用程序，因此它们忽略所接收的PUSH标志。</code></p>
<p>PUSH标志通常在以下情形被设置：</p>
<ol>
<li>应用的一次数据写入完成。</li>
<li>发送缓冲区没有更多的数据等待发送。</li>
</ol>
<p>当然，还是有些时候还是挺玄学，具体还是要看使用TCP版本的实现。</p>
<hr>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>在滑窗协议那里所举的例子中，发送方首先就直接发送了6个报文，看起来这样可以提高发送效率，
但是实际中需要考虑整个路由路径上的拥塞情况，如果每个人都没有节制的发送自己的报文，
那么结果就是路径堵死，谁都别想成功发送报文。</p>
<p>为了避免这种情况，就需要每个人限制自己的发送速度，那么如何知道自己能以多快的速率发送呢？
既然全靠自觉，那么就只能一点点去试，逐渐增加自己的发送速度，直到丢包，这就是<strong>慢启动</strong>。</p>
<blockquote>
<p>慢启动为发送方的TCP增加了另一个窗口：拥塞窗口(congestion window)，记为cwnd。</p>
</blockquote>
<ul>
<li>当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。</li>
<li>每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。</li>
</ul>
<p>需要注意到发送方取<strong>拥塞窗口</strong>与<strong>通告窗口</strong>中的<strong>最小值</strong>作为发送上限。
<strong>拥塞窗口</strong>是<strong>发送方</strong>使用的流量控制，而<strong>通告窗口</strong>则是<strong>接收方</strong>使用的流量控制。</p>
<p>注意到虽然名字是<code>慢</code>启动，但是其实启动速度是指数增长的，如书上的例子（先不考虑通告窗口的大小）：</p>
<p><img src="/images/network/tcp-ip/1-13.png" alt="image" title="慢启动"></p>
<ul>
<li>初始化拥塞窗口大小为1，发送一个报文。</li>
<li>收到<code>ACK 513</code>，拥塞窗口大小增加为2，窗口右移，发送两个报文。</li>
<li>收到<code>ACK 1025</code>，拥塞窗口大小增加为3，窗口右移，发送两个报文。</li>
<li>收到<code>ACK 1537</code>，拥塞窗口大小增加为4，窗口右移，发送两个报文。</li>
<li>收到<code>ACK 2049</code>、<code>ACK 2561</code>，拥塞窗口大小增加为6，窗口右移，发送最后一个报文。</li>
</ul>
<p>在这一步时，一共发送了8个报文，收到了5个ACK，还有3个报文没有收到ACK，当这三个ACK都收到时，
拥塞窗口大小将变为9。</p>
<p>如果发出的报文ACK立刻返回，那么拥塞窗口的大小变化规律就是：</p>
<ul>
<li>1 -&gt; 2</li>
<li>2 -&gt; 4</li>
<li>4 -&gt; 8</li>
<li>…</li>
</ul>
<p>也就是一个RTT时间之后，窗口大小就会翻倍，所以说是指数增长。</p>
<hr>
<h3 id="成块数据的吞吐量"><a href="#成块数据的吞吐量" class="headerlink" title="成块数据的吞吐量"></a>成块数据的吞吐量</h3><blockquote>
<p>通常发送一个分组的时间取决于两个因素：
传播时延（由光的有限速率、传输设备的等待时间等引起）
和一个取决于媒体速率（即媒体每秒可传输的比特数）的发送时延。</p>
<p>对于一个给定的两个接点之间的通路，传播时延一般是固定的，而发送时延则取决于分组的大小。
在速率较慢的情况下发送时延起主要作用，而在千兆比特速率下传播时延则占主要地位。</p>
</blockquote>
<p>如书中所举的例子：</p>
<p><img src="/images/network/tcp-ip/1-14.png" alt="image" title="成块数据的吞吐量举例"></p>
<p>在例子中的最后时刻，发送方不断发送报文和接收ACK，已经填满了整个路径，
这时窗口的增加已经无法增加发送速率了，也就是<strong>连接的理想稳定状态</strong>。</p>
<p><strong>带宽时延乘积：</strong></p>
<p>这里给出了<strong>通道容量</strong>的计算公式，注意到它<strong>并不是</strong>吞吐量。</p>
<p>正如上面的例子中的图，如果一个报文完全写入通道需要时间A，RTT大小为B，
相当于发送方不间断的写入报文时，从第一个报文开始写入，直到第一个ACK到达发送方时，
发送方一共发送了$\frac{B}{A}$个报文。</p>
<p>假设一个报文的长度为C，那么<strong>通道容量为</strong>：</p>
<script type="math/tex; mode=display">
capacity(bit)=\frac{B}{A} * C = B * \frac{C}{A}</script><p>注意到B就是RTT时间，$\frac{C}{A}$就是链路带宽，即：</p>
<script type="math/tex; mode=display">
capacity(bit)=bandwidth(b/s) \times "round \ trip \ time(s)"</script><p>计算这个值的意义在于指导TCP的缓存大小，如果发送或者接收缓冲小于<strong>通道容量</strong>，
那么传输速度就一定达不到理论上的最大值，因为当发送缓冲塞满时，就会停止发送报文。</p>
<p><strong>拥塞：</strong></p>
<blockquote>
<p>当数据到达一个大的管道（如一个快速局域网）并向一个较小的管道（如一个较慢的广域网）发送时便会发生拥塞。
当多个输入流到达一个路由器，而路由器的输出流小于这些输入流的总和时也会发生拥塞。</p>
</blockquote>
<p>正如书中的例子：</p>
<p><img src="/images/network/tcp-ip/1-15.png" alt="image" title="瓶颈路由"></p>
<p>整个链路的链路带宽由最小的那部分决定。</p>
<hr>
<h3 id="紧急方式"><a href="#紧急方式" class="headerlink" title="紧急方式"></a>紧急方式</h3><blockquote>
<p>TCP提供了<code>紧急方式(urgent mode)</code>，它使一端可以告诉另一端有些具有某种方式的“紧急数据”已经放置在普通的数据流中。
另一端被通知这个紧急数据已被放置在普通数据流中，由接收方决定如何处理。</p>
</blockquote>
<p>这个东西目前还不好理解，它是一种在已有的TCP连接上传输紧急数据的方式。</p>
<p>具体参考：</p>
<p><a href="https://www.cnblogs.com/c-slmax/p/5553857.html">TCP带外数据</a></p>
<p><a href="https://blog.csdn.net/aprilweet/article/details/62421995">带外数据：TCP紧急模式分析</a></p>
<hr>
<hr>
<hr>
<h2 id="TCP的超时与重传"><a href="#TCP的超时与重传" class="headerlink" title="TCP的超时与重传"></a>TCP的超时与重传</h2><p><strong>TCP提供可靠的运输层</strong>，也就是说，使用TCP传输数据，它保证接收端能收到发送端所发给它的所有数据。</p>
<p>达到<strong>可靠</strong>的阻碍在于报文在传输过程中会发生丢包，而且你还无法知道这个丢包的发生，
所以就需要使用超时来判断是否丢包，使用重传来重新传输丢掉的数据。</p>
<hr>
<h3 id="往返时间测量"><a href="#往返时间测量" class="headerlink" title="往返时间测量"></a>往返时间测量</h3><blockquote>
<p>TCP超时与重传中最重要的部分就是对一个给定连接的往返时间（RTT）的测量。</p>
</blockquote>
<p>假设RTT时间为A秒，正常情况下，当一个报文发出后的A秒，发送方就应该接收到ACK，
那如果没有收到ACK，我们就有理由怀疑报文丢失了，考虑到网络的抖动，我们可能再等待一段时间，
如果这时还没有收到ACK，那么就可以考虑开始重传了。</p>
<p>所以，超时时间的计算是基于RTT时间的，在一个局域网里面，超时时间相比与一个广域网来说，肯定是要短一点的。</p>
<blockquote>
<p>首先TCP必须测量在发送一个带有特别序号的字节和接收到包含该字节的确认之间的RTT。</p>
</blockquote>
<p>注意到发送报文与ACK并不是一一对应的，一个报文2可以通过<code>ACK 5</code>来确认，所以这里书中表述为<code>接收到包含该字节的确认</code>。</p>
<p>由于这个问题和网络抖动会造成测量的RTT时间在一定范围内变化，那么这里就需要多次对RTT的测量来计算得到一个相对准确的值，
一种简单的平滑方式如下：</p>
<script type="math/tex; mode=display">
R \leftarrow \alpha R + (1 - \alpha ) M</script><p>其中$R$表示平滑得到的RTT，$M$表示测量得到的RTT，$\alpha$为平滑因子，推荐值0.9。</p>
<p>在<code>RFC 793</code>中推荐的重传超时时间<strong>RTO</strong>（Retransmission Time Out）的值应该设置为：</p>
<script type="math/tex; mode=display">
RTO=R \beta</script><p>这里的$\beta$为时延离散因子，推荐值为2。也就是说超时时间为2倍的RTT。</p>
<p><strong>Jacobson</strong>认为这种方式太简单，容易更不上网络的变化，他认为方差也是一个需要考虑的因素，
所以它提出了下面的RTO估计方法：</p>
<script type="math/tex; mode=display">
Err = M - A \\
A \leftarrow A + gErr \\
D \leftarrow D + h(|Err| - D) \\
RTO = A + 4D</script><p>这里$M$表示测量得到的RTT，$A$表示平滑得到的RTT，$D$表示平滑得到的均值偏差，$g$取值$\frac{1}{8}$，$h$取值0.25。</p>
<p>观察这个计算方式可以发现，当$Err$持续是一个很小的值，也就是RTT的测量值比较稳定时，$D$趋于0，RTO就趋于$A$，
也就是RTO就是RTT，而上面简单的计算公式中，RTO总是两倍的RTT。这其实很好理解，如果RTT的测量值比较稳定，
就证明RTT波动很小，一旦某个报文在一个RTT范围内没有ACK回来，那么它就是一个异常点，大概率是发生了丢包，
所以立刻开始重传，而不是等待两倍的RTT时间。</p>
<p><strong>Karn算法：</strong></p>
<blockquote>
<p>在重传数据的确认最后到达之前，不能更新RTT估计器。</p>
</blockquote>
<p>因为所收到的重传数据的ACK，无法确定是哪一次重传报文的ACK。</p>
<p>另外，在重传数据时，已经采用了<strong>指数退避</strong>的策略来计算RTO，每次重传都将RTO乘2。</p>
<p><strong>往返时间RTT的测量：</strong></p>
<blockquote>
<p>大多数源于伯克利的TCP实现在任何时候对每个连接仅测量一次RTT值。
在发送一个报文段时，如果给定连接的定时器已经被使用，则该报文段不被计时。</p>
</blockquote>
<p>这里的定时器使用<strong>滴答计数器</strong>来进行：</p>
<p><img src="/images/network/tcp-ip/1-17.png" alt="image" title="滴答"></p>
<p>可以看到对于RTT的测量并不是精确的，而是通过它经历了几个滴答来计算它的时间，
就像图中的第一次测量，即使实际上是1.061秒，但是它经过了3个滴答，所以被记录为1.5秒。</p>
<p><strong>RTO的初始化以及重传时的计算：</strong></p>
<blockquote>
<p>变量$A$和$D$分别被初始化为0和3秒。</p>
</blockquote>
<p>也就是说初始的重传时间就是：</p>
<script type="math/tex; mode=display">
RTO_{init}=A+2D=0 + 2 \times 3 = 6s</script><blockquote>
<p>因子2D只在这个初始化计算中使用。正如前面提到的，以后使用4D和A相加来计算RTO。</p>
</blockquote>
<p>那么第一次超时时间就是6s，当接着发生第二次超时的情况下，首先使用正确的公式计算$RTO_1$，再进行指数退避（乘2）：</p>
<script type="math/tex; mode=display">
RTO_2 = 2 RTO_1 = 2 (A + 4D) = 2(0 + 4 \times 3) = 24s</script><p>再往后接着进行指数退避：</p>
<ul>
<li>$RTO_3 = 2RTO_2 = 48s$</li>
<li>$RTO_4 = 2RTO_3 = 64s$</li>
<li>$RTO_5 = 64s$</li>
<li>$RTO_6 = 64s$</li>
<li>$RTO_7 = 64s$</li>
<li>…</li>
</ul>
<p><img src="/images/network/tcp-ip/1-16.png" alt="image" title="RTO初始时的变化情况"></p>
<p><strong>注意到指数退避的最大值为64s</strong>。</p>
<hr>
<h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h3><blockquote>
<p>拥塞避免算法是一种处理丢失分组的方法。 </p>
<p>该算法假定由于分组受到损坏引起的丢失是非常少的（远小于1%），
因此分组丢失就意味着在源主机和目的主机之间的某处网络上发生了拥塞。 </p>
<p>有<strong>两种</strong>分组丢失的指示：发生超时和接收到重复的确认。</p>
</blockquote>
<p>注意到之前说了慢启动算法，它会一直增加cwnd窗口大小，那么这样增长下去，很可能到达一个上限，造成网络拥塞，
以至于产生丢包。那么此时仅仅重传丢失的报文是不够的，因为现在的cwnd窗口大小明显是过大了的，
所以还要将它缩小，这就是这里的<strong>拥塞避免算法</strong>。</p>
<p>拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口cwnd和一个慢启动门限ssthresh。</p>
<p>这样得到的算法的工作过程如下：</p>
<ol>
<li><p>对一个给定的连接，初始化cwnd为1个报文段，ssthresh为65535个字节。</p>
</li>
<li><p>TCP输出例程的输出不能超过cwnd和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制，
而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计，
而后者则与接收方在该连接上的可用缓存大小有关。</p>
</li>
<li><p>当拥塞发生时（超时或收到重复确认），ssthresh被设置为当前窗口大小的一半
（cwnd和接收方通告窗口大小的最小值，但最少为2个报文段）。
此外，如果是超时引起了拥塞，则cwnd被设置为1个报文段（这就是慢启动）。</p>
</li>
<li><p>当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免。
如果cwnd小于或等于ssthresh，则正在进行慢启动，否则正在进行拥塞避免。
慢启动一直持续到我们回到当拥塞发生时所处位置的一半时候才停止（因为我们记录了在步骤2中给我们制造麻烦的窗口大小的一半），
然后转为执行拥塞避免。</p>
</li>
</ol>
<p><strong>ssthresh</strong>：标记上一次拥塞发生时，窗口大小的一半。</p>
<p>也就是说，首先慢启动（其实是指数增长），然后为了降低窗口增长速度，
所以需要在cwnd超过ssthresh时，降低窗口的增长速度，进入拥塞避免增长模式。</p>
<p><strong>拥塞避免</strong>：求每次收到一个确认时将cwnd增加1/cwnd。也就是说一个往返时间内最多为cwnd增加1个报文段。</p>
<p><img src="/images/network/tcp-ip/1-18.png" alt="image" title="从慢启动到拥塞避免"></p>
<hr>
<h3 id="快速重传与快速恢复算法"><a href="#快速重传与快速恢复算法" class="headerlink" title="快速重传与快速恢复算法"></a>快速重传与快速恢复算法</h3><blockquote>
<p>在收到一个失序的报文段时，TCP立即需要产生一个ACK（一个重复的ACK）。
这个重复的ACK不应该被迟延。
该重复的ACK的目的在于让对方知道收到一个失序的报文段，并告诉对方自己希望收到的序号。</p>
</blockquote>
<p>直接先来看算法过程：</p>
<ol>
<li><p>当收到第3个重复的ACK时（不算第一个正常的ACK），将ssthresh设置为当前拥塞窗口cwnd的一半。重传丢失的报文段。
设置cwnd为ssthresh加上3倍的报文段大小。</p>
</li>
<li><p>每次收到另一个重复的ACK时，cwnd增加1个报文段大小并发送1个分组（如果新的cwnd允许发送）。</p>
</li>
<li><p>当下一个确认新数据的ACK到达时，设置cwnd为ssthresh（在第1步中设置的值）。
这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认。
另外，这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认。
这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半。</p>
</li>
</ol>
<p>这个算法由<strong>收到3个重复的ACK</strong>而启动，其中的道理在于：</p>
<ul>
<li><p>首先TCP的发送顺序并不等于接收顺序，后发送的报文可能先被接收方所接收，这时也会产生重复ACK，所以这个值不能定得太小。</p>
</li>
<li><p>这大概率证明了这个ACK之后的那个报文丢失，所以无需等到超时重传计时器，而是立即重传。</p>
</li>
<li><p>丢失报文后面至少有三个报文得到了接收，并且ACK也成功的传送了回来，侧面证明了网络状况还好，所以没有必要直接进行慢启动。</p>
</li>
<li><p>每一个新的重复ACK，就代表一个报文被接收，更加证明了网络状况并不差。</p>
</li>
</ul>
<p><img src="/images/network/tcp-ip/1-19.png" alt="image" title="拥塞避免的例子"></p>
<p>看上面书中所举的例子，可以看到它的各个变量的变化情况就与上面的算法描述一致。</p>
<hr>
<h3 id="按每条路由进行度量"><a href="#按每条路由进行度量" class="headerlink" title="按每条路由进行度量"></a>按每条路由进行度量</h3><blockquote>
<p>当一个TCP连接关闭时，如果已经发送了足够多的数据来获得有意义统计资料，且目的结点的路由表项不是一个默认的表项，
那么下列信息就保存在路由表项中以备下次使用：被平滑的RTT、被平滑的均值偏差以及慢启动门限。
所谓“足够多的数据”是指16个窗口的数据，这样就可得到16个RTT采样，从而使被平滑的RTT过滤器能够集中在正确结果的5%以内。</p>
<p>当建立一个新的连接时，不论是主动还是被动，
如果该连接将要使用的路由表项已经有这些度量的值，则用这些度量来对相应的变量进行初始化。</p>
</blockquote>
<hr>
<h3 id="ICMP的差错"><a href="#ICMP的差错" class="headerlink" title="ICMP的差错"></a>ICMP的差错</h3><blockquote>
<p>TCP能够遇到的最常见的ICMP差错就是源站抑制、主机不可达和网络不可达。</p>
</blockquote>
<p>当前基于伯克利的实现对这些错误的处理是：</p>
<ol>
<li><p>一个接收到的源站抑制引起拥塞窗口cwnd被置为1个报文段大小来发起慢启动，但是慢启动门限ssthresh没有变化，
所以窗口将打开直至它或者开放了所有的通路（受窗口大小和往返时间的限制）或者发生了拥塞。</p>
</li>
<li><p>一个接收到的主机不可达或网络不可达实际上都被忽略，因为这两个差错都被认为是短暂现象。
这有可能是由于中间路由器被关闭而导致选路协议要花费数分钟才能稳定到另一个替换路由。
在这个过程中就可能发生这两个ICMP差错中的一个，但是连接并不必被关闭。
相反，TCP试图发送引起该差错的数据，尽管最终有可能会超时。
当前基于伯克利的实现记录发生的ICMP差错，如果连接超时，ICMP差错被转换为一个更合适的的差错码而不是“连接超时”。</p>
</li>
</ol>
<p>需要了解到对于ICMP的差错，TCP有针对的处理就行了。</p>
<hr>
<h3 id="重新分组"><a href="#重新分组" class="headerlink" title="重新分组"></a>重新分组</h3><blockquote>
<p>当TCP超时并重传时，它不一定要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，
这将有助于提高性能（当然，这个较大的报文段不能够超过接收方声明的MSS）。
在协议中这是允许的，因为TCP是使用字节序号而不是报文段序号来进行识别它所要发送的数据和进行确认。</p>
</blockquote>
<p>观察书中所举的例子：</p>
<p><img src="/images/network/tcp-ip/1-20.png" alt="image" title="重新分组"></p>
<p>可以看到<code>13:27</code>字节在重传过程中，又键入了6个字符，于是重传就变成了<code>13:33</code>字节，这就是TCP的重新分组。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/aprilweet/article/details/62421995">带外数据：TCP紧急模式分析</a></p>
<p><a href="https://www.cnblogs.com/c-slmax/p/5553857.html">TCP带外数据</a></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树(Segment Tree)进阶使用记录(HDU3397)</title>
    <url>/2019/08/18/2019-08-21-segment-tree/</url>
    <content><![CDATA[<hr>
<h2 id="线段树的进阶"><a href="#线段树的进阶" class="headerlink" title="线段树的进阶"></a>线段树的进阶</h2><p>在前一篇博客中<a href="http://longrm.com/2019/08/16/2019-08-16-segment-tree/">线段树(Segment Tree)使用记录</a>，介绍了基础的线段树形式。</p>
<p>这一篇讨论以下进阶的使用，主要针对<code>lazy标志</code>。</p>
<p>上一篇博客中对于一个区间的修改只是<strong>单点修改</strong>，但是有时候会碰到<strong>区间修改</strong>的情况，这时基本的线段树可能就不适用了。</p>
<p>这时就需要针对<strong>区间修改</strong>来对区间树的更新方式进行变化。</p>
<p><strong>下面先假设问题为，初始给定一个数组：</strong></p>
<ul>
<li>修改操作包括：区间加上一个数，或者区间减去一个数。</li>
<li>查询操作包括：区间的求和。</li>
</ul>
<hr>
<h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>上一篇博客中使用的是<strong>至底向上</strong>的建树方式，这样的建树方法可以最大化空间利用率（2n空间即可），但是这样会造成一些处理上的困难，如图：</p>
<div align="center"><img src="/images/algorithm/SegmentTree_1.png"
style="zoom:70%" title="至底向上" /></div>

<p>图中点1、2其实在整颗树的最右边，而3、4、5、6却在左边，这样的节点排列方式对于区间修改是不利的（会造成逻辑上的混乱）。</p>
<p>所以可以使用<strong>至顶向下</strong>的建树方式，也就是递归建树：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> node, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        table[node] = arr[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    buildTree(l, mid, left(node), arr);</span><br><span class="line">    buildTree(mid+<span class="number">1</span>, r, right(node), arr);</span><br><span class="line">    pushUp(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将区间的左边放到左子树，右边放到右子树来进行递归建树，注意在建立完毕左右子树之后更新本节点信息（<code>pushUp(node)</code>）。</p>
<div align="center"><img src="/images/algorithm/SegmentTree_3.png"
style="zoom:70%" title="至顶向下" /></div>

<p>可以看到上面就是<strong>至顶向下</strong>所建立的树的结构，节点序号从左向右排列，但是这样带来的问题就是增加了空间占用（上图中数组大小14）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SegmentTreeLazySum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        i = i &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    table = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*i];</span><br><span class="line">    lazy = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*i];</span><br><span class="line">    buildTree(<span class="number">0</span>, n-<span class="number">1</span>, <span class="number">1</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用上面的方式来确定所需数组大小，也就是假如最后一层需要能放下n个元素，最小的i使得$2^i &gt; n$。</p>
<hr>
<h2 id="lazy标记"><a href="#lazy标记" class="headerlink" title="lazy标记"></a>lazy标记</h2><p>在进行区间修改时，我们不可能像单点修改一样，将所有节点的值都修改，因为在查询时，可能只需要上层节点的信息就可以完成查询。</p>
<p>例如将整个数组所有点都增加1，然后询问整个数组的求和，这时我们只需要在根节点上之前所记录的求和加上整个数组的长度即可。</p>
<p>这样的思想就是为了降低算法复杂度，对于一个区间的修改，我们先欠着，当必要的时候才进行修改。</p>
<p><code>update</code>方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [L, R]为原始更新区间，[x, y]为当前节点node所包含的区间</span></span><br><span class="line"><span class="comment">// t为操作类型，c为操作数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> c, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( y &lt; L || x &gt; R ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= x &amp;&amp; y &lt;= R) &#123;</span><br><span class="line">        c = t == <span class="number">0</span> ? c : -c;</span><br><span class="line">        table[node] += (y - x + <span class="number">1</span>) * c;</span><br><span class="line">        lazy[node] += c;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lazyDown(node, y - x + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (x + y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    update(t, L, R, c,  x, mid, left(node));</span><br><span class="line">    update(t, L, R, c, mid+<span class="number">1</span>, y, right(node));</span><br><span class="line">    pushUp(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里lazy标记就代表需要加上的数（使用正负来代表原始的加减）。</strong></p>
<p>可以看到：</p>
<ol>
<li>当发现整个子区间都包含在更新区间中时，就可以停止更新下传，更新节点值与lazy标记即可。</li>
<li>当子区间部分包含在更新区间中时，就需要下传更新，那么此时就需要先将之前的lazy标记给下传了。</li>
<li>完成左右儿子的更新后，记得更新本节点（<code>pushUp(node)</code>）。</li>
</ol>
<p>那么这里就涉及到了<code>lazyDown</code>函数，这个函数根据不同的情况会有很大的变化，这里因为只涉及加减法，所以比较简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lazyDown</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazy[node] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = left(node), r = right(node);</span><br><span class="line">    lazy[l] += lazy[node];</span><br><span class="line">    table[l] += lazy[node] * (len - (len &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    lazy[r] += lazy[node];</span><br><span class="line">    table[r] += lazy[node] * (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    lazy[node] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为只是加减法，所以子节点的lazy标记单纯加上父节点的lazy标记即可，当然同时也要记得更新子节点的值。</p>
<hr>
<h2 id="查询操作"><a href="#查询操作" class="headerlink" title="　查询操作"></a>　查询操作</h2><p>查询操作就递归向下即可，当然记得需要下传lazy标记：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( y &lt; L || x &gt; R ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= x &amp;&amp; y &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span> table[node];</span><br><span class="line">    &#125;</span><br><span class="line">    lazyDown(node, y - x + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mid = (x + y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    res += query(L, R, x, mid, left(node));</span><br><span class="line">    res += query(L, R,mid+<span class="number">1</span>, y, right(node));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>注意这里所针对的问题，初始给定一个数组：</p>
<ul>
<li>修改操作包括：区间加上一个数，或者区间减去一个数。</li>
<li>查询操作包括：区间的求和。</li>
</ul>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeLazySum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] lazy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegmentTreeLazySum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            i = i &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*i];</span><br><span class="line">        lazy = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*i];</span><br><span class="line">        buildTree(<span class="number">0</span>, n-<span class="number">1</span>, <span class="number">1</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> node, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">            table[node] = arr[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        buildTree(l, mid, left(node), arr);</span><br><span class="line">        buildTree(mid+<span class="number">1</span>, r, right(node), arr);</span><br><span class="line">        pushUp(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left(node), r = right(node);</span><br><span class="line">        table[node] = table[l] + table[r];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lazyDown</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy[node] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = left(node), r = right(node);</span><br><span class="line">        lazy[l] += lazy[node];</span><br><span class="line">        table[l] += lazy[node] * (len - (len &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        lazy[r] += lazy[node];</span><br><span class="line">        table[r] += lazy[node] * (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        lazy[node] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> c, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( y &lt; L || x &gt; R ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= x &amp;&amp; y &lt;= R) &#123;</span><br><span class="line">            c = t == <span class="number">0</span> ? c : -c;</span><br><span class="line">            table[node] += (y - x + <span class="number">1</span>) * c;</span><br><span class="line">            lazy[node] += c;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lazyDown(node, y - x + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (x + y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        update(t, L, R, c,  x, mid, left(node));</span><br><span class="line">        update(t, L, R, c, mid+<span class="number">1</span>, y, right(node));</span><br><span class="line">        pushUp(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( y &lt; L || x &gt; R ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= x &amp;&amp; y &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">return</span> table[node];</span><br><span class="line">        &#125;</span><br><span class="line">        lazyDown(node, y - x + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, mid = (x + y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        res += query(L, R, x, mid, left(node));</span><br><span class="line">        res += query(L, R,mid+<span class="number">1</span>, y, right(node));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idx &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (idx &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试用例：</span></span><br><span class="line">    <span class="comment">// 输入：</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 5 5</span></span><br><span class="line">    <span class="comment">// 1 1 1 1 1</span></span><br><span class="line">    <span class="comment">// 2 2 4 7</span></span><br><span class="line">    <span class="comment">// 1 1 3 4</span></span><br><span class="line">    <span class="comment">// 0 0 4 2</span></span><br><span class="line">    <span class="comment">// 1 1 4 8</span></span><br><span class="line">    <span class="comment">// 2 2 4 3</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 输出：</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// -23</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; T; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n, m, t, x, y, c;</span><br><span class="line">            n = sc.nextInt();</span><br><span class="line">            m = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                arr[i] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            SegmentTreeLazySum hdu = <span class="keyword">new</span> SegmentTreeLazySum(n, arr);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                t = sc.nextInt();</span><br><span class="line">                x = sc.nextInt();</span><br><span class="line">                y = sc.nextInt();</span><br><span class="line">                c = sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</span><br><span class="line">                    System.out.println(hdu.query(x, y, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hdu.update(t, x, y, c,<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="HDU3397"><a href="#HDU3397" class="headerlink" title="HDU3397"></a>HDU3397</h2><p>这个题目是一个比较典型的线段树题，初始给定一个数组，操作包括：</p>
<ul>
<li>0：将区间[x, y]全部置为0；</li>
<li>1：将区间[x, y]全部置为1；</li>
<li><p>2：将区间[x, y]中的1变为0，0变为1；</p>
</li>
<li><p>3：查询区间[x, y]中1的数量；</p>
</li>
<li>4：查询区间[x, y]中连续出现1的最多的次数。</li>
</ul>
<p><strong>这道题的难点一在于查询<code>4</code></strong>，因为在一个节点上，我们需要通过它的两个子节点的信息来得到连续1的数量。</p>
<p>对于这个问题，可以考虑这样来解决，在一个节点上，我们保存如下信息：</p>
<ol>
<li>贴着区间左边的连续1的数量<code>LLen</code>。</li>
<li>贴着区间右边的连续1的数量<code>RLen</code>。</li>
<li>区间中的最大连续1的数量<code>MLen</code>。</li>
</ol>
<p>那么对于一个节点，它的相关信息可以这样计算得到：</p>
<ol>
<li><code>LLen</code>：等于左儿子的<code>LLen</code>。但是需要注意，如果左儿子的<code>LLen</code>等于整个区间的长度，那么就为<strong>左儿子的<code>LLen</code></strong>加上右儿子的<code>LLen</code>。</li>
<li><code>RLen</code>：同上。</li>
<li><code>MLen</code>：等于 左儿子的<code>MLen</code>，右儿子的<code>MLen</code>，左儿子的<code>RLen</code>加上右儿子的<code>LLen</code> 的最大值。</li>
</ol>
<p><strong>这道题的难点二在于操作<code>2</code></strong>，如何在一个节点上完成信息的更新，主要是<code>LLen</code>、<code>RLen</code>、<code>MLen</code>信息的变化？</p>
<p>为了完成这个件事，这里对称的将连续0的数量保存下来<code>ZLLen</code>、<code>ZRLen</code>、<code>ZMLen</code>，这样在进行操作2时，
就可以将<code>LLen</code>、<code>RLen</code>、<code>MLen</code>和<code>ZLLen</code>、<code>ZRLen</code>、<code>ZMLen</code>的信息交换即可。</p>
<p><strong>整个代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HDU3397</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] Ztable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] MLen;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] LLen;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] RLen;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] ZLLen;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] ZRLen;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] ZMLen;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] lazy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HDU3397</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            i = i &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*i];</span><br><span class="line">        Ztable = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*i];</span><br><span class="line">        lazy = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*i];</span><br><span class="line">        MLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*i];</span><br><span class="line">        LLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*i];</span><br><span class="line">        RLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*i];</span><br><span class="line">        ZLLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*i];</span><br><span class="line">        ZRLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*i];</span><br><span class="line">        ZMLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*i];</span><br><span class="line">        Arrays.fill(lazy, -<span class="number">1</span>);</span><br><span class="line">        buildTree(<span class="number">0</span>, n-<span class="number">1</span>, <span class="number">1</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> node, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">            table[node] = MLen[node] = LLen[node] = RLen[node] = arr[l];</span><br><span class="line">            Ztable[node] = ZLLen[node] = ZRLen[node] = ZMLen[node] = <span class="number">1</span> - arr[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        buildTree(l, mid, left(node), arr);</span><br><span class="line">        buildTree(mid+<span class="number">1</span>, r, right(node), arr);</span><br><span class="line">        pushUp(node, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> lenL, <span class="keyword">int</span> lenR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left(node), r = right(node);</span><br><span class="line">        table[node] = table[l] + table[r];</span><br><span class="line">        Ztable[node] = Ztable[l] + Ztable[r];</span><br><span class="line"></span><br><span class="line">        LLen[node] = LLen[l] == lenL ? LLen[l] + LLen[r] : LLen[l];</span><br><span class="line">        RLen[node] = RLen[r] == lenR ? RLen[r] + RLen[l] : RLen[r];</span><br><span class="line"></span><br><span class="line">        ZLLen[node] = ZLLen[l] == lenL ? ZLLen[l] + ZLLen[r] : ZLLen[l];</span><br><span class="line">        ZRLen[node] = ZRLen[r] == lenR ? ZRLen[r] + ZRLen[l] : ZRLen[r];</span><br><span class="line"></span><br><span class="line">        MLen[node] = Math.max(MLen[l], MLen[r]);</span><br><span class="line">        MLen[node] = Math.max(MLen[node], RLen[l] + LLen[r]);</span><br><span class="line"></span><br><span class="line">        ZMLen[node] = Math.max(ZMLen[l], ZMLen[r]);</span><br><span class="line">        ZMLen[node] = Math.max(ZMLen[node], ZRLen[l] + ZLLen[r]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lazyDown</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span> || lazy[node] == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = left(node), r = right(node);</span><br><span class="line">        lazyHelper2(lazy[node], l, len - (len &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        lazyHelper2(lazy[node], r, len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        lazy[node] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lazyHelper</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy[node] == <span class="number">0</span>) &#123;</span><br><span class="line">            table[node] = LLen[node] = RLen[node] = MLen[node] = <span class="number">0</span>;</span><br><span class="line">            Ztable[node] = ZLLen[node] = ZRLen[node] = ZMLen[node] = len;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lazy[node] == <span class="number">1</span>) &#123;</span><br><span class="line">            table[node] = LLen[node] = RLen[node] = MLen[node] = len;</span><br><span class="line">            Ztable[node] = ZLLen[node] = ZRLen[node] = ZMLen[node] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lazy[node] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp0 = table[node], tmp1 = LLen[node], tmp2 = RLen[node], tmp3 = MLen[node];</span><br><span class="line">            table[node] = Ztable[node];</span><br><span class="line">            LLen[node] = ZLLen[node];</span><br><span class="line">            RLen[node] = ZRLen[node];</span><br><span class="line">            MLen[node] = ZMLen[node];</span><br><span class="line">            Ztable[node] = tmp0;</span><br><span class="line">            ZLLen[node] = tmp1;</span><br><span class="line">            ZRLen[node] = tmp2;</span><br><span class="line">            ZMLen[node] = tmp3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lazyHelper2</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> node, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lazy[node] == -<span class="number">1</span>) &#123;</span><br><span class="line">                lazy[node] = t;</span><br><span class="line">                lazyHelper(node, len);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lazy[node] == <span class="number">2</span>) &#123;</span><br><span class="line">                lazyHelper(node, len);</span><br><span class="line">                lazy[node] = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lazy[node] = <span class="number">1</span> - lazy[node];</span><br><span class="line">                lazyHelper(node, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lazy[node] = t;</span><br><span class="line">            lazyHelper(node, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( y &lt; L || x &gt; R ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= x &amp;&amp; y &lt;= R) &#123;</span><br><span class="line">            lazyHelper2(t, node, y - x + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lazyDown(node, y - x + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (x + y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        update(t, L, R, x, mid, left(node));</span><br><span class="line">        update(t, L, R, mid+<span class="number">1</span>, y, right(node));</span><br><span class="line">        pushUp(node, mid - x + <span class="number">1</span>, y - mid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query3</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( y &lt; L || x &gt; R ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= x &amp;&amp; y &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">return</span> table[node];</span><br><span class="line">        &#125;</span><br><span class="line">        lazyDown(node, y - x + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, mid = (x + y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        res += query3(L, R, x, mid, left(node));</span><br><span class="line">        res += query3(L, R,mid+<span class="number">1</span>, y, right(node));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在进行查询4的时候，由于左右儿子都可能只有一部分与查询区间相交，</span></span><br><span class="line">    <span class="comment">// 所有需要一个结构体来存储相交部分的相关信息。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Ans</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> LLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> RLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> MLen = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Ans</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Ans</span><span class="params">(<span class="keyword">int</span> LLen, <span class="keyword">int</span> RLen, <span class="keyword">int</span> MLen)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.LLen = LLen;</span><br><span class="line">            <span class="keyword">this</span>.RLen = RLen;</span><br><span class="line">            <span class="keyword">this</span>.MLen = MLen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query4</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query4Helper(L, R, x, y, node).MLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Ans <span class="title">query4Helper</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( y &lt; L || x &gt; R ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ans();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= x &amp;&amp; y &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ans(LLen[node], RLen[node], MLen[node]);</span><br><span class="line">        &#125;</span><br><span class="line">        lazyDown(node, y - x + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res1 = <span class="number">0</span>, res2 = <span class="number">0</span>, res3 = <span class="number">0</span>, mid = (x + y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Ans ans1 = query4Helper(L, R, x, mid, left(node));</span><br><span class="line">        Ans ans2 = query4Helper(L, R, mid+<span class="number">1</span>, y, right(node));</span><br><span class="line">        res1 = ans1.LLen == (mid - x + <span class="number">1</span>) ? ans1.LLen + ans2.LLen : ans1.LLen;</span><br><span class="line">        res2 = ans2.RLen == (y - mid) ? ans2.RLen + ans1.RLen : ans2.RLen;</span><br><span class="line">        res3 = Math.max(ans1.MLen, ans2.MLen);</span><br><span class="line">        res3 = Math.max(res3, ans1.RLen + ans2.LLen);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Ans(res1, res2, res3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idx &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (idx &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; T; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n, m, t, x, y;</span><br><span class="line">            n = sc.nextInt();</span><br><span class="line">            m = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                arr[i] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            HDU3397 hdu = <span class="keyword">new</span> HDU3397(n, arr);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                t = sc.nextInt();</span><br><span class="line">                x = sc.nextInt();</span><br><span class="line">                y = sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span> (t == <span class="number">3</span>) &#123;</span><br><span class="line">                    System.out.println(hdu.query3(x, y, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">4</span>) &#123;</span><br><span class="line">                    System.out.println(hdu.query4(x, y, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hdu.update(t, x, y, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较基础，速度与使用空间都不怎么样，但是至少AC了：</p>
<p><img src="/images/algorithm/SegmentTree_4.png" alt="image" title="运行结果"></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>线段树有很多不同的形式，而且很多时候根据题目的不同会有很多的小变化。</p>
<p>最重要的是<strong>代码一般较长，逻辑一般较乱</strong>，所有很容易<strong>出BUG</strong>，建议保持好<strong>心态</strong>。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang基础学习</title>
    <url>/2019/08/29/2019-08-29-golang-learn-1/</url>
    <content><![CDATA[<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>众所周知Java里面是没有指针的，但是有自动垃圾回收机制。C++是有指针的，但是没有自动垃圾回收。</p>
<p>Golang是一种新的语言，很多地方的设计借鉴了以前的语言，例如它是有指针的，并且有自动垃圾回收机制。</p>
<p>（主要代表着我需要进行指针的学习…）</p>
<hr>
<h1 id="Go语言基础学习"><a href="#Go语言基础学习" class="headerlink" title="Go语言基础学习"></a>Go语言基础学习</h1><p>这方面去看一些教程就好：</p>
<p>首先菜鸟教程，内容不多，比较简单和基础：</p>
<p><a href="https://www.runoob.com/go/go-tutorial.html">Go 语言教程 | 菜鸟教程</a></p>
<p>然后可以看看知乎上是怎么推荐学习Go语言的：</p>
<p><a href="https://www.zhihu.com/question/30461290/answer/210414739">系统学习GO，推荐几本靠谱的书?</a></p>
<p>然后还有官方的教程，有英文版的，也有中文版的，非常详细：</p>
<p><a href="https://golang.google.cn/doc/">Documentation - The Go Programming Language</a></p>
<p><a href="https://go-zh.org/doc/">文档 - Go 编程语言</a></p>
<p>当然看上面的东西估计很快就烦了，那么不想看上面的就<strong>直接看</strong>官方提供的这个，真是个有意思的东西:</p>
<p><a href="https://tour.go-zh.org/welcome/1">Go 语言之旅</a></p>
<hr>
<h1 id="牛顿法（练习：循环与函数）"><a href="#牛顿法（练习：循环与函数）" class="headerlink" title="牛顿法（练习：循环与函数）"></a>牛顿法（练习：循环与函数）</h1><p>在教程<a href="https://tour.go-zh.org/flowcontrol/8">练习：循环与函数</a>中，要求我们实现一个求解平方根的函数，
方法就是使用牛顿法，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	z := <span class="number">1.0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		z -= (z*z - x) / (<span class="number">2</span> * z)</span><br><span class="line">		fmt.Println(z)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Sqrt(<span class="number">1123415</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">561708</span><br><span class="line">280854.99999910983</span><br><span class="line">140429.49999065354</span><br><span class="line">70218.74992055642</span><br><span class="line">35117.37435503582</span><br><span class="line">17574.682322665183</span><br><span class="line">8819.302336487126</span><br><span class="line">4473.341863784877</span><br><span class="line">2362.238687969266</span><br><span class="line">1418.9054334516886</span><br><span class="line">1418.9054334516886</span><br></pre></td></tr></table></figure>
<p>可以看到通过牛顿法，基本在10次迭代以内就可以计算出十分精确的平方根。</p>
<p><strong>牛顿法原理：</strong></p>
<p>牛顿法可以用于求解方程的根，当一个方程的根不好直接求解时，就可以使用牛顿法来进行迭代求解。</p>
<p>对于一个方程，需要求解 $x$ 的值：</p>
<script type="math/tex; mode=display">
f(x) = 0</script><p>那么首先利用泰勒展开来对 $f(x)$ 进行展开，这里从 $x_0$ 进行展开，并且只展开到一阶：</p>
<script type="math/tex; mode=display">
f(x) \approx f(x_0) + (x - x_0)f'(x_0)</script><p>那么就可以使用这个近似式来求解原方程的近似解：</p>
<script type="math/tex; mode=display">
f(x_0) + (x - x_0)f'(x_0) = 0</script><script type="math/tex; mode=display">
f(x_0) + xf'(x_0) - x_0 f'(x_0) = 0</script><script type="math/tex; mode=display">
xf'(x_0) = x_0f'(x_0) - f(x_0)</script><script type="math/tex; mode=display">
x = x_0 - \frac{f(x_0)}{f'(x_0)}</script><p>注意到 $f’(x_0)$ 就是原函数 $f(x)$ 在 $x_0$ 这点的斜率，那么其实在这一点上的切线方程就可以写为：</p>
<script type="math/tex; mode=display">
y - f(x_0) = f'(x_0)(x - x_0)</script><p>那么对于 $x = x_0 - \frac{f(x_0)}{f’(x_0)}$ 这一点，将它代入切线方程，求出它在切线上所对应的 $y$ ：</p>
<script type="math/tex; mode=display">
y - f(x_0) = f'(x_0)(x_0 - \frac{f(x_0)}{f'(x_0)} - x_0)</script><script type="math/tex; mode=display">
y - f(x_0) = -f(x_0)</script><script type="math/tex; mode=display">
y = 0</script><p>也就是对应切线上的点 $(x_0 - \frac{f(x_0)}{f’(x_0)}, 0)$ ，画出图可以看出对应如下：</p>
<div align="center"><img src="/images/golang/practice-1_1.png" style="zoom:70%" title="牛顿法" /></div>

<p>从图中可以看到观察到，这里所需要求解的点为曲线与x轴所相交的那个点 $x$ （y为0，也就是 $f(x)=0$ ）。
虽然图中的 $x_{n+1}$ 并不是所需要求得点 $x$ ，但是它比 $x_n$ 更加接近 $x$ 。</p>
<p>所以这里就可以通过迭代来求解原方程的根，这一次从 $x_{n+1}$ 进行泰勒展开来求得下一个点。</p>
<p><strong>回到练习题：</strong></p>
<p>求解平方根，即方程 $x^2 = y$ 的解，即 $f(x) = x^2 - y$ ，代入上面的式子 $x = x_0 - \frac{f(x_0)}{f’(x_0)}$ ，
可以推出：</p>
<script type="math/tex; mode=display">
x_{n+1} = x_n - \frac{x_n^2 - y}{2x_n}</script><script type="math/tex; mode=display">
x_{n+1} = \frac{x_n^2 + y}{2x_n}</script><p>题目中用的上面的形式，使用下面的形式其实也可以求解，但是两种方法的结果有细微的差别。
估计是考虑到溢出的问题吧，减法在这里可以保证更好的精度。</p>
<hr>
<h1 id="最大公约数与最小公倍数（练习题：最小众倍数）"><a href="#最大公约数与最小公倍数（练习题：最小众倍数）" class="headerlink" title="最大公约数与最小公倍数（练习题：最小众倍数）"></a>最大公约数与最小公倍数（练习题：最小众倍数）</h1><p><a href="https://www.nowcoder.com/questionTerminal/792b17400b1b4915bb13c872e7ba48f7?toCommentId=3765769">牛客-最小众倍数</a></p>
<p>最小众倍数：即是三个数的最小公倍数。</p>
<p>题目给了 a，b，c，d，e 一共5个数，求它们的最小众倍数中最小的那一个。</p>
<p><strong>方法一</strong>：暴力搜索。复杂度等于<strong>搜索下限</strong>减去<strong>上限</strong>：</p>
<ul>
<li>搜索下限：第3大的数。</li>
<li>搜索上限：前3小的数的乘积。</li>
</ul>
<hr>
<p><strong>方法二</strong>：寻找所有三个数的组合的最小众倍数，取其中最小的那个。复杂度等于O(n^3)，n为输入数的个数，本题 n = 5。</p>
<p>如何求3个数a,b,c的最小众倍数？</p>
<p><strong>第一种求法：</strong></p>
<ul>
<li>求出<code>b*c</code>,<code>a*c</code>的最大公约数A;</li>
<li>求出<code>a*c</code>,<code>a*b</code>的最大公约数B;</li>
<li>求出A,B的最大公约数k;</li>
<li>使用<code>(a*b*c) / k</code>即得到结果。</li>
</ul>
<p>这个想法就是，对于 $C = abc$ ：</p>
<script type="math/tex; mode=display">
(bc)a=C \\
(ac)b=C \\
(ab)c=C</script><p>假设最小众倍数为 $D$ ，那么 $C$ 一定是 $D$ 的整数倍 $k$，即 $C = kD$ ：</p>
<script type="math/tex; mode=display">
(bc)a=kD \\
(ac)b=kD \\
(ab)c=kD</script><p>也就是：</p>
<script type="math/tex; mode=display">
\frac{(bc)}{k}a=D \\
\frac{(ac)}{k}b=D \\
\frac{(ab)}{k}c=D</script><p>那么 $k$ 就是能同时整除 $bc,ac,ab$ 的最大的数，也就是它们的最大众约数，
也就可以通过 $bc,ac$ 的最大公约数 $A$ ， $ac,ab$ 的最大公约数B，再求 $A,B$ 的最大公约数 $k$ 即可：</p>
<script type="math/tex; mode=display">
D = \frac{abc}{GCD(GCD(bc,ac), GCD(ac,ab))}</script><p>两个数的最大公约数求法在之前的博客中有写<a href="http://longrm.com/2017/11/20/2017-11-20-leetcode_149/#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">LeetCode 149 Max Points on a Line</a></p>
<p><strong>第二种求法：</strong></p>
<ul>
<li>求出a，b的最小公倍数A；</li>
<li>求出A，c的最小公倍数D；</li>
<li>D就是a，b，c的最小众倍数。</li>
</ul>
<p>首先，对于a，b的最小公倍数A：</p>
<script type="math/tex; mode=display">
x_1 a = A \\
x_2 b = A</script><p>然后对于A，c的最小公倍数D：</p>
<script type="math/tex; mode=display">
x_3 A = D \\
x_4 c = D</script><p>上面合在一起，即：</p>
<script type="math/tex; mode=display">
x_1 x_3 a = D \\
x_2 x_3 b = D \\
x_4 c = D</script><p>注意到由于最小公倍数的性质，$x_1$ 与 $x_2$ 互质，$x_3$ 与 $x_4$ 互质。</p>
<p>如果 $D$ 是a，b，c的最小众倍数，则 $x_1 x_3$ ，$x_2 x_3$，$x_4$ 的最大众约数为 1 。</p>
<p>这里使用<strong>反证</strong>，<strong>假设</strong> $x_1 x_3$ ，$x_2 x_3$，$x_4$ 的最大众约数不为 1 。</p>
<p>由于$x_3$ 与 $x_4$ 互质，那么只能 $x_1$ 、 $x_2$ 与 $x_4$ 存在不为 1 的最大公约数 $S$ ：</p>
<script type="math/tex; mode=display">
x_1 = k_1 S \\
x_2 = k_2 S \\
x_4 = k_3 S</script><p>也就是 $x_1$ 与 $x_2$ 存在最大公约数 $S$ ，与原条件 $x_1$ 与 $x_2$ 互质<strong>相矛盾</strong>。</p>
<p>所以 $x_1 x_3$ ，$x_2 x_3$，$x_4$ 的最大众约数为 1 ，即 $D$ 是a，b，c的最小众倍数。</p>
<script type="math/tex; mode=display">
D = LCM(LCM(a, b), c)</script><p>同理，使用公约数的解法可以改写为：</p>
<script type="math/tex; mode=display">
D = \frac{abc}{GCD(GCD(ab,bc), ac)}</script><p><strong>对于两个数的最小公倍数：</strong></p>
<p>对于a，b的最小公倍数A ：</p>
<script type="math/tex; mode=display">
k_1 a = A \\
k_2 b = A</script><p>注意 $k_1$ 与 $k_2$ 互质，假如a，b的最大公约数为 $S$ ：</p>
<script type="math/tex; mode=display">
k_1 (h_1 S) = A \\
k_2 (h_2 S) = A</script><p>注意到 $h_1$ 与 $h_2$ 互质，那么这里就可以推出：</p>
<script type="math/tex; mode=display">
k_1 (h_1 S) = k_2 (h_2 S) \\
k_1 h_1 = k_2 h_2 \\
k_1= \frac{h_2}{h_1} k_2</script><p>注意 $k_1$ 与 $k_2$ 互质，$h_1$ 与 $h_2$ 互质，所以 $\frac{h_2}{h_1}$ 必然等于 $\frac{k_1}{k_2}$ ，所以：</p>
<script type="math/tex; mode=display">
k_1 = h_2 \\
k_2 = h_1</script><p>所以：</p>
<script type="math/tex; mode=display">
k_1 a = h_2 (h_1 S) = A \\
\frac{(h_1 S) (h_2 S)}{S} = A \\
\frac{ab}{S} = A \\
\frac{ab}{GCD(a, b)} = A</script><p>即a，b的最小公倍数等于它们的乘积除以它们的最大公约数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LCM</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a*b) / GCD(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GCD</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> b != <span class="number">0</span> &#123;</span><br><span class="line">        c = a % b</span><br><span class="line">        a = b</span><br><span class="line">        b = c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码，求一个数组的最小众倍数：</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MinInt = <span class="keyword">int</span>(^<span class="keyword">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zbsUseGCD</span><span class="params">(seq *[]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    min := MinInt</span><br><span class="line">    n := <span class="built_in">len</span>(*seq)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i+<span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">for</span> k := j+<span class="number">1</span>; k &lt; n; k++ &#123;</span><br><span class="line">                zbsTmp := findZBSUseGCD((*seq)[i], (*seq)[j], (*seq)[k])</span><br><span class="line">                <span class="keyword">if</span> zbsTmp &lt; min &#123;</span><br><span class="line">                    min = zbsTmp</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zbsUseLCM</span><span class="params">(seq *[]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    min := MinInt</span><br><span class="line">    n := <span class="built_in">len</span>(*seq)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i+<span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">for</span> k := j+<span class="number">1</span>; k &lt; n; k++ &#123;</span><br><span class="line">                zbsTmp := findZBSUseLCM((*seq)[i], (*seq)[j], (*seq)[k])</span><br><span class="line">                <span class="keyword">if</span> zbsTmp &lt; min &#123;</span><br><span class="line">                    min = zbsTmp</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findZBSUseGCD</span><span class="params">(a, b, c <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a*b*c) / GCD(GCD(a*b, b*c), a*c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findZBSUseLCM</span><span class="params">(a, b, c <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> LCM(a, LCM(b, c))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LCM</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a*b) / GCD(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GCD</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> b != <span class="number">0</span> &#123;</span><br><span class="line">        c = a % b</span><br><span class="line">        a = b</span><br><span class="line">        b = c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="练习：Web-爬虫"><a href="#练习：Web-爬虫" class="headerlink" title="练习：Web 爬虫"></a>练习：Web 爬虫</h1><blockquote>
<p>修改 Crawl 函数来并行地抓取 URL，并且保证不重复。</p>
</blockquote>
<ul>
<li>使用map和互斥锁来保证URL的唯一抓取。</li>
<li>使用管道或者<code>sync.WaitGroup</code>来实现主线程等待子线程结束。</li>
</ul>
<p>代码一：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。</span></span><br><span class="line">    Fetch(url <span class="keyword">string</span>) (body <span class="keyword">string</span>, urls []<span class="keyword">string</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">    v <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 增加给定 key 的计数器的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">set</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line">    <span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line">    <span class="keyword">if</span> c.v[key] == <span class="number">0</span> &#123;</span><br><span class="line">        c.v[key]++</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crawl</span><span class="params">(url <span class="keyword">string</span>, sc *SafeCounter, fetcher Fetcher, ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !sc.set(url) &#123;</span><br><span class="line">        ch &lt;- <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    body, urls, err := fetcher.Fetch(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        ch &lt;- <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;found: %s %q\n&quot;</span>, url, body)</span><br><span class="line">    <span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        <span class="keyword">go</span> Crawl(u, sc, fetcher, ch)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> urls &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line">        Crawl(<span class="string">&quot;https://golang.org/&quot;</span>, &amp;SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;, fetcher, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>))</span><br><span class="line">        time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fakeFetcher 是返回若干结果的 Fetcher。</span></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="keyword">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">    body <span class="keyword">string</span></span><br><span class="line">    urls []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f fakeFetcher)</span> <span class="title">Fetch</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> res.body, res.urls, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;not found: %s&quot;</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetcher 是填充后的 fakeFetcher。</span></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line">    <span class="string">&quot;https://golang.org/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">        <span class="string">&quot;The Go Programming Language&quot;</span>,</span><br><span class="line">        []<span class="keyword">string</span>&#123;</span><br><span class="line">            <span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://golang.org/cmd/&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;https://golang.org/pkg/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">        <span class="string">&quot;Packages&quot;</span>,</span><br><span class="line">        []<span class="keyword">string</span>&#123;</span><br><span class="line">            <span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://golang.org/cmd/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://golang.org/pkg/fmt/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://golang.org/pkg/os/&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;https://golang.org/pkg/fmt/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">        <span class="string">&quot;Package fmt&quot;</span>,</span><br><span class="line">        []<span class="keyword">string</span>&#123;</span><br><span class="line">            <span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;https://golang.org/pkg/os/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">        <span class="string">&quot;Package os&quot;</span>,</span><br><span class="line">        []<span class="keyword">string</span>&#123;</span><br><span class="line">            <span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里实现了<code>SafeCounter</code>结构体来实现线程安全的<code>map</code>，并在<code>set</code>函数中使用了<code>defer</code>来将解锁放到<code>return</code>之后。</p>
<p><code>Crawl</code>函数使用了管道来让主线程等待子线程结束，<strong>但是</strong>可以看到这样写十分复杂，每个return之前都需要记得向管道写入。</p>
<p>可以使用下面方法简化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteToChan</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crawl</span><span class="params">(url <span class="keyword">string</span>, sc *SafeCounter, fetcher Fetcher, ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> WriteToChan(ch)</span><br><span class="line">    <span class="keyword">if</span> !sc.set(url) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    body, urls, err := fetcher.Fetch(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;found: %s %q\n&quot;</span>, url, body)</span><br><span class="line">    <span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        <span class="keyword">go</span> Crawl(u, sc, fetcher, ch)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> urls &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里编写函数<code>WriteToChan</code>，然后使用<code>defer</code>来实现函数结束时往管道写入。</p>
<p>当然也可以使用<code>sync.WaitGroup</code>：</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crawl</span><span class="params">(url <span class="keyword">string</span>, sc *SafeCounter, fetcher Fetcher, ch <span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">if</span> !sc.set(url) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    body, urls, err := fetcher.Fetch(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;found: %s %q\n&quot;</span>, url, body)</span><br><span class="line">    <span class="keyword">var</span> wgNext sync.WaitGroup</span><br><span class="line">    wgNext.Add(<span class="built_in">len</span>(urls))</span><br><span class="line">    <span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        <span class="keyword">go</span> Crawl(u, sc, fetcher, ch, &amp;wgNext)</span><br><span class="line">    &#125;</span><br><span class="line">    wgNext.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="素数求解"><a href="#素数求解" class="headerlink" title="素数求解"></a>素数求解</h1><p>素数或者质数：大于1，并且只能被1和自身整除的数，例如：2，3，5，7…</p>
<p>判断一个数 $n$ 是不是素数，可以按照定义：</p>
<ul>
<li>方法一：从2开始判断是否能够整除，直到 $\sqrt{n}$ 。</li>
<li>方法二：如果比 $n$ 小的数所构成的合数中没有 $n$，那么 $n$ 是素数。</li>
</ul>
<p>问题一：如何快速求解<code>[0,n]</code>范围内的素数。</p>
<p>如果n较大的时候，使用方法一复杂度也较大，这时使用方法二会更快：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX = <span class="number">500000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> primes [MAX]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> isNotPrime [MAX]<span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> idx <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findPrime</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    isNotPrime[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    isNotPrime[<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> !isNotPrime[i] &#123;</span><br><span class="line">            primes[idx] = i</span><br><span class="line">            idx++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于每个数 i ，将 i*2, i*3, i*4 ... 排除</span></span><br><span class="line">        <span class="keyword">for</span> j := i*<span class="number">2</span>; j &lt;= n; j+=i &#123;</span><br><span class="line">            isNotPrime[j] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    findPrime(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; idx; i++ &#123;</span><br><span class="line">        fmt.Println(primes[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这样的写法会有很多重复筛选，例如<code>2*3</code>，<code>3*2</code>都会被统计，但是其实没有必要。
另外，还有重复类似 <code>4*2, 4*3, 4*4 ...</code> 其实就是 <code>2*4, 2*6, 2*8 ...</code>，也就是说对于不是素数的数，
筛选它们的倍数是重复的。更进一步，这里只需要筛选素数的倍数就可以了。</p>
<p>按照上面所述，可以改写如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findPrime</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    isNotPrime[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    isNotPrime[<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> !isNotPrime[i] &#123;</span><br><span class="line">            primes[idx] = i</span><br><span class="line">            idx++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j, bound := <span class="number">0</span>, n/i + <span class="number">1</span>; j &lt; idx &amp;&amp; primes[j] &lt; bound; j++ &#123;</span><br><span class="line">            isNotPrime[primes[j]*i] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于这里只统计：</p>
<ul>
<li><code>2*2</code>，<code>2*3</code>，<code>2*4</code> …</li>
<li><code>3*3</code>，<code>3*4</code>，<code>3*5</code> …</li>
<li><code>5*5</code>，<code>5*6</code>，<code>5*7</code> …</li>
</ul>
<p>当然这里还是会出现重复，例如<code>2*9</code>和<code>3*6</code>，但是已经少了很多重复的筛选了。</p>
<p>更进一步，<strong>快速筛选法</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findPrime</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    isNotPrime[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    isNotPrime[<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> !isNotPrime[i] &#123;</span><br><span class="line">            primes[idx] = i</span><br><span class="line">            idx++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j, bound := <span class="number">0</span>, n/i + <span class="number">1</span>; j &lt; idx &amp;&amp; primes[j] &lt; bound; j++ &#123;</span><br><span class="line">            isNotPrime[primes[j]*i] = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> i%primes[j] == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在筛选过程中，可以不出现任何一个重复。</p>
<p><strong>那么为什么这样可以不出现任何一个重复，且筛选出所有合数呢？</strong></p>
<p>首先<code>每一个合数都可以以唯一形式被写成质数的乘积，即分解质因数</code>，那么只要是不同的质数组合，得到的肯定是不同的合数，</p>
<p>例如合数 $A_1 = a \times b \times c$ ，$A_2 = d \times e \times f$，假设 $a \leq b \leq c ; d \leq e \leq f$，
那么只有在 <code>a == d &amp;&amp; b == e &amp;&amp; c == f</code> 时， $A_1$ 等于 $A_2$。</p>
<p>那么在给定一个素数集合 <code>&#123;a, b, ..., n&#125;</code> ，就可以使用下面的方法来组合出所有这个集合所能表示的合数，且不发生重复：</p>
<div align="center"><img src="/images/golang/practice-1_2.png" style="zoom:55%" title="合数筛选" /></div>

<p>图中的集合为<code>&#123;2, 3, 5, 7&#125;</code>，左边是包含2的所有合数的组合方法，右边是其中 <code>2,3,3</code> 这条路线的样子。</p>
<p>可以看到，第一层生成 <code>&#123;2,2&#125;,&#123;2,3&#125;,&#123;2,5&#125;,&#123;2,7&#125;</code>，对于后面的三个集合 <code>&#123;2,3&#125;,&#123;2,5&#125;,&#123;2,7&#125;</code> 来说，它们向下的路线无法再经过 <code>2</code> ，
所有它们所生成的集合中，永远不可能包含子集 <code>&#123;2,2&#125;</code>，所以 <code>&#123;2,2&#125;</code> 与 <code>&#123;2,3&#125;,&#123;2,5&#125;,&#123;2,7&#125;</code> 向下所得到的集合永远不会相同，
同理可以知道 <code>&#123;2,2&#125;,&#123;2,3&#125;,&#123;2,5&#125;,&#123;2,7&#125;</code> 互相之间向下不可能生成相同集合，也就保证了不会<strong>重复</strong>。
至于覆盖所有合数，则是<strong>显然</strong>的，因为任何合数都可以表示为图中一条路线。</p>
<p>当然，另一种组合顺序也是一样的，也是快速筛选法中所用的：</p>
<div align="center"><img src="/images/golang/practice-1_3.png" style="zoom:55%" title="合数筛选" /></div>

<p>也就是刚才是限制向左，这里是限制向右，不过效果都是一样的。</p>
<p>为什么说算法中使用的就是这种组合方式呢？我们来跑100以内素数，打印一下输出就知道了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">i =  2</span><br><span class="line">primes = 2 </span><br><span class="line">i =  3</span><br><span class="line">primes = 2 3 </span><br><span class="line">i =  4   // 2 x 2</span><br><span class="line">primes = 2 </span><br><span class="line">i =  5</span><br><span class="line">primes = 2 3 5 </span><br><span class="line">i =  6   // 3 x 2</span><br><span class="line">primes = 2 </span><br><span class="line">i =  7</span><br><span class="line">primes = 2 3 5 7 </span><br><span class="line">i =  8   // 2 x 2 x 2</span><br><span class="line">primes = 2 </span><br><span class="line">i =  9   // 3 x 3</span><br><span class="line">primes = 2 3 </span><br><span class="line">i =  10  // 5 x 2</span><br><span class="line">primes = 2 </span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，输出完全符合预期（因为本来就是按这个组合方法写的…）：</p>
<ul>
<li>当<code>i = 2</code>，那么由于限制往右，那么向下只能再组合出 <code>&#123;2,2&#125;</code>；</li>
<li>当<code>i = 3</code>，那么向下只能再组合出 <code>&#123;2,2&#125;，&#123;3,2&#125;</code>；</li>
<li>当<code>i = 6</code>，其实就是组合 <code>&#123;3,2&#125;</code>，相当于图中的 3 走到 2，那么再向下也只有 2 能选择了，所以只能组合出 <code>&#123;3,2,2&#125;</code>；</li>
<li>…</li>
</ul>
<p>所以这里的 <code>i%primes[j] == 0</code> 其实就是在判断 <code>primes[j]</code> 是不是 <code>i</code> 的最小因数，一旦判断为 <code>true</code>，就相当于到达了右边界，
所以进行 <code>break</code>。</p>
<p>所以这样的方法<strong>一定不会出现任何重复的筛选</strong>。</p>
<p>至于包含所有合数，那也是明显的，对于合数 $A = a \times b \times … \times m \times n$ ，假设 $ a \geq b \geq … \geq m \geq n$，
那么一定会先遍历到 $i = a \times b \times … \times m$ ，又因为 $i$ 向下组合的右边界为 $m$ ，且 $m \geq n$ ，所以，一定会由 $i$ 筛选出 $A$，
所以这里<strong>一定不会漏掉任何一个合数</strong>。</p>
<p>证明完毕。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>srs的推拉流压测</title>
    <url>/2019/10/29/2019-10-29-srs_bench-v1/</url>
    <content><![CDATA[<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>测试单个srs节点的同时推流或拉流的能力。</p>
<p><strong>主机1：</strong></p>
<p>云主机-上海</p>
<p>CPU：Intel(R) Xeon(R) Gold 6161 CPU @ 2.20GHz</p>
<p>MEM：64G</p>
<p><strong>主机2：</strong></p>
<p>云主机-北京</p>
<p>CPU：Intel(R) Xeon(R) Gold 6161 CPU @ 2.20GHz</p>
<p>MEM：64G</p>
<p>测试方法：使用srs自带的<a href="https://github.com/ossrs/srs-bench">srs-bench</a>进行测试。</p>
<hr>
<h1 id="带宽测试"><a href="#带宽测试" class="headerlink" title="带宽测试"></a>带宽测试</h1><p>使用iperf3进行测试：</p>
<p>上海：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ iperf3 -s -p 12345 -i 1</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Server listening on 12345</span><br></pre></td></tr></table></figure>
<p>北京：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ iperf3 -c xxx.xxx.xxx.219 -p12345 -i 1 -t 30 </span><br><span class="line"></span><br><span class="line">[ ID] Interval           Transfer     Bandwidth       Retr  Cwnd</span><br><span class="line">[  4]   0.00-1.00   sec  16.0 MBytes   135 Mbits&#x2F;sec  4174    652 KBytes       </span><br><span class="line">[  4]   1.00-2.00   sec  21.2 MBytes   178 Mbits&#x2F;sec  3352   1011 KBytes       </span><br><span class="line">[  4]   2.00-3.00   sec  26.2 MBytes   220 Mbits&#x2F;sec  1293   5.66 KBytes       </span><br><span class="line">[  4]   3.00-4.00   sec  45.0 MBytes   378 Mbits&#x2F;sec  1368   2.62 MBytes       </span><br><span class="line">[  4]   4.00-5.00   sec  25.0 MBytes   210 Mbits&#x2F;sec  2496   1.96 MBytes       </span><br><span class="line">[  4]   5.00-6.00   sec  42.5 MBytes   357 Mbits&#x2F;sec  1203   2.60 MBytes       </span><br><span class="line">[  4]   6.00-7.00   sec  33.8 MBytes   283 Mbits&#x2F;sec  2117    990 KBytes       </span><br><span class="line">[  4]   7.00-8.00   sec  33.8 MBytes   283 Mbits&#x2F;sec    0   1.02 MBytes       </span><br><span class="line">[  4]   8.00-9.00   sec  35.0 MBytes   294 Mbits&#x2F;sec   13    824 KBytes       </span><br><span class="line">[  4]   9.00-10.00  sec  27.5 MBytes   231 Mbits&#x2F;sec   63    860 KBytes       </span><br><span class="line">[  4]  10.00-11.00  sec  31.2 MBytes   262 Mbits&#x2F;sec    0    940 KBytes       </span><br><span class="line">[  4]  11.00-12.00  sec  31.2 MBytes   262 Mbits&#x2F;sec    0    998 KBytes       </span><br><span class="line">[  4]  12.00-13.00  sec  35.0 MBytes   294 Mbits&#x2F;sec    0   1.01 MBytes       </span><br><span class="line">[  4]  13.00-14.00  sec  35.0 MBytes   294 Mbits&#x2F;sec    0   1.04 MBytes       </span><br><span class="line">[  4]  14.00-15.00  sec  35.0 MBytes   294 Mbits&#x2F;sec    0   1.05 MBytes       </span><br><span class="line">[  4]  15.00-16.00  sec  36.2 MBytes   304 Mbits&#x2F;sec    1   1.07 MBytes       </span><br><span class="line">[  4]  16.00-17.00  sec  37.5 MBytes   315 Mbits&#x2F;sec    0   1.10 MBytes       </span><br><span class="line">[  4]  17.00-18.00  sec  38.8 MBytes   325 Mbits&#x2F;sec    0   1.13 MBytes       </span><br><span class="line">[  4]  18.00-19.00  sec  30.0 MBytes   252 Mbits&#x2F;sec   96    894 KBytes       </span><br><span class="line">[  4]  19.00-20.00  sec  30.0 MBytes   252 Mbits&#x2F;sec    1    932 KBytes       </span><br><span class="line">[  4]  20.00-21.00  sec  31.2 MBytes   262 Mbits&#x2F;sec    0    956 KBytes       </span><br><span class="line">[  4]  21.00-22.00  sec  32.5 MBytes   273 Mbits&#x2F;sec    0    983 KBytes       </span><br><span class="line">[  4]  22.00-23.00  sec  32.5 MBytes   273 Mbits&#x2F;sec    0   1008 KBytes       </span><br><span class="line">[  4]  23.00-24.00  sec  35.0 MBytes   294 Mbits&#x2F;sec    0   1.01 MBytes       </span><br><span class="line">[  4]  24.00-25.00  sec  35.0 MBytes   294 Mbits&#x2F;sec    0   1.03 MBytes       </span><br><span class="line">[  4]  25.00-26.00  sec  36.2 MBytes   304 Mbits&#x2F;sec    0   1.06 MBytes       </span><br><span class="line">[  4]  26.00-27.00  sec  37.5 MBytes   315 Mbits&#x2F;sec    0   1.15 MBytes       </span><br><span class="line">[  4]  27.00-28.00  sec  41.2 MBytes   346 Mbits&#x2F;sec    0   1.27 MBytes       </span><br><span class="line">[  4]  28.00-29.00  sec  32.5 MBytes   273 Mbits&#x2F;sec  226   1018 KBytes       </span><br><span class="line">[  4]  29.00-30.00  sec  36.2 MBytes   304 Mbits&#x2F;sec    0   1.09 MBytes       </span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth       Retr</span><br><span class="line">[  4]   0.00-30.00  sec   996 MBytes   279 Mbits&#x2F;sec  16403             sender</span><br><span class="line">[  4]   0.00-30.00  sec   993 MBytes   278 Mbits&#x2F;sec                  receiver</span><br><span class="line"></span><br><span class="line">iperf Done.</span><br></pre></td></tr></table></figure></h2><p>北京：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ iperf3 -s -p 12345 -i 1</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Server listening on 12345</span><br></pre></td></tr></table></figure>
<p>上海：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ iperf3 -c xxx.xxx.xxx.103 -p12345 -i 1 -t 30</span><br><span class="line"></span><br><span class="line">[ ID] Interval           Transfer     Bandwidth       Retr  Cwnd</span><br><span class="line">[  4]   0.00-1.00   sec  1.48 MBytes  12.4 Mbits&#x2F;sec    1   56.6 KBytes       </span><br><span class="line">[  4]   1.00-2.00   sec  2.49 MBytes  20.9 Mbits&#x2F;sec    1   80.6 KBytes       </span><br><span class="line">[  4]   2.00-3.00   sec  3.48 MBytes  29.2 Mbits&#x2F;sec    1    106 KBytes       </span><br><span class="line">[  4]   3.00-4.00   sec  4.29 MBytes  36.0 Mbits&#x2F;sec    1    130 KBytes       </span><br><span class="line">[  4]   4.00-5.00   sec  4.91 MBytes  41.2 Mbits&#x2F;sec    0    157 KBytes       </span><br><span class="line">[  4]   5.00-6.00   sec  6.46 MBytes  54.2 Mbits&#x2F;sec    0    184 KBytes       </span><br><span class="line">[  4]   6.00-7.00   sec  6.84 MBytes  57.3 Mbits&#x2F;sec    0    212 KBytes       </span><br><span class="line">[  4]   7.00-8.00   sec  8.20 MBytes  68.8 Mbits&#x2F;sec    0    238 KBytes       </span><br><span class="line">[  4]   8.00-9.00   sec  8.76 MBytes  73.5 Mbits&#x2F;sec    0    266 KBytes       </span><br><span class="line">[  4]   9.00-10.00  sec  9.82 MBytes  82.4 Mbits&#x2F;sec    0    293 KBytes       </span><br><span class="line">[  4]  10.00-11.00  sec  11.7 MBytes  98.0 Mbits&#x2F;sec    0    356 KBytes       </span><br><span class="line">[  4]  11.00-12.00  sec  14.4 MBytes   120 Mbits&#x2F;sec    0    467 KBytes       </span><br><span class="line">[  4]  12.00-13.00  sec  19.8 MBytes   166 Mbits&#x2F;sec    0    602 KBytes       </span><br><span class="line">[  4]  13.00-14.00  sec  23.8 MBytes   199 Mbits&#x2F;sec    0    772 KBytes       </span><br><span class="line">[  4]  14.00-15.00  sec  30.0 MBytes   252 Mbits&#x2F;sec    0    977 KBytes       </span><br><span class="line">[  4]  15.00-16.00  sec  37.5 MBytes   315 Mbits&#x2F;sec    1   1.06 MBytes       </span><br><span class="line">[  4]  16.00-17.00  sec  38.8 MBytes   325 Mbits&#x2F;sec    0   1.09 MBytes       </span><br><span class="line">[  4]  17.00-18.00  sec  40.0 MBytes   336 Mbits&#x2F;sec    0   1.11 MBytes       </span><br><span class="line">[  4]  18.00-19.00  sec  36.2 MBytes   304 Mbits&#x2F;sec  152    846 KBytes       </span><br><span class="line">[  4]  19.00-20.00  sec  31.2 MBytes   262 Mbits&#x2F;sec    4    911 KBytes       </span><br><span class="line">[  4]  20.00-21.00  sec  31.2 MBytes   262 Mbits&#x2F;sec    0    938 KBytes       </span><br><span class="line">[  4]  21.00-22.00  sec  33.8 MBytes   283 Mbits&#x2F;sec    0    964 KBytes       </span><br><span class="line">[  4]  22.00-23.00  sec  33.8 MBytes   283 Mbits&#x2F;sec    0    991 KBytes       </span><br><span class="line">[  4]  23.00-24.00  sec  35.0 MBytes   294 Mbits&#x2F;sec    0   1018 KBytes       </span><br><span class="line">[  4]  24.00-25.00  sec  37.5 MBytes   315 Mbits&#x2F;sec    0   1.02 MBytes       </span><br><span class="line">[  4]  25.00-26.00  sec  36.2 MBytes   304 Mbits&#x2F;sec    0   1.05 MBytes       </span><br><span class="line">[  4]  26.00-27.00  sec  32.5 MBytes   273 Mbits&#x2F;sec   82    813 KBytes       </span><br><span class="line">[  4]  27.00-28.00  sec  30.0 MBytes   252 Mbits&#x2F;sec    0    905 KBytes       </span><br><span class="line">[  4]  28.00-29.00  sec  33.8 MBytes   283 Mbits&#x2F;sec    0    973 KBytes       </span><br><span class="line">[  4]  29.00-30.00  sec  33.8 MBytes   283 Mbits&#x2F;sec    0   1022 KBytes       </span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth       Retr</span><br><span class="line">[  4]   0.00-30.00  sec   678 MBytes   189 Mbits&#x2F;sec  243             sender</span><br><span class="line">[  4]   0.00-30.00  sec   676 MBytes   189 Mbits&#x2F;sec                  receiver</span><br><span class="line"></span><br><span class="line">iperf Done.</span><br></pre></td></tr></table></figure>
<p><strong>可以看到TCP稳定时，大概是300M的带宽。</strong></p>
<hr>
<h1 id="rtmp推流测试"><a href="#rtmp推流测试" class="headerlink" title="rtmp推流测试"></a>rtmp推流测试</h1><p>在北京起一个srs服务器，从上海使用srs-bench推流过去。</p>
<p>这里srs服务器和srs-bench都是单核运行的，为了保证srs-bench不会先达到cpu上限，使用两个srs-bench进程来推流。</p>
<p><strong>先推750路流</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;objs&#x2F;sb_rtmp_publish -i doc&#x2F;source.200kbps.768x320.flv -c 750 -s 10 -r rtmp:&#x2F;&#x2F;xxx.xxx.xxx.103:2019&#x2F;live&#x2F;livestream_&#123;i&#125;?vhost&#x3D;long.test.com</span><br><span class="line"></span><br><span class="line">[2019-10-27 15:58:55.938] [report] [16398] threads:750 alive:750 duration:30 tduration:0 nread:0.79 nwrite:137.69 tasks:750 etasks:0 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 15:59:25.938] [report] [16398] threads:750 alive:750 duration:60 tduration:0 nread:0.39 nwrite:163.65 tasks:750 etasks:0 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 15:59:55.938] [report] [16398] threads:750 alive:750 duration:90 tduration:0 nread:0.26 nwrite:164.61 tasks:750 etasks:0 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 16:00:25.938] [report] [16398] threads:750 alive:750 duration:120 tduration:0 nread:0.20 nwrite:172.49 tasks:750 etasks:0 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 16:00:55.938] [report] [16398] threads:750 alive:750 duration:150 tduration:0 nread:0.16 nwrite:174.96 tasks:750 etasks:0 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 16:01:25.938] [report] [16398] threads:750 alive:750 duration:180 tduration:0 nread:0.13 nwrite:179.18 tasks:750 etasks:0 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 16:01:55.938] [report] [16398] threads:750 alive:750 duration:210 tduration:0 nread:0.11 nwrite:184.73 tasks:750 etasks:0 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 16:02:25.938] [report] [16398] threads:750 alive:750 duration:240 tduration:0 nread:0.10 nwrite:182.79 tasks:750 etasks:0 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 16:02:55.939] [report] [16398] threads:750 alive:750 duration:270 tduration:0 nread:0.09 nwrite:183.50 tasks:750 etasks:0 stasks:0 estasks:0</span><br></pre></td></tr></table></figure>
<p><strong>观察服务器cpu占用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ top</span><br><span class="line"></span><br><span class="line">top - 15:57:51 up 243 days,  1:29,  4 users,  load average: 0.35, 0.16, 0.10</span><br><span class="line">Tasks: 212 total,   2 running, 210 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  2.2 us,  0.5 sy,  0.0 ni, 96.7 id,  0.0 wa,  0.0 hi,  0.6 si,  0.0 st</span><br><span class="line">KiB Mem : 65807864 total,  2352216 free,  1588392 used, 61867256 buff&#x2F;cache</span><br><span class="line">KiB Swap:  4194300 total,  4192468 free,     1832 used. 61573296 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND        </span><br><span class="line"> 9548 root      20   0  639468 318264   1924 R  50.5  0.5  22:03.87 srs            </span><br><span class="line"> 9554 root      20   0  437456 221308   1928 S  15.6  0.3  11:34.34 srs            </span><br><span class="line">   10 root      20   0       0      0      0 S   0.3  0.0 236:57.63 rcu_sched      </span><br><span class="line">    1 root      20   0  199248   3912   2436 S   0.0  0.0  68:38.96 systemd        </span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.01 kthreadd       </span><br><span class="line">    3 root      20   0       0      0      0 S   0.0  0.0   1:33.02 ksoftirqd&#x2F;0    </span><br><span class="line">    5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker&#x2F;0:0H   </span><br><span class="line">    6 root      20   0       0      0      0 S   0.0  0.0   0:03.29 kworker&#x2F;u32:0  </span><br></pre></td></tr></table></figure>
<p><strong>观察服务器IO占用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dstat</span><br><span class="line"></span><br><span class="line">----total-cpu-usage---- -dsk&#x2F;total- -net&#x2F;total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw </span><br><span class="line">  2   0  97   0   0   1|   0     0 |  24M  730k|   0     0 |  12k 7223 </span><br><span class="line">  2   0  97   0   0   1|   0     0 |  23M  715k|   0     0 |  11k 7190 </span><br><span class="line">  2   1  97   0   0   1|   0   112k|  20M  675k|   0     0 |  11k 7399 </span><br><span class="line">  2   0  97   0   0   1|   0     0 |  21M  684k|   0     0 |  11k 6847 </span><br><span class="line">  2   0  97   0   0   1|   0     0 |  23M  695k|   0     0 |  11k 7115 </span><br><span class="line">  2   0  97   0   0   1|   0     0 |  23M  710k|   0     0 |  11k 7168 </span><br><span class="line">  2   0  97   0   0   1|   0     0 |  24M  714k|   0     0 |  11k 7377 </span><br><span class="line">  2   1  97   0   0   1|   0     0 |  27M  743k|   0     0 |  12k 6799 </span><br><span class="line">  2   0  97   0   0   1|   0    24k|  30M  783k|   0     0 |  13k 7247 </span><br><span class="line">  2   0  97   0   0   1|   0     0 |  33M  813k|   0     0 |  13k 7354 </span><br><span class="line">  2   1  97   0   0   1|   0     0 |  36M  833k|   0     0 |  14k 8435 </span><br><span class="line">  2   0  97   0   0   1|   0     0 |  37M  861k|   0     0 |  14k 7925 </span><br></pre></td></tr></table></figure>
<p><strong>再推250路流，增加到1000路流：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;objs&#x2F;sb_rtmp_publish -i doc&#x2F;source.200kbps.768x320.flv -c 250 -s 10 -r rtmp:&#x2F;&#x2F;xxx.xxx.xxx.103:2019&#x2F;live&#x2F;livestream1_&#123;i&#125;?vhost&#x3D;long.test.com</span><br><span class="line"></span><br><span class="line">[2019-10-27 16:28:10.008] [report] [16481] threads:250 alive:250 duration:1110 tduration:0 nread:0.01 nwrite:62.53 tasks:262 etasks:12 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 16:28:40.008] [report] [16481] threads:250 alive:250 duration:1140 tduration:0 nread:0.01 nwrite:62.37 tasks:262 etasks:12 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 16:29:10.008] [report] [16481] threads:250 alive:250 duration:1170 tduration:0 nread:0.01 nwrite:62.39 tasks:262 etasks:12 stasks:0 estasks:0</span><br></pre></td></tr></table></figure>
<p><strong>观察服务器cpu占用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top - 16:26:27 up 243 days,  1:57,  4 users,  load average: 0.84, 0.73, 0.61</span><br><span class="line">Tasks: 212 total,   1 running, 211 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  3.0 us,  0.5 sy,  0.0 ni, 95.7 id,  0.0 wa,  0.0 hi,  0.8 si,  0.0 st</span><br><span class="line">KiB Mem : 65807864 total,  2342924 free,  1593668 used, 61871272 buff&#x2F;cache</span><br><span class="line">KiB Swap:  4194300 total,  4192468 free,     1832 used. 61567380 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND        </span><br><span class="line"> 9548 root      20   0  639468 318264   1924 S  69.4  0.5  39:42.44 srs            </span><br><span class="line">15063 root      20   0  155140   5848   4500 S   1.0  0.0   0:00.03 sshd           </span><br><span class="line">15065 root      20   0  116496   3088   1648 S   0.7  0.0   0:00.02 bash           </span><br><span class="line">   10 root      20   0       0      0      0 S   0.3  0.0 237:00.91 rcu_sched      </span><br><span class="line">   80 root      20   0       0      0      0 S   0.3  0.0 560:22.55 ksoftirqd&#x2F;14   </span><br></pre></td></tr></table></figure>
<p><strong>观察服务器IO占用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----total-cpu-usage---- -dsk&#x2F;total- -net&#x2F;total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw </span><br><span class="line">  3   0  96   0   0   1|   0     0 |  32M  990k|   0     0 |  14k 5548 </span><br><span class="line">  3   0  96   0   0   1|   0    20k|  31M  994k|   0     0 |  14k 5763 </span><br><span class="line">  3   0  96   0   0   1|   0     0 |  32M  986k|   0     0 |  14k 5636 </span><br><span class="line">  3   0  96   0   0   1|   0     0 |  32M  979k|   0     0 |  14k 5777 </span><br><span class="line">  3   0  96   0   0   1|   0  8192B|  31M  981k|   0     0 |  14k 5762 </span><br><span class="line">  4   0  95   0   0   1|   0     0 |  32M  989k|   0     0 |  14k 5615 </span><br><span class="line">  4   1  95   0   0   1|   0  3008k|  33M 1011k|   0     0 |  15k 5571 </span><br><span class="line">  3   1  96   0   0   1|   0     0 |  35M 1051k|   0     0 |  15k 5471 </span><br><span class="line">  3   0  96   0   0   1|   0     0 |  37M 1066k|   0     0 |  15k 5289 </span><br><span class="line">  3   1  95   0   0   1|  44k 4096B|  38M 1079k|   0     0 |  15k 5712 </span><br><span class="line">  3   0  96   0   0   1|   0     0 |  39M 1086k|   0     0 |  15k 5389 </span><br></pre></td></tr></table></figure>
<p><strong>增加到1200路流：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;objs&#x2F;sb_rtmp_publish -i doc&#x2F;source.200kbps.768x320.flv -c 200 -s 10 -r rtmp:&#x2F;&#x2F;xxx.xxx.xxx.103:2019&#x2F;live&#x2F;livestream2_&#123;i&#125;?vhost&#x3D;long.test.com</span><br><span class="line"></span><br><span class="line">[2019-10-27 16:33:21.150] [report] [16689] threads:200 alive:199 duration:60 tduration:0 nread:0.11 nwrite:39.88 tasks:208 etasks:9 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 16:33:51.150] [report] [16689] threads:200 alive:200 duration:90 tduration:0 nread:0.08 nwrite:41.05 tasks:219 etasks:19 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 16:34:21.150] [report] [16689] threads:200 alive:200 duration:120 tduration:0 nread:0.06 nwrite:42.49 tasks:219 etasks:19 stasks:0 estasks:0</span><br></pre></td></tr></table></figure>
<p><strong>观察服务器cpu占用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top - 16:32:01 up 243 days,  2:03,  4 users,  load average: 0.98, 0.85, 0.68</span><br><span class="line">Tasks: 213 total,   2 running, 211 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  3.5 us,  0.5 sy,  0.0 ni, 95.1 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st</span><br><span class="line">KiB Mem : 65807864 total,  2326480 free,  1607988 used, 61873396 buff&#x2F;cache</span><br><span class="line">KiB Swap:  4194300 total,  4192468 free,     1832 used. 61551888 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND        </span><br><span class="line"> 9548 root      20   0  675468 321256   1924 R  88.4  0.5  44:02.00 srs            </span><br><span class="line">   10 root      20   0       0      0      0 S   0.3  0.0 237:01.58 rcu_sched      </span><br><span class="line"> 1060 root      20   0   20.1g 421956  13468 S   0.3  0.6 308:47.03 java           </span><br><span class="line"> 5359 root      20   0  112800   4328   3300 S   0.3  0.0   9:57.35 sshd           </span><br><span class="line"> 6052 root      20   0   13220    796    592 S   0.3  0.0 238:27.05 rngd            </span><br></pre></td></tr></table></figure>
<p><strong>观察服务器IO占用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----total-cpu-usage---- -dsk&#x2F;total- -net&#x2F;total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw </span><br><span class="line">  3   1  95   0   0   1|   0     0 |  35M 1218k|   0     0 |  16k 3206 </span><br><span class="line">  3   0  95   0   0   1|   0     0 |  35M 1235k|   0     0 |  17k 3217 </span><br><span class="line">  3   1  95   0   0   1|   0     0 |  35M 1224k|   0     0 |  17k 3194 </span><br><span class="line">  4   0  95   0   0   1|   0     0 |  35M 1216k|   0     0 |  17k 3381 </span><br><span class="line">  4   1  95   0   0   1|   0    52k|  35M 1223k|   0     0 |  17k 3177 </span><br><span class="line">  4   1  95   0   0   1|   0     0 |  35M 1247k|   0     0 |  17k 3289 </span><br><span class="line">  4   0  95   0   0   1|   0     0 |  35M 1218k|   0     0 |  17k 3346 </span><br><span class="line">  3   0  95   0   0   1|   0     0 |  35M 1229k|   0     0 |  17k 3093 </span><br><span class="line">  4   1  95   0   0   1|   0     0 |  35M 1207k|   0     0 |  17k 3226 </span><br><span class="line">  3   0  95   0   0   1|   0    60k|  35M 1238k|   0     0 |  17k 3097 </span><br><span class="line">  4   0  95   0   0   1|   0  8192B|  35M 1209k|   0     0 |  17k 3612 </span><br><span class="line">  3   1  95   0   0   1|   0     0 |  35M 1219k|   0     0 |  16k 3216 </span><br></pre></td></tr></table></figure>
<p><strong>结论：在推送200kbps的流的情况下，大概在1000路推流时，带宽首先被占满，CPU在70%左右。</strong></p>
<hr>
<h1 id="rtmp拉流测试"><a href="#rtmp拉流测试" class="headerlink" title="rtmp拉流测试"></a>rtmp拉流测试</h1><p><strong>先推一路流上去：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;objs&#x2F;sb_rtmp_publish -i doc&#x2F;source.200kbps.768x320.flv -c 1 -s 10 -r rtmp:&#x2F;&#x2F;xxx.xxx.xxx.103:2019&#x2F;live&#x2F;livestream?vhost&#x3D;long.test.com</span><br></pre></td></tr></table></figure>
<p><strong>直接拉1000路流：</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;objs&#x2F;sb_rtmp_load -c 1000 -s 10 -r rtmp:&#x2F;&#x2F;xxx.xxx.xxx.103:2019&#x2F;live&#x2F;livestream?vhost&#x3D;long.test.com</span><br><span class="line"></span><br><span class="line">[2019-10-27 16:42:00.428] [report] [16756] threads:1000 alive:1000 duration:30 tduration:0 nread:172.40 nwrite:0.93 tasks:1000 etasks:0 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 16:42:30.428] [report] [16756] threads:1000 alive:1000 duration:60 tduration:0 nread:212.69 nwrite:0.46 tasks:1000 etasks:0 stasks:0 estasks:0</span><br></pre></td></tr></table></figure>
<p><strong>观察服务器cpu占用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top - 16:40:27 up 243 days,  2:11,  4 users,  load average: 0.14, 0.42, 0.56</span><br><span class="line">Tasks: 213 total,   2 running, 211 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.5 us,  0.3 sy,  0.0 ni, 98.5 id,  0.0 wa,  0.0 hi,  0.7 si,  0.0 st</span><br><span class="line">KiB Mem : 65807864 total,  2276144 free,  1648396 used, 61883324 buff&#x2F;cache</span><br><span class="line">KiB Swap:  4194300 total,  4192468 free,     1832 used. 61505084 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND        </span><br><span class="line"> 9548 root      20   0  675468 321276   1944 R  13.6  0.5  47:13.14 srs            </span><br><span class="line"> 6572 root      20   0 1949000  44236  14768 S   1.7  0.1 955:10.49 containerd     </span><br><span class="line"> 4921 root      20   0   24576   8708   2380 S   0.3  0.0  85:26.68 srs            </span><br><span class="line"> 6052 root      20   0   13220    796    592 S   0.3  0.0 238:28.16 rngd           </span><br><span class="line">    1 root      20   0  199248   3912   2436 S   0.0  0.0  68:39.47 systemd        </span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.01 kthreadd       </span><br></pre></td></tr></table></figure>
<p><strong>观察服务器IO占用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----total-cpu-usage---- -dsk&#x2F;total- -net&#x2F;total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw </span><br><span class="line">  0   0  99   0   0   1|   0     0 |1309k   46M|   0     0 |  14k  880 </span><br><span class="line">  1   0  98   0   0   1|   0     0 |1312k   45M|   0     0 |  14k  913 </span><br><span class="line">  0   0  99   0   0   1|   0     0 |1167k   44M|   0     0 |  13k  897 </span><br><span class="line">  1   0  99   0   0   1|   0     0 |1236k   45M|   0     0 |  12k  810 </span><br><span class="line">  1   0  99   0   0   1|   0   148k|1309k   47M|   0     0 |  13k  911 </span><br><span class="line">  0   0  99   0   0   1|   0     0 |1296k   45M|   0     0 |  13k  817 </span><br><span class="line">  0   0  99   0   0   1|   0     0 |1269k   42M|   0     0 |  13k  843 </span><br><span class="line">  0   0  99   0   0   1|   0     0 |1195k   44M|   0     0 |  12k  894 </span><br><span class="line">  0   0  99   0   0   1|   0     0 |1192k   42M|   0     0 |  12k  812 </span><br><span class="line">  1   0  99   0   0   1|   0    20k|1271k   49M|   0     0 |  12k  795 </span><br><span class="line">  0   0  99   0   0   1|   0     0 |1243k   41M|   0     0 |  13k  949 </span><br><span class="line">  1   0  98   0   0   1|   0     0 |1320k   48M|   0     0 |  13k  909 </span><br><span class="line">  0   0  99   0   0   1|   0     0 |1254k   45M|   0     0 |  13k  858 </span><br></pre></td></tr></table></figure>
<p><strong>结论：在拉取200kbps的流的情况下，大概在1000路拉流时，带宽45MB左右，CPU在13%左右，上限决定于带宽</strong></p>
<hr>
<h1 id="flv拉流测试"><a href="#flv拉流测试" class="headerlink" title="flv拉流测试"></a>flv拉流测试</h1><p><strong>先推一路流上去：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;objs&#x2F;sb_rtmp_publish -i doc&#x2F;source.200kbps.768x320.flv -c 1 -s 10 -r rtmp:&#x2F;&#x2F;xxx.xxx.xxx.103:2019&#x2F;live&#x2F;livestream?vhost&#x3D;long.test.com</span><br></pre></td></tr></table></figure>
<p><strong>直接拉1000路流：</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;objs&#x2F;sb_http_load -c 1000 -s 10 -r http:&#x2F;&#x2F;long.test.com:3019&#x2F;live&#x2F;livestream.flv</span><br><span class="line"></span><br><span class="line">[2019-10-27 18:05:31.713] [report] [17375] threads:1000 alive:1000 duration:240 tduration:0 nread:238.23 nwrite:0.00 tasks:1000 etasks:0 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 18:06:01.713] [report] [17375] threads:1000 alive:1000 duration:270 tduration:0 nread:242.30 nwrite:0.00 tasks:1000 etasks:0 stasks:0 estasks:0</span><br><span class="line">[2019-10-27 18:06:31.713] [report] [17375] threads:1000 alive:1000 duration:300 tduration:0 nread:244.52 nwrite:0.00 tasks:1000 etasks:0 stasks:0 estasks:0</span><br></pre></td></tr></table></figure>
<p><strong>观察服务器cpu占用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top - 18:04:10 up 243 days,  3:35,  4 users,  load average: 0.10, 0.17, 0.13</span><br><span class="line">Tasks: 211 total,   2 running, 209 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  1.2 us,  0.9 sy,  0.0 ni, 97.1 id,  0.0 wa,  0.0 hi,  0.8 si,  0.0 st</span><br><span class="line">KiB Mem : 65807864 total,  2559192 free,  1223956 used, 62024716 buff&#x2F;cache</span><br><span class="line">KiB Swap:  4194300 total,  4192468 free,     1832 used. 61930044 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND        </span><br><span class="line">18700 root      20   0  340136 107528   2000 R  41.5  0.2   3:15.25 srs            </span><br><span class="line"> 6572 root      20   0 1949000  43996  14768 S   1.7  0.1 955:25.07 containerd     </span><br><span class="line">  966 root      20   0  122040   1492    888 S   0.3  0.0 174:11.47 wrapper        </span><br><span class="line"> 9695 root      20   0  161976   2372   1600 R   0.3  0.0   0:29.07 top            </span><br><span class="line">    1 root      20   0  199248   3912   2436 S   0.0  0.0  68:40.50 systemd        </span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.01 kthreadd       </span><br><span class="line">    3 root      20   0       0      0      0 S   0.0  0.0   1:33.02 ksoftirqd&#x2F;0    </span><br></pre></td></tr></table></figure>
<p><strong>观察服务器IO占用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----total-cpu-usage---- -dsk&#x2F;total- -net&#x2F;total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw </span><br><span class="line">  1   1  97   0   0   1|   0     0 |1138k   42M|   0     0 |  13k 1447 </span><br><span class="line">  1   1  97   0   0   1|   0     0 |1121k   42M|   0     0 |  13k 1417 </span><br><span class="line">  1   1  97   0   0   1|   0     0 |1108k   41M|   0     0 |  13k 1436 </span><br><span class="line">  1   1  97   0   0   1|   0    28k|1110k   44M|   0     0 |  13k 1381 </span><br><span class="line">  1   1  97   0   0   1|   0     0 |1150k   44M|   0     0 |  13k 1300 </span><br><span class="line">  1   1  97   0   0   1|   0     0 |1190k   42M|   0     0 |  13k 1306 </span><br><span class="line">  1   1  98   0   0   1|   0     0 |1086k   42M|   0     0 |  13k 1320 </span><br><span class="line">  1   1  98   0   0   1|   0     0 |1186k   44M|   0     0 |  13k 1298 </span><br><span class="line">  1   1  98   0   0   1|   0    68k|1181k   41M|   0     0 |  14k 1348 </span><br><span class="line">  1   1  98   0   0   1|   0     0 | 853k   33M|   0     0 |  11k 1255 </span><br><span class="line">  1   1  98   0   0   0|   0     0 | 812k   37M|   0     0 |  10k 1149 </span><br><span class="line">  3   1  96   0   0   0|   0     0 | 876k   41M|   0     0 |  11k 1308 </span><br></pre></td></tr></table></figure>
<p><strong>结论：与rtmp类似，在拉取200kbps的流的情况下，大概在1000路拉流时，带宽43MB左右，CPU在41%左右，上限决定于带宽，
但是这里的CPU使用率显然比rtmp高得多。</strong></p>
<hr>
<h1 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h1><p>无论是推流还是拉流，实际上的瓶颈都在于<strong>带宽</strong>。并且在测试中srs实际上只使用了一个CPU核心，实际上还剩余了大量的CPU资源。</p>
<p><strong>由于srs-bench不支持flv推流测试，所以暂时没有对flv推流进行测试。</strong></p>
<h2 id="——————————————————"><a href="#——————————————————" class="headerlink" title="——————————————————-"></a>——————————————————-</h2><h1 id="2019-11-1补充：局域网测试"><a href="#2019-11-1补充：局域网测试" class="headerlink" title="2019-11-1补充：局域网测试"></a>2019-11-1补充：局域网测试</h1><p>上一次测试限于带宽只有300M，导致测试效果是带宽为瓶颈，这里在局域网中进行测试，有更大的带宽。</p>
<p>VM1：192.168.90.40</p>
<p>VM2：192.168.90.45</p>
<p>主机CPU为i7-8700，频率3.2GHz。</p>
<hr>
<h1 id="带宽测试-1"><a href="#带宽测试-1" class="headerlink" title="带宽测试"></a>带宽测试</h1><p><strong>VM1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ iperf3 -s -p 12345 -i 1</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Server listening on 12345</span><br><span class="line">-----------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p><strong>VM2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ iperf3 -c 192.168.90.40 -p12345 -i 1 -t 30</span><br><span class="line"></span><br><span class="line">Connecting to host 192.168.90.40, port 12345</span><br><span class="line">[  4] local 192.168.90.43 port 50380 connected to 192.168.90.40 port 12345</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth       Retr  Cwnd</span><br><span class="line">[  4]   0.00-1.00   sec   111 MBytes   932 Mbits&#x2F;sec    3    402 KBytes       </span><br><span class="line">[  4]   1.00-2.00   sec   113 MBytes   948 Mbits&#x2F;sec    0    581 KBytes       </span><br><span class="line">[  4]   2.00-3.00   sec   111 MBytes   934 Mbits&#x2F;sec    0    713 KBytes       </span><br><span class="line">[  4]   3.00-4.00   sec   111 MBytes   933 Mbits&#x2F;sec    0    826 KBytes       </span><br><span class="line">[  4]   4.00-5.00   sec   111 MBytes   933 Mbits&#x2F;sec    0    923 KBytes       </span><br><span class="line">[  4]   5.00-6.00   sec   111 MBytes   933 Mbits&#x2F;sec    0   1014 KBytes       </span><br><span class="line">[  4]   6.00-7.00   sec   111 MBytes   933 Mbits&#x2F;sec    0   1.07 MBytes       </span><br><span class="line">[  4]   7.00-8.00   sec   112 MBytes   944 Mbits&#x2F;sec    0   1.14 MBytes       </span><br><span class="line">[  4]   8.00-9.00   sec   111 MBytes   933 Mbits&#x2F;sec    0   1.21 MBytes     </span><br></pre></td></tr></table></figure>
<p>可以看到带宽接近千兆。</p>
<hr>
<h1 id="推拉流测试结果"><a href="#推拉流测试结果" class="headerlink" title="推拉流测试结果"></a>推拉流测试结果</h1><p>CPU为i7-8700，频率3.2GHz;带宽933 Mbits/sec。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>测试项目</th>
<th>单路流大小</th>
<th>推拉流数</th>
<th>CPU使用率</th>
<th>带宽占用   </th>
</tr>
</thead>
<tbody>
<tr>
<td>rtmp推流测试</td>
<td>200kbps</td>
<td>4000</td>
<td>100%</td>
<td>114M     </td>
</tr>
<tr>
<td>rtmp拉流测试</td>
<td>200kbps</td>
<td>4000</td>
<td>20%~40%</td>
<td>114M     </td>
</tr>
<tr>
<td>flv拉流测试</td>
<td>200kbps</td>
<td>4000</td>
<td>60%~80%</td>
<td>114M     </td>
</tr>
<tr>
<td>rtmp推流测试</td>
<td>1000kbps</td>
<td>500</td>
<td>40%~50%</td>
<td>60M~80M     </td>
</tr>
<tr>
<td>rtmp推流测试</td>
<td>1000kbps</td>
<td>1000</td>
<td>75%~80%</td>
<td>114M     </td>
</tr>
<tr>
<td>rtmp拉流测试</td>
<td>1000kbps</td>
<td>500</td>
<td>13%~15%</td>
<td>60M~80M     </td>
</tr>
<tr>
<td>rtmp拉流测试</td>
<td>1000kbps</td>
<td>1000</td>
<td>15%~17%</td>
<td>114M     </td>
</tr>
<tr>
<td>flv拉流测试</td>
<td>1000kbps</td>
<td>500</td>
<td>18%~20%</td>
<td>60M~80M     </td>
</tr>
<tr>
<td>flv拉流测试</td>
<td>1000kbps</td>
<td>1000</td>
<td>45%~50%</td>
<td>114M     </td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>live</category>
      </categories>
      <tags>
        <tag>live</tag>
        <tag>srs</tag>
      </tags>
  </entry>
  <entry>
    <title>srs中ffmpeg配置转码参数的一些介绍</title>
    <url>/2019/10/29/2019-10-29-srs_ffmpeg_transcode_params/</url>
    <content><![CDATA[<hr>
<h1 id="srs-所有转码参数介绍"><a href="#srs-所有转码参数介绍" class="headerlink" title="srs 所有转码参数介绍"></a>srs 所有转码参数介绍</h1><p>srs版本v2</p>
<p>参考来自<a href="https://github.com/ossrs/srs/wiki/v2_CN_FFMPEG">srs官方FFMPEG教程</a></p>
<p>首先是原官方文档：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen              1935;</span><br><span class="line">vhost __defaultVhost__ &#123;</span><br><span class="line">    # the streaming transcode configs.</span><br><span class="line">    transcode &#123;</span><br><span class="line">        # whether the transcode enabled.</span><br><span class="line">        # if off, donot transcode.</span><br><span class="line">        # default: off.</span><br><span class="line">        enabled     on;</span><br><span class="line">        # the ffmpeg </span><br><span class="line">        ffmpeg      .&#x2F;objs&#x2F;ffmpeg&#x2F;bin&#x2F;ffmpeg;</span><br><span class="line">        # the transcode engine for matched stream.</span><br><span class="line">        # all matched stream will transcoded to the following stream.</span><br><span class="line">        # the transcode set name(ie. hd) is optional and not used.</span><br><span class="line">        engine example &#123;</span><br><span class="line">            # whether the engine is enabled</span><br><span class="line">            # default: off.</span><br><span class="line">            enabled         on;</span><br><span class="line">            # input format, can be:</span><br><span class="line">            # off, do not specifies the format, ffmpeg will guess it.</span><br><span class="line">            # flv, for flv or RTMP stream.</span><br><span class="line">            # other format, for example, mp4&#x2F;aac whatever.</span><br><span class="line">            # default: flv</span><br><span class="line">            iformat         flv;</span><br><span class="line">            # ffmpeg filters, follows the main input.</span><br><span class="line">            vfilter &#123;</span><br><span class="line">                # the logo input file.</span><br><span class="line">                i               .&#x2F;doc&#x2F;ffmpeg-logo.png;</span><br><span class="line">                # the ffmpeg complex filter.</span><br><span class="line">                # for filters, @see: http:&#x2F;&#x2F;ffmpeg.org&#x2F;ffmpeg-filters.html</span><br><span class="line">                filter_complex  &#39;overlay&#x3D;10:10&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            # video encoder name. can be:</span><br><span class="line">            #       libx264: use h.264(libx264) video encoder.</span><br><span class="line">            #       copy: donot encoder the video stream, copy it.</span><br><span class="line">            #       vn: disable video output.</span><br><span class="line">            vcodec          libx264;</span><br><span class="line">            # video bitrate, in kbps</span><br><span class="line">            # @remark 0 to use source video bitrate.</span><br><span class="line">            # default: 0</span><br><span class="line">            vbitrate        1500;</span><br><span class="line">            # video framerate.</span><br><span class="line">            # @remark 0 to use source video fps.</span><br><span class="line">            # default: 0</span><br><span class="line">            vfps            25;</span><br><span class="line">            # video width, must be even numbers.</span><br><span class="line">            # @remark 0 to use source video width.</span><br><span class="line">            # default: 0</span><br><span class="line">            vwidth          768;</span><br><span class="line">            # video height, must be even numbers.</span><br><span class="line">            # @remark 0 to use source video height.</span><br><span class="line">            # default: 0</span><br><span class="line">            vheight         320;</span><br><span class="line">            # the max threads for ffmpeg to used.</span><br><span class="line">            # default: 1</span><br><span class="line">            vthreads        12;</span><br><span class="line">            # x264 profile, @see x264 -help, can be:</span><br><span class="line">            # high,main,baseline</span><br><span class="line">            vprofile        main;</span><br><span class="line">            # x264 preset, @see x264 -help, can be: </span><br><span class="line">            #       ultrafast,superfast,veryfast,faster,fast</span><br><span class="line">            #       medium,slow,slower,veryslow,placebo</span><br><span class="line">            vpreset         medium;</span><br><span class="line">            # other x264 or ffmpeg video params</span><br><span class="line">            vparams &#123;</span><br><span class="line">                # ffmpeg options, @see: http:&#x2F;&#x2F;ffmpeg.org&#x2F;ffmpeg.html</span><br><span class="line">                t               100;</span><br><span class="line">                # 264 params, @see: http:&#x2F;&#x2F;ffmpeg.org&#x2F;ffmpeg-codecs.html#libx264</span><br><span class="line">                coder           1;</span><br><span class="line">                b_strategy      2;</span><br><span class="line">                bf              3;</span><br><span class="line">                refs            10;</span><br><span class="line">            &#125;</span><br><span class="line">            # audio encoder name. can be:</span><br><span class="line">            #       libfdk_aac: use aac(libfdk_aac) audio encoder.</span><br><span class="line">            #       copy: donot encoder the audio stream, copy it.</span><br><span class="line">            #       an: disable audio output.</span><br><span class="line">            acodec          libfdk_aac;</span><br><span class="line">            # audio bitrate, in kbps. [16, 72] for libfdk_aac.</span><br><span class="line">            # @remark 0 to use source audio bitrate.</span><br><span class="line">            # default: 0</span><br><span class="line">            abitrate        70;</span><br><span class="line">            # audio sample rate. for flv&#x2F;rtmp, it must be:</span><br><span class="line">            #       44100,22050,11025,5512</span><br><span class="line">            # @remark 0 to use source audio sample rate.</span><br><span class="line">            # default: 0</span><br><span class="line">            asample_rate    44100;</span><br><span class="line">            # audio channel, 1 for mono, 2 for stereo.</span><br><span class="line">            # @remark 0 to use source audio channels.</span><br><span class="line">            # default: 0</span><br><span class="line">            achannels       2;</span><br><span class="line">            # other ffmpeg audio params</span><br><span class="line">            aparams &#123;</span><br><span class="line">                # audio params, @see: http:&#x2F;&#x2F;ffmpeg.org&#x2F;ffmpeg-codecs.html#Audio-Encoders</span><br><span class="line">                # @remark SRS supported aac profile for HLS is: aac_low, aac_he, aac_he_v2</span><br><span class="line">                profile:a   aac_low;</span><br><span class="line">                bsf:a       aac_adtstoasc;</span><br><span class="line">            &#125;</span><br><span class="line">            # output format, can be:</span><br><span class="line">            #       off, do not specifies the format, ffmpeg will guess it.</span><br><span class="line">            #       flv, for flv or RTMP stream.</span><br><span class="line">            #       other format, for example, mp4&#x2F;aac whatever.</span><br><span class="line">            # default: flv</span><br><span class="line">            oformat         flv;</span><br><span class="line">            # output stream. variables:</span><br><span class="line">            #       [vhost] the input stream vhost.</span><br><span class="line">            #       [port] the intput stream port.</span><br><span class="line">            #       [app] the input stream app.</span><br><span class="line">            #       [stream] the input stream name.</span><br><span class="line">            #       [engine] the tanscode engine name.</span><br><span class="line">            output          rtmp:&#x2F;&#x2F;127.0.0.1:[port]&#x2F;[app]?vhost&#x3D;[vhost]&#x2F;[stream]_[engine];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="转码engine配置"><a href="#转码engine配置" class="headerlink" title="转码engine配置"></a>转码engine配置</h1><p>一个 transcode 中可以配置多个 engine 来进行转码：</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vhost www.test.com &#123;</span><br><span class="line">    transcode &#123;</span><br><span class="line">        engine 360p &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        engine 480p &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        engine 720p &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="srs-中可使用的转码参数"><a href="#srs-中可使用的转码参数" class="headerlink" title="srs 中可使用的转码参数"></a>srs 中可使用的转码参数</h1><hr>
<h2 id="整体参数"><a href="#整体参数" class="headerlink" title="整体参数"></a>整体参数</h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 输入格式，其中flv表示输入格式为flv或者是RTMP。</span><br><span class="line">iformat         flv;</span><br><span class="line"></span><br><span class="line"># ffmpeg 滤镜</span><br><span class="line">vfilter &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 视频相关参数</span><br><span class="line">vcodec          libx264;</span><br><span class="line">vbitrate        1500;</span><br><span class="line">vfps            25;</span><br><span class="line">vwidth          768;</span><br><span class="line">vheight         320;</span><br><span class="line">vthreads        12;</span><br><span class="line">vprofile        main;</span><br><span class="line">vpreset         medium;</span><br><span class="line">vparams &#123;</span><br><span class="line">    t               100;</span><br><span class="line">    coder           1;</span><br><span class="line">    b_strategy      2;</span><br><span class="line">    bf              3;</span><br><span class="line">    refs            10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 音频相关参数</span><br><span class="line">acodec          libfdk_aac;</span><br><span class="line">abitrate        70;</span><br><span class="line">asample_rate    44100;</span><br><span class="line">achannels       2;</span><br><span class="line">aparams &#123;</span><br><span class="line">    profile:a   aac_low;</span><br><span class="line">    bsf:a       aac_adtstoasc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出格式，其中flv表示输出格式为flv或者是RTMP。</span><br><span class="line">oformat         flv;</span><br><span class="line"></span><br><span class="line"># 转码后的输出流</span><br><span class="line">output          rtmp:&#x2F;&#x2F;127.0.0.1:[port]&#x2F;[app]?vhost&#x3D;[vhost]&#x2F;[stream]_[engine];</span><br></pre></td></tr></table></figure></h2><h2 id="视频相关参数"><a href="#视频相关参数" class="headerlink" title="视频相关参数"></a>视频相关参数</h2><p><strong>vcodec：</strong></p>
<p>视频编码器名称，通常使用 libx264。</p>
<p><strong>vbitrate：</strong></p>
<p>视频编码所使用的码率，单位kbps。这里所设置的应该是视频的平均码率。</p>
<p><strong>vfps：</strong></p>
<p>视频帧率。</p>
<p><strong>vwidth：</strong></p>
<p>视频宽度。</p>
<p><strong>vheight：</strong></p>
<p>视频高度。</p>
<p><strong>vthreads：</strong></p>
<p>使用多少个线程来进行转码。开启多个线程需要codec（编解码器）支持才行。</p>
<p><strong>vprofile：</strong></p>
<p>可以简单理解为H264的版本，可以选择high,main,baseline。
暂时知道：压缩率 high &gt; main &gt; baseline。
暂时不知道它与画质有没有直接关系。</p>
<p><a href="https://blog.csdn.net/matrix_laboratory/article/details/72764621">H264 Profile对比分析</a></p>
<p><strong>vpreset：</strong></p>
<p>用于调节编码速度和质量的平衡。
可以设置为：ultrafast,superfast,veryfast,faster,fast,medium,slow,slower,veryslow,placebo</p>
<p><strong>vparams：</strong></p>
<p>可以添加一些x264或者视频相关的参数。</p>
<ul>
<li>t：限制从输入文件读取的时长</li>
<li>coder：x264使用，熵编码相关参数。</li>
<li>b_strategy：x264使用，自适应的添加B帧数目，<code>Use only on first-pass</code>。</li>
<li>bf：<code>max number of B frames</code>。</li>
<li>refs：<code>Set reference frames to consider for motion compensation</code>。</li>
</ul>
<p><strong>实际上可以在这个参数中添加各种参数，而这些参数都会被添加在-preset后面。</strong></p>
<hr>
<h2 id="视频滤镜-vfilter"><a href="#视频滤镜-vfilter" class="headerlink" title="视频滤镜 vfilter"></a>视频滤镜 vfilter</h2><p><strong>i：</strong></p>
<p>表示输入，例如加水印时，就需要额外的图片作为输入。</p>
<p>可以有多个输入，并且输入也可以是流的形式，意思是可以支持多路流合并成为一路流。</p>
<p><strong>filter_complex：</strong></p>
<p>也就是FFmpeg的filter_complex，一个<code>filtergraph</code>，支持多个输入流。</p>
<p>使用它可以做各种事情，后面使用举例说明。</p>
<p>详细使用方法可以参考官方文档:<a href="http://ffmpeg.org/ffmpeg-filters.html#Filtergraph-syntax-1">4.1 Filtergraph syntax</a></p>
<hr>
<h2 id="音频相关参数"><a href="#音频相关参数" class="headerlink" title="音频相关参数"></a>音频相关参数</h2><p><strong>acodec：</strong></p>
<p>音频编码器，通常使用 libfdk_aac 。</p>
<p><strong>abitrate：</strong></p>
<p>音频码率，单位kbps，<code>[16, 72] for libfdk_aac</code>。</p>
<p><strong>asample_rate：</strong></p>
<p>音频采样率，对于 flv和rtmp，只能设置为 44100,22050,11025,5512。</p>
<p><strong>achannels：</strong></p>
<p>声道，1表示单声道，2表示双声道。</p>
<p><strong>aparams：</strong></p>
<p>可以在里面填一些与音频相关的转码参数，同样的，这些参数会接在<code>achannels</code>(<code>-ac</code>)的后面。</p>
<ul>
<li>profile:a 与h264编码中的profile类似，这里支持 aac_low, aac_he, aac_he_v2 这几种参数的设置。</li>
<li>bsf:a 表示<code>Bitstream Filters</code>，详细参考<a href="http://ffmpeg.org/ffmpeg-all.html#Bitstream-Filters">18 Bitstream Filters</a>。</li>
</ul>
<hr>
<h1 id="转码配置举例"><a href="#转码配置举例" class="headerlink" title="转码配置举例"></a>转码配置举例</h1><hr>
<h2 id="改变视频分辨率"><a href="#改变视频分辨率" class="headerlink" title="改变视频分辨率"></a>改变视频分辨率</h2><p><strong>方法一：</strong></p>
<p>使用<code>vwidth</code>和<code>vheight</code>参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vhost www.transcode.com &#123;</span><br><span class="line">    transcode &#123;</span><br><span class="line">        enabled      on;</span><br><span class="line">        ffmpeg      .&#x2F;objs&#x2F;ffmpeg&#x2F;bin&#x2F;ffmpeg;</span><br><span class="line">        engine 1080_60  &#123;</span><br><span class="line">            enabled         on;</span><br><span class="line">            vfilter &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            vcodec          libx264;</span><br><span class="line">            vbitrate        5000;</span><br><span class="line">            vfps            60;</span><br><span class="line">            vwidth          1920;</span><br><span class="line">            vheight         1080;</span><br><span class="line">            vthreads        12;</span><br><span class="line">            vprofile        main;</span><br><span class="line">            vpreset         fast;</span><br><span class="line">            vparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            acodec          libfdk_aac;</span><br><span class="line">            abitrate        50;</span><br><span class="line">            asample_rate    44100;</span><br><span class="line">            achannels       2;</span><br><span class="line">            aparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            output          rtmp:&#x2F;&#x2F;192.168.90.229:2019&#x2F;persist?vhost&#x3D;lrm.test.com&#x2F;long_1080_60;</span><br><span class="line">        &#125;</span><br><span class="line">        engine 720_60  &#123;</span><br><span class="line">            enabled         on;</span><br><span class="line">            vfilter &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            vcodec          libx264;</span><br><span class="line">            vbitrate        3500;</span><br><span class="line">            vfps            60;</span><br><span class="line">            vwidth          1280;</span><br><span class="line">            vheight         720;</span><br><span class="line">            vthreads        12;</span><br><span class="line">            vprofile        main;</span><br><span class="line">            vpreset         fast;</span><br><span class="line">            vparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            acodec          libfdk_aac;</span><br><span class="line">            abitrate        50;</span><br><span class="line">            asample_rate    44100;</span><br><span class="line">            achannels       2;</span><br><span class="line">            aparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            output          rtmp:&#x2F;&#x2F;192.168.90.229:2019&#x2F;persist?vhost&#x3D;lrm.test.com&#x2F;long_720_60;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面转码将视频转码成<code>1080P+60fps</code>和<code>720P+60fps</code>。</p>
<p><strong>方法二：</strong></p>
<p>使用<code>filter_complex</code>，在其中使用scale滤镜来缩减分辨率，并将<code>vwidth</code>和<code>vheight</code>设置为0。</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vhost www.transcode.com &#123;</span><br><span class="line">    transcode &#123;</span><br><span class="line">        enabled      on;</span><br><span class="line">        ffmpeg      .&#x2F;objs&#x2F;ffmpeg&#x2F;bin&#x2F;ffmpeg;</span><br><span class="line">        engine 720_60  &#123;</span><br><span class="line">            enabled         on;</span><br><span class="line">            vfilter &#123;</span><br><span class="line">                filter_complex  &#39;scale&#x3D;1280:-1&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            vcodec          libx264;</span><br><span class="line">            vbitrate        3500;</span><br><span class="line">            vfps            60;</span><br><span class="line">            vwidth          0;</span><br><span class="line">            vheight         0;</span><br><span class="line">            vthreads        12;</span><br><span class="line">            vprofile        main;</span><br><span class="line">            vpreset         fast;</span><br><span class="line">            vparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            acodec          libfdk_aac;</span><br><span class="line">            abitrate        50;</span><br><span class="line">            asample_rate    44100;</span><br><span class="line">            achannels       2;</span><br><span class="line">            aparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            output          rtmp:&#x2F;&#x2F;192.168.90.229:2019&#x2F;persist?vhost&#x3D;lrm.test.com&#x2F;long_720_60;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p><strong>结论：推荐使用方法二。</strong></p>
<p>如果输入视频不是16:9分辨率时，使用方法一转码视频造成画面拉伸，因为它的<code>vwidth</code>和<code>vheight</code>参数反映到FFmpeg中是<code>-s vwidth x vheight</code>，
使用-1时则会报错。而使用方法二则可以使用-1来维持原画面比例。</p>
<hr>
<h2 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h2><p>官方例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vhost __defaultVhost__ &#123;</span><br><span class="line">    transcode &#123;</span><br><span class="line">        enabled     on;</span><br><span class="line">        ffmpeg      .&#x2F;objs&#x2F;ffmpeg&#x2F;bin&#x2F;ffmpeg;</span><br><span class="line">        engine ff &#123;</span><br><span class="line">            enabled         on;</span><br><span class="line">            vfilter &#123;</span><br><span class="line">                i               .&#x2F;doc&#x2F;ffmpeg-logo.png;</span><br><span class="line">                filter_complex      &#39;overlay&#x3D;10:10&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            vcodec          libx264;</span><br><span class="line">            vbitrate        300;</span><br><span class="line">            vfps            20;</span><br><span class="line">            vwidth          768;</span><br><span class="line">            vheight         320;</span><br><span class="line">            vthreads        2;</span><br><span class="line">            vprofile        baseline;</span><br><span class="line">            vpreset         superfast;</span><br><span class="line">            vparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            acodec          libfdk_aac;</span><br><span class="line">            abitrate        45;</span><br><span class="line">            asample_rate    44100;</span><br><span class="line">            achannels       2;</span><br><span class="line">            aparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            output          rtmp:&#x2F;&#x2F;127.0.0.1:[port]&#x2F;[app]?vhost&#x3D;[vhost]&#x2F;[stream]_[engine];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现方法，使用<code>vfilter</code>，输入图片并使用滤镜<code>overlay</code>来完成。</p>
<hr>
<h2 id="CBR恒定编码实现"><a href="#CBR恒定编码实现" class="headerlink" title="CBR恒定编码实现"></a>CBR恒定编码实现</h2><p>先来看一下使用<code>bitrate</code>来控制码率的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vhost lrm.test.com &#123;</span><br><span class="line">    transcode &#123;</span><br><span class="line">        enabled      on;</span><br><span class="line">        ffmpeg      .&#x2F;objs&#x2F;ffmpeg&#x2F;bin&#x2F;ffmpeg;</span><br><span class="line">        engine ff &#123;</span><br><span class="line">            enabled         on;</span><br><span class="line">            vfilter &#123;</span><br><span class="line">                i               .&#x2F;doc&#x2F;ffmpeg-logo.png;</span><br><span class="line">                filter_complex  &#39;[1][0]scale2ref&#x3D;w&#x3D;iw&#x2F;8:h&#x3D;ow&#x2F;mdar[scaled][0-out]; [0-out][scaled]overlay&#x3D;x&#x3D;main_w&#x2F;10-w&#x2F;2:y&#x3D;main_h&#x2F;10-h&#x2F;2[over]; [over]scale&#x3D;1280:-1&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            vcodec          libx264;</span><br><span class="line">            vbitrate        3500;</span><br><span class="line">            vfps            60;</span><br><span class="line">            vwidth          0;</span><br><span class="line">            vheight         0;</span><br><span class="line">            vthreads        12;</span><br><span class="line">            vprofile        main;</span><br><span class="line">            vpreset         fast;</span><br><span class="line">            vparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            acodec          libfdk_aac;</span><br><span class="line">            abitrate        50;</span><br><span class="line">            asample_rate    44100;</span><br><span class="line">            achannels       2;</span><br><span class="line">            aparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            output          rtmp:&#x2F;&#x2F;127.0.0.1:[port]&#x2F;[app]?vhost&#x3D;[vhost]&#x2F;[stream]_[engine];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将<code>vbitrate</code>设置在3500，也就是我们希望码率可以控制在3500kbps，使用VLC播放器可以看到大概的统计效果：</p>
<p><img src="/images/media/FFmpeg/bitrate-1.png" alt="image" title="使用bitrate控制码率"></p>
<p>参数中虽然可以使用<code>bitrate</code>来指定码率，但是实际上这只是平均码率，但是实际码率还是会<strong>上下波动，并且范围也不小</strong>。</p>
<p>可以使用下面方法来实现<strong>CBR</strong>，也是FFmpeg文档中所述的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vhost lrm.test.com &#123;</span><br><span class="line">    transcode &#123;</span><br><span class="line">        enabled      on;</span><br><span class="line">        ffmpeg      .&#x2F;objs&#x2F;ffmpeg&#x2F;bin&#x2F;ffmpeg;</span><br><span class="line">        engine ff &#123;</span><br><span class="line">            enabled         on;</span><br><span class="line">            vfilter &#123;</span><br><span class="line">                i               .&#x2F;doc&#x2F;ffmpeg-logo.png;</span><br><span class="line">                filter_complex  &#39;[1][0]scale2ref&#x3D;w&#x3D;iw&#x2F;8:h&#x3D;ow&#x2F;mdar[scaled][0-out]; [0-out][scaled]overlay&#x3D;x&#x3D;main_w&#x2F;10-w&#x2F;2:y&#x3D;main_h&#x2F;10-h&#x2F;2[over]; [over]scale&#x3D;1280:-1&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            vcodec          libx264;</span><br><span class="line">            vbitrate        3500;</span><br><span class="line">            vfps            60;</span><br><span class="line">            vwidth          0;</span><br><span class="line">            vheight         0;</span><br><span class="line">            vthreads        12;</span><br><span class="line">            vprofile        main;</span><br><span class="line">            vpreset         fast;</span><br><span class="line">            vparams &#123;</span><br><span class="line">                maxrate:v     3500k;</span><br><span class="line">                minrate:v     3500k;</span><br><span class="line">                bufsize:v     3500k;</span><br><span class="line">            &#125;</span><br><span class="line">            acodec          libfdk_aac;</span><br><span class="line">            abitrate        50;</span><br><span class="line">            asample_rate    44100;</span><br><span class="line">            achannels       2;</span><br><span class="line">            aparams &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            output          rtmp:&#x2F;&#x2F;127.0.0.1:[port]&#x2F;[app]?vhost&#x3D;[vhost]&#x2F;[stream]_[engine];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面配置中，增加设置<code>maxrate</code>，<code>minrate</code>，<code>bufsize</code>来配合控制视频的码率。</p>
<p><img src="/images/media/FFmpeg/bitrate-2.png" alt="image" title="增加设置`maxrate`，`minrate`，`bufsize`来配合控制视频的码率"></p>
<p>实际效果并不能固定码率，码率仍然在上下波动，但很明显能达到更小的波动范围。</p>
<hr>
]]></content>
      <categories>
        <category>live</category>
      </categories>
      <tags>
        <tag>live</tag>
        <tag>srs</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>使用C语言调用FFmpeg来进行固定时间间隔截图(rtmp直播流)</title>
    <url>/2019/12/23/2019-12-23-ffmpeg-screenshot-2/</url>
    <content><![CDATA[<hr>
<h1 id="使用C语言调用FFmpeg"><a href="#使用C语言调用FFmpeg" class="headerlink" title="使用C语言调用FFmpeg"></a>使用C语言调用FFmpeg</h1><p><a href="http://longrm.com/2019/12/19/2019-11-27-ffmpeg-screenshot/">使用FFmpeg来进行固定时间间隔截图（rtmp直播流）</a></p>
<p>在我上面的博客中总结了一些通过CMD调用FFmpeg来完成截图的方法，里面的方法虽然进化得越来越好，但是始终是不完美的。</p>
<p>为了达到基本可控的截图，那么就需要自己能够控制整个编解码过程，那么就只能通过代码的方式来进行了。</p>
<p>由于github上Golang包装好的的FFmpeg库，个人感觉并不好用，或者说并不比直接写C语言好用，所以这里决定直接使用C语言。</p>
<p>FFmpeg编解码的过程我主要参考的下面的博客：</p>
<p><a href="https://www.cnblogs.com/leisure_chn/p/10584901.html">FFmpeg编解码处理1-转码全流程简介</a></p>
<p><a href="https://lightfish.cn/2018-12-20-ffmpeg-primer">ffmpeg的C语言编程入门</a></p>
<p>FFmpeg编解码过程参考上面博客即可。</p>
<p>这里要进行截图主要的流程是：<strong>输入-&gt;解封装-&gt;找到单个keyPacket-&gt;解码-&gt;frame转换-&gt;编码为packet-&gt;封装-&gt;输出</strong>。</p>
<hr>
<h1 id="FFmpeg编程环境"><a href="#FFmpeg编程环境" class="headerlink" title="FFmpeg编程环境"></a>FFmpeg编程环境</h1><p><a href="https://www.jianshu.com/p/7baf03b1a868">FFmpeg下载与配置（Visual Studio）</a></p>
<p>这里我没有使用C++来写，因为出现一堆我解决不了的问题…所以直接使用C来写的（也就是.c文件而不是.cpp）。</p>
<hr>
<h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考 https://www.cnblogs.com/leisure_chn/p/10584901.html</span></span><br><span class="line"><span class="comment">// https://blog.csdn.net/lightfish_zhang/article/details/86594694</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些全局变量</span></span><br><span class="line"><span class="keyword">char</span> nameBuffer[<span class="number">256</span>], intBuffer[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">char</span>* infilename, * outfilename_head;</span><br><span class="line"><span class="keyword">int</span> inWidth, inHeight;</span><br><span class="line"><span class="keyword">int</span> outWidth, outHeight;    <span class="comment">// 输出的高宽，可以通过输入参数来自己定义</span></span><br><span class="line"><span class="keyword">int</span> pts;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些统计用的全局变量</span></span><br><span class="line"><span class="keyword">int</span> picture_num = <span class="number">1000</span>;     <span class="comment">// 一共截多少张图，可以通过输入参数来自己定义</span></span><br><span class="line"><span class="keyword">int</span> time_interval = <span class="number">1</span>;       <span class="comment">// 间隔多少时间进行一次截图，可以通过输入参数来自己定义，但是下限是GOP的大小，设置比GOP小就等于GOP</span></span><br><span class="line"><span class="keyword">int</span> picture_count = <span class="number">0</span>, pkt_count = <span class="number">0</span>, key_pkt_count = <span class="number">0</span>, out_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码相关变量</span></span><br><span class="line">AVFormatContext* ifmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVCodecContext* deCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line">AVCodec* deCodec = <span class="literal">NULL</span>;</span><br><span class="line">AVPacket* dePkt = <span class="literal">NULL</span>;</span><br><span class="line">AVFrame* deFrame = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> video_stream_index;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码相关变量</span></span><br><span class="line">AVFormatContext* ofmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVOutputFormat* ofmt = <span class="literal">NULL</span>;</span><br><span class="line">AVCodecContext* enCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line">AVStream* ostream = <span class="literal">NULL</span>;</span><br><span class="line">AVCodec* enCodec = <span class="literal">NULL</span>;</span><br><span class="line">AVPacket* enPkt = <span class="literal">NULL</span>;</span><br><span class="line">AVFrame* enframe = <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SwsContext</span>* <span class="title">sws_ctx</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化解码相关变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitDecodeParam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/*********************** 分配输入 AVFormatContext **********************/</span></span><br><span class="line">	ifmt_ctx = avformat_alloc_context();</span><br><span class="line">	ret = avformat_open_input(&amp;ifmt_ctx, infilename, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not open input file &#x27;%s&#x27;.\n&quot;</span>, infilename);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/**************************** 读取输入流的信息 *************************/</span></span><br><span class="line">	ret = avformat_find_stream_info(ifmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to retrieve input stream information.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/****************************** 打印输入信息 ***************************/</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;--------------------------------------\n&quot;</span>);</span><br><span class="line">	av_dump_format(ifmt_ctx, <span class="number">0</span>, infilename, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;--------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/****************** 使用 av_find_best_stream 找到视频流 ****************/</span></span><br><span class="line">	video_stream_index = av_find_best_stream(ifmt_ctx, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (video_stream_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not find video stream.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/******************************** 找到解码器 ***************************/</span></span><br><span class="line">	deCodec = avcodec_find_decoder(ifmt_ctx-&gt;streams[video_stream_index]-&gt;codecpar-&gt;codec_id);</span><br><span class="line">	<span class="keyword">if</span> (!deCodec) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can not find decodec\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/*************************** 分配解码器 context ************************/</span></span><br><span class="line">	deCodecCtx = avcodec_alloc_context3(deCodec);</span><br><span class="line">	<span class="keyword">if</span> (!deCodecCtx) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to allocate the decoder context for stream\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/***************************** 给解码器赋予参数 *************************/</span></span><br><span class="line">	<span class="comment">// 不同的输入需要不同的解码器来解码，这里赋予其参数后，它才能对这个流进行解码</span></span><br><span class="line">	ret = avcodec_parameters_to_context(deCodecCtx, ifmt_ctx-&gt;streams[video_stream_index]-&gt;codecpar);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to copy decoder parameters to input decoder context for stream\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/******************************* 打开解码器 ****************************/</span></span><br><span class="line">	ret = avcodec_open2(deCodecCtx, deCodec, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can not open decodec\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/******************************** 分配pkt *****************************/</span></span><br><span class="line">	dePkt = av_packet_alloc();</span><br><span class="line">	<span class="keyword">if</span> (!dePkt) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not allocate pkt\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/******************************** 分配frame ***************************/</span></span><br><span class="line">	deFrame = av_frame_alloc();</span><br><span class="line">	<span class="keyword">if</span> (!deFrame) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not allocate frame\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存长宽到全局</span></span><br><span class="line">	inWidth = deCodecCtx-&gt;width;</span><br><span class="line">	inHeight = deCodecCtx-&gt;height;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化编码相关变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitEncodeParam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/*********************** 分配输出 AVFormatContext **********************/</span></span><br><span class="line">	ret = avformat_alloc_output_context2(&amp;ofmt_ctx, <span class="literal">NULL</span>, <span class="string">&quot;image2&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Alloc output context failed.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ofmt = ofmt_ctx-&gt;oformat;</span><br><span class="line">	ofmt-&gt;flags = ofmt-&gt;flags &amp; ~AVFMT_NOFILE; <span class="comment">// 置 AVFMT_NOFILE 置为零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/************************ 构建一个新stream，用于输出 ********************/</span></span><br><span class="line">	ostream = avformat_new_stream(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ostream == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Frame2JPG:: avformat_new_stream error.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ostream-&gt;id = ofmt_ctx-&gt;nb_streams - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">    <span class="comment">/***************************** 查找编码器 ******************************/</span></span><br><span class="line">	enCodec = avcodec_find_encoder(ofmt-&gt;video_codec);</span><br><span class="line">	<span class="keyword">if</span> (!enCodec) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;avcodec_find_encoder() error.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">    <span class="comment">/************************* 分配编码器context ***************************/</span></span><br><span class="line">	enCodecCtx = avcodec_alloc_context3(enCodec);</span><br><span class="line">	<span class="keyword">if</span> (!enCodecCtx) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not allocate video codec context\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	enCodecCtx-&gt;codec_id = ofmt-&gt;video_codec;</span><br><span class="line">	enCodecCtx-&gt;codec_type = AVMEDIA_TYPE_VIDEO;</span><br><span class="line">	enCodecCtx-&gt;pix_fmt = AV_PIX_FMT_YUVJ420P;</span><br><span class="line">	enCodecCtx-&gt;color_range = AVCOL_RANGE_JPEG;</span><br><span class="line">	enCodecCtx-&gt;width = outWidth;</span><br><span class="line">	enCodecCtx-&gt;height = outHeight;</span><br><span class="line">	enCodecCtx-&gt;time_base.num = <span class="number">1</span>;</span><br><span class="line">	enCodecCtx-&gt;time_base.den = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">    <span class="comment">/***************************** 打开编码器 ******************************/</span></span><br><span class="line">	ret = avcodec_open2(enCodecCtx, enCodec, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not open codec.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">    <span class="comment">/*************************** 分配stream参数 ****************************/</span></span><br><span class="line">	<span class="comment">// 将enCodecCtx中的参数复制到 ostream 中，否则这个stream不知道自己是个啥</span></span><br><span class="line">	ret = avcodec_parameters_from_context(ostream-&gt;codecpar, enCodecCtx);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not copy the stream parameters\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/*************************** 分配编码使用的PKT *************************/</span></span><br><span class="line">	enPkt = av_packet_alloc();</span><br><span class="line">	<span class="keyword">if</span> (!enPkt) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not allocate pkt\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/************************** 分配编码使用的frame ************************/</span></span><br><span class="line">	<span class="comment">// 这个frame用于将解码得到的frame进行格式转换，才能继续送入编码器，否则出来的图片看不懂</span></span><br><span class="line">	enframe = av_frame_alloc();</span><br><span class="line">	<span class="keyword">if</span> (!enframe) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not allocate frame\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	enframe-&gt;format = enCodecCtx-&gt;pix_fmt;</span><br><span class="line">	enframe-&gt;color_range = enCodecCtx-&gt;color_range;</span><br><span class="line">	enframe-&gt;width = enCodecCtx-&gt;width;</span><br><span class="line">	enframe-&gt;height = enCodecCtx-&gt;height;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 给frame实际分配buffer</span></span><br><span class="line">	ret = av_frame_get_buffer(enframe, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not allocate frame data.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ensure that the frame data is writable, avoiding data copy if possible.</span></span><br><span class="line">	<span class="comment">// 避免数据复制占用内存，实际不知道有没有用。</span></span><br><span class="line">	ret = av_frame_make_writable(enframe);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 帧变换context，初始化一次就够了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocateSws</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!sws_ctx) &#123;</span><br><span class="line">		sws_ctx = sws_getContext(deFrame-&gt;width, deFrame-&gt;height,</span><br><span class="line">			deFrame-&gt;format,</span><br><span class="line">			enCodecCtx-&gt;width, enCodecCtx-&gt;height,</span><br><span class="line">			enCodecCtx-&gt;pix_fmt,</span><br><span class="line">			SWS_FAST_BILINEAR, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个deFrame转换成一张 JPEG 图片</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Frame2JPG</span><span class="params">(<span class="keyword">char</span>* out_file)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">    <span class="comment">/**************************** 打开输出文件 *****************************/</span></span><br><span class="line">	<span class="comment">// pb 是一个 AVIOContext ，这里应该是打开 outfilename ，将句柄存入pb中</span></span><br><span class="line">	<span class="comment">// 这样每次转换frame到jpg不需要重新分配编码器，只需要每次打开新文件即可</span></span><br><span class="line">	ret = avio_open(&amp;ofmt_ctx-&gt;pb, out_file, AVIO_FLAG_WRITE);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not open output file &#x27;%s&#x27;\n&quot;</span>, out_file);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印输出文件信息</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------\n&quot;</span>);</span><br><span class="line">	av_dump_format(ofmt_ctx, <span class="number">0</span>, out_file, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/************************* 写入头部信息到文件 ***************************/</span></span><br><span class="line">	ret = avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Write head to output file error.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/******************* 将deFrame变换写入到enFrame中 **********************/</span></span><br><span class="line">	allocateSws();</span><br><span class="line">	<span class="keyword">if</span> (!sws_ctx) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not initialize the conversion context\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line">	sws_scale(sws_ctx, (<span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span>*)deFrame-&gt;data,</span><br><span class="line">		deFrame-&gt;linesize, <span class="number">0</span>, deFrame-&gt;height, enframe-&gt;data,</span><br><span class="line">		enframe-&gt;linesize);</span><br><span class="line">	enframe-&gt;pts = pts++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">    <span class="comment">/************************** enFrame送入编码器 **************************/</span></span><br><span class="line">	<span class="comment">// 这里完成对enFrame的编码，形成pkt，并写入到输出文件</span></span><br><span class="line">	ret = avcodec_send_frame(enCodecCtx, enframe);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Send IFrame to decodec error.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		ret = avcodec_receive_packet(enCodecCtx, dePkt);</span><br><span class="line">		<span class="keyword">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) &#123;</span><br><span class="line">			ret = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error during encoding\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> end;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------\n&quot;</span>);</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Write to picture [num = %d] [name = %s] [data size = %5d byte]\n&quot;</span>, </span><br><span class="line">			picture_count, out_file, dePkt-&gt;size);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------\n&quot;</span>);</span><br><span class="line">		ret = av_write_frame(ofmt_ctx, dePkt);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Write frame to output failed.\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> end;</span><br><span class="line">		&#125;</span><br><span class="line">		av_packet_unref(dePkt);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/************************* 写入尾部信息到文件中 *************************/</span></span><br><span class="line">	av_write_trailer(ofmt_ctx);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Encoding picture success.\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Encoding picture Failed.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/****************************** 关闭输出文件 ***************************/</span></span><br><span class="line">	avio_closep(&amp;ofmt_ctx-&gt;pb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建输出文件名，例如 test0.jpg  test1.jpg  test2.jpg</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">constuctFileName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(nameBuffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(nameBuffer));</span><br><span class="line">	<span class="built_in">memset</span>(intBuffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(intBuffer));</span><br><span class="line">	itoa(out_num, intBuffer, <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">strcat</span>(nameBuffer, outfilename_head);</span><br><span class="line">	<span class="built_in">strcat</span>(nameBuffer, intBuffer);</span><br><span class="line">	<span class="built_in">strcat</span>(nameBuffer, <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">	out_num = (out_num + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closeDecodeParam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	av_frame_free(&amp;deFrame);</span><br><span class="line">	av_packet_free(&amp;dePkt);</span><br><span class="line">	avcodec_free_context(&amp;deCodecCtx);</span><br><span class="line">	avformat_free_context(ifmt_ctx);</span><br><span class="line">	video_stream_index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closeEncodeParam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	av_frame_free(&amp;enframe);</span><br><span class="line">	av_packet_free(&amp;enPkt);</span><br><span class="line">	avcodec_free_context(&amp;enCodecCtx);</span><br><span class="line">	avformat_free_context(ofmt_ctx);</span><br><span class="line">	sws_freeContext(sws_ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;input file&gt; &lt;output file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	infilename = argv[<span class="number">1</span>];</span><br><span class="line">	outfilename_head = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;------------- begin -------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// InitDecodeParam</span></span><br><span class="line">	ret = InitDecodeParam();</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置输出的宽高</span></span><br><span class="line">	outWidth = inWidth;</span><br><span class="line">	outHeight = inHeight;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// InitEncodeParam</span></span><br><span class="line">	ret = InitEncodeParam();</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************/</span></span><br><span class="line">	<span class="comment">/****************************** 关闭输出文件 ***************************/</span></span><br><span class="line">	<span class="comment">// 1. 每次只将关键帧送入解码器，使用 dePkt-&gt;flags 来判断是否关键帧，可以减少解码CPU消耗。</span></span><br><span class="line">	<span class="comment">// 2. 每过一定时间间隔截取一张图片，这里通过 dePkt-&gt;pts 来判断包的时间。</span></span><br><span class="line">	<span class="keyword">while</span> (picture_count &lt; picture_num &amp;&amp; av_read_frame(ifmt_ctx, dePkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		pkt_count++;</span><br><span class="line">		<span class="comment">// 判断pkt属于视频流，并且是关键帧，这样就不用一直解包</span></span><br><span class="line">		<span class="keyword">if</span> (dePkt-&gt;stream_index == video_stream_index &amp;&amp; (dePkt-&gt;flags &amp; AV_PKT_FLAG_KEY)) &#123;</span><br><span class="line">			<span class="keyword">double</span> timeStamp = dePkt-&gt;pts * av_q2d(ifmt_ctx-&gt;streams[video_stream_index]-&gt;time_base);</span><br><span class="line">			<span class="keyword">if</span> (timeStamp &lt; (<span class="keyword">double</span>)time_interval * key_pkt_count) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			key_pkt_count++;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Send an key packet to decodec. timeStamp: %.2f s.\n&quot;</span>, timeStamp);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将这个pkt解码</span></span><br><span class="line">			ret = avcodec_send_packet(deCodecCtx, dePkt);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error sending a packet for decoding\n&quot;</span>);</span><br><span class="line">				<span class="keyword">goto</span> end;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将道理，对于视频来说，一个pkt应该只对应一个frame</span></span><br><span class="line">			<span class="keyword">while</span> (picture_count &lt; picture_num &amp;&amp; ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				ret = avcodec_receive_frame(deCodecCtx, deFrame);</span><br><span class="line">				<span class="keyword">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) &#123;</span><br><span class="line">					ret = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error during decoding\n&quot;</span>);</span><br><span class="line">					<span class="keyword">goto</span> end;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (deFrame-&gt;pict_type == AV_PICTURE_TYPE_I) &#123; <span class="comment">// 确定是关键帧，讲道理必然是</span></span><br><span class="line">					constuctFileName();</span><br><span class="line"></span><br><span class="line">					ret = Frame2JPG(nameBuffer);</span><br><span class="line">					<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Trancode to jpeg failed.\n&quot;</span>);</span><br><span class="line">						<span class="keyword">goto</span> end;</span><br><span class="line">					&#125;</span><br><span class="line">					picture_count++;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Warning: Not key frame.\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		av_packet_unref(dePkt);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error occurred: %s\n&quot;</span>, av_err2str(ret));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;SUCCESS\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pkt_count = %d, key_pkt_count = %d, picture_count = %d\n&quot;</span>, pkt_count, key_pkt_count, picture_count);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放资源</span></span><br><span class="line">	closeDecodeParam();</span><br><span class="line">	closeEncodeParam();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于持续的在线截图来说，能降低CPU使用就尽量降低CPU使用，所以上面代码里面编解码器都是复用的，每次只是打开新的输出文件来写入图片而已。</p>
<p><strong>但是这里存在一个问题，在调用<code>avcodec_send_packet()</code>函数的时候，你会发现必须要送入3个Packet，才会解码得到第一个frame，</strong>
<strong>这是解码器的缓存机制造成的，这个问题意味着：</strong></p>
<ol>
<li>第一张截图的获得需要经过2个interval，每一张截图的都会延迟2个interval。</li>
<li>最后2张截图没法获取。</li>
</ol>
<p><strong>这个问题最好就是解码器能够每次立即对一个Packet进行解码，但是貌似做不到。下面是<code>avcodec_send_packet()</code>代码中的注释：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* @param[in] avpkt The input AVPacket. Usually, this will be a single video</span><br><span class="line">*                  frame, or several complete audio frames.</span><br><span class="line">*                  Ownership of the packet remains with the caller, and the</span><br><span class="line">*                  decoder will not write to the packet. The decoder may create</span><br><span class="line">*                  a reference to the packet data (or copy it if the packet is</span><br><span class="line">*                  not reference-counted).</span><br><span class="line">*                  Unlike with older APIs, the packet is always fully consumed,</span><br><span class="line">*                  and if it contains multiple frames (e.g. some audio codecs),</span><br><span class="line">*                  will require you to call avcodec_receive_frame() multiple</span><br><span class="line">*                  times afterwards before you can send a new packet.</span><br><span class="line">*                  It can be NULL (or an AVPacket with data set to NULL and</span><br><span class="line">*                  size set to 0); in this case, it is considered a flush</span><br><span class="line">*                  packet, which signals the end of the stream. Sending the</span><br><span class="line">*                  first flush packet will return success. Subsequent ones are</span><br><span class="line">*                  unnecessary and will return AVERROR_EOF. If the decoder</span><br><span class="line">*                  still has frames buffered, it will return them after sending</span><br><span class="line">*                  a flush packet.</span><br></pre></td></tr></table></figure>
<p><strong>所以要是想截图的生产没有延迟，那就需要：</strong></p>
<ol>
<li>在发送一个Packet到解码器之后，再发送一个NULL的AVPacket。</li>
<li>解码器不能复用，每次需要重新new。这个应该也不会对CPU有什么消耗。</li>
</ol>
<p>解决这些问题，就可以愉快的进行固定时间间隔的截图了。</p>
<hr>
<h2 id="2020-05-07-更新"><a href="#2020-05-07-更新" class="headerlink" title="2020-05-07 更新"></a>2020-05-07 更新</h2><p>今天测试了一下内存占用的情况，首先这个代码是<strong>没有内存泄漏</strong>的，我跑了几个小时试过，内存占用没有增加。</p>
<p>下面测试的时候使用的是1Mbps的流（或者flv文件）来测试的，通过几个阶段来测试内存占用：</p>
<ol>
<li>只加载代码，也就是在代码第一行就阻塞了。</li>
<li>通过输入流信息（或者文件），初始化编解码器，然后阻塞。</li>
<li>正常拉流截图。</li>
</ol>
<p>大致结果如下（windows10）：</p>
<p><img src="/images/media/FFmpeg/ffmpeg-mem.png" alt="image" title="各种情况的内存占用"></p>
<p>大致可以看得出来，在编解码实际运行之前，占用内存并不多。（这里没有更加深入的分析。。。。）</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/7baf03b1a868">FFmpeg下载与配置（Visual Studio）</a></p>
<p><a href="https://www.cnblogs.com/leisure_chn/p/10584901.html">FFmpeg编解码处理1-转码全流程简介</a></p>
<p><a href="https://lightfish.cn/2018-12-20-ffmpeg-primer">ffmpeg的C语言编程入门</a></p>
]]></content>
      <categories>
        <category>media</category>
      </categories>
      <tags>
        <tag>live</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>cs231n Assignment 1</title>
    <url>/2017/07/16/2017-07-16-cs231n-assignment1/</url>
    <content><![CDATA[<h2 id="cs231n-assignment-1-笔记"><a href="#cs231n-assignment-1-笔记" class="headerlink" title="cs231n : assignment-1 笔记"></a>cs231n : assignment-1 笔记</h2><h2 id="作业内容："><a href="#作业内容：" class="headerlink" title="作业内容："></a>作业内容：</h2><ul>
<li><strong>knn</strong></li>
<li><strong>svm</strong></li>
<li><strong>softmax</strong></li>
<li><strong>two_layer_net</strong></li>
<li><strong>features</strong></li>
</ul>
<h2 id="作业所使用数据集-："><a href="#作业所使用数据集-：" class="headerlink" title="作业所使用数据集 ："></a>作业所使用数据集 ：</h2><p>本次作业所有算法的数据集均使用<strong>CIFAR-10</strong>，它是一个包含不同物体图片的数据集，图片大小为<strong>32*32*3</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load the raw CIFAR-10 data.</span></span><br><span class="line">cifar10_dir = <span class="string">&#x27;cs231n/datasets/cifar-10-batches-py&#x27;</span></span><br><span class="line">X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir)</span><br></pre></td></tr></table></figure>
<p>数据集中图片示例： </p>
<p><img src="/images/cs231n/CIFAR10.png" alt="image" title="CIFAR10"></p>
<hr>
<h2 id="knn-k-Nearest-Neighbor"><a href="#knn-k-Nearest-Neighbor" class="headerlink" title="knn (k-Nearest Neighbor)"></a>knn (k-Nearest Neighbor)</h2><p><strong>knn</strong> 也就是<strong>k近邻</strong>，它的思想很简单，也就是将训练样本中与测试样本距离最近 <strong>k</strong> 个样本看作标签的预测。当然它也可以用来做聚类，思想方法与分类一样。</p>
<p>距离的计算一般使用 <strong>L1 distance</strong> 或 <strong>L2 distance</strong></p>
<script type="math/tex; mode=display">d_1(I_1, I_2) = \sum_P{|I_1^P - I_2^P |}</script><script type="math/tex; mode=display">d_1(I_1, I_2) = \sqrt{\sum_P{(I_1^P - I_2^P)^2}}</script><p><strong>knn</strong> 分类器训练步骤：</p>
<ol>
<li>训练阶段：只需要将训练数据存储下来即可。</li>
<li>测试阶段：输入测试样本，计算它与所有训练样本之间的两两距离，取出前k个最近的训练样本，它们中最多的标记就作为测试样本的标记。</li>
</ol>
<p><strong>knn</strong> 需要的训练参数只有 <strong>k</strong> ，这类参数也叫做<strong>交叉验证参数</strong>(cross-validated)，也就是我们在对模型进行交叉验证时，需要调整的参数。</p>
<p>从 <strong>knn</strong> 的训练过程可以看出，<strong>knn</strong> 基本没有训练时间的消耗，但是它在进行样本分类时，由于需要计算与所有训练样本间的距离，所有它的样本分类很耗时间（有一些方法可以应用来减小计算量）。</p>
<h3 id="jupter-notebook"><a href="#jupter-notebook" class="headerlink" title="jupter notebook :"></a>jupter notebook :</h3><p>由于原始的数据太多，首先对样本进行下采样，否则算法将会非常慢。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Subsample the data for more efficient code execution in this exercise</span></span><br><span class="line">num_training = <span class="number">5000</span></span><br><span class="line">mask = <span class="built_in">list</span>(<span class="built_in">range</span>(num_training))</span><br><span class="line">X_train = X_train[mask]</span><br><span class="line">y_train = y_train[mask]</span><br><span class="line"></span><br><span class="line">num_test = <span class="number">500</span></span><br><span class="line">mask = <span class="built_in">list</span>(<span class="built_in">range</span>(num_test))</span><br><span class="line">X_test = X_test[mask]</span><br><span class="line">y_test = y_test[mask]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reshape the image data into rows</span></span><br><span class="line">X_train = np.reshape(X_train, (X_train.shape[<span class="number">0</span>], -<span class="number">1</span>))</span><br><span class="line">X_test = np.reshape(X_test, (X_test.shape[<span class="number">0</span>], -<span class="number">1</span>))</span><br><span class="line">print(X_train.shape, X_test.shape)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(5000, 3072)  (500, 3072)</p>
</blockquote>
<h4 id="训练部分代码："><a href="#训练部分代码：" class="headerlink" title="训练部分代码："></a>训练部分代码：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a kNN classifier instance. </span></span><br><span class="line"><span class="comment"># Remember that training a kNN classifier is a noop: </span></span><br><span class="line"><span class="comment"># the Classifier simply remembers the data and does no further processing </span></span><br><span class="line">classifier = KNearestNeighbor()</span><br><span class="line">classifier.train(X_train, y_train)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trian</span>(<span class="params">self, X, y</span>):</span></span><br><span class="line">    self.X_train = X</span><br><span class="line">    self.y_train = y</span><br></pre></td></tr></table></figure>
<p>很明显，训练部分就是将训练数据存下来了而已，没有进行任何操作。</p>
<h4 id="测试部分（使用-L2-distance）："><a href="#测试部分（使用-L2-distance）：" class="headerlink" title="测试部分（使用 L2 distance）："></a>测试部分（使用 L2 distance）：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Let&#x27;s compare how fast the implementations are</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_function</span>(<span class="params">f, *args</span>):</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    tic = time.time()</span><br><span class="line">    f(*args)</span><br><span class="line">    toc = time.time()</span><br><span class="line">    <span class="keyword">return</span> toc - tic</span><br><span class="line"></span><br><span class="line">two_loop_time = time_function(classifier.compute_distances_two_loops, X_test)</span><br><span class="line">print(<span class="string">&#x27;Two loop version took %f seconds&#x27;</span> % two_loop_time)</span><br><span class="line"></span><br><span class="line">one_loop_time = time_function(classifier.compute_distances_one_loop, X_test)</span><br><span class="line">print(<span class="string">&#x27;One loop version took %f seconds&#x27;</span> % one_loop_time)</span><br><span class="line"></span><br><span class="line">no_loop_time = time_function(classifier.compute_distances_no_loops, X_test)</span><br><span class="line">print(<span class="string">&#x27;No loop version took %f seconds&#x27;</span> % no_loop_time)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># two loop</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(num_test):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(num_train):</span><br><span class="line">        dists[i][j] =  np.sqrt(np.<span class="built_in">sum</span>(np.square(self.X_train[j,:] - X[i,:])))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># one loop</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(num_test):</span><br><span class="line">    temp = np.sqrt(np.<span class="built_in">sum</span>(np.square(self.X_train - X[i,:]), axis = <span class="number">1</span>))</span><br><span class="line">    dists[i,:] = temp.T</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># no loop</span></span><br><span class="line"><span class="comment"># 这里需要将 L2 的公式给写开，得到三个和式，分别计算出三部分，</span></span><br><span class="line"><span class="comment"># 就可以计算出距离，也就避免了显式的循环</span></span><br><span class="line">x_square = np.<span class="built_in">sum</span>(np.square(X), axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">xtr_square = np.<span class="built_in">sum</span>(np.square(self.X_train), axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">two_x_y = <span class="number">2</span>*X.dot(self.X_train.T)</span><br><span class="line">dists = np.sqrt((x_square + xtr_square.T) - two_x_y)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Two loop version took 20.160266 seconds<br>One loop version took 34.393572 seconds<br>No loop version took 0.665433 seconds</p>
</blockquote>
<p>测试部分要求实现二重循环、一重循环和无循环三种计算距离的方式，从结果可以看出有无循环在计算时间上的巨大差异。证明在实现算法时，通过矩阵运算来直接计算的重要性。</p>
<h4 id="交叉验证部分-Cross-validation"><a href="#交叉验证部分-Cross-validation" class="headerlink" title="交叉验证部分 (Cross-validation) :"></a>交叉验证部分 (Cross-validation) :</h4><p>由于我们可以选择不同的 <strong>k</strong> 值，所以可以使用交叉验证来测试不同k值下，<strong>knn</strong> 在数据集中的准确率，于是可以选择出最佳的 <strong>k</strong> 值。
对每一个k值，不能只进行一次测试，误差可能导致结果选择不准确，所以使用<strong>5折交叉验证</strong>。将训练数据分成五等份（随机划分），每次使用一份作为验证集，其余的作为训练集，进行五次计算，平均值作为其最终的准确率。</p>
<p><img src="/images/cs231n/five_folds.png" alt="image" title="five folds"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_folds = <span class="number">5</span></span><br><span class="line">k_choices = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> k_choices:</span><br><span class="line">    this_k_cross = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_folds):</span><br><span class="line">        xtf_copy = X_train_folds.copy()</span><br><span class="line">        ytf_copy = y_train_folds.copy()</span><br><span class="line">        <span class="keyword">del</span>(xtf_copy[j])</span><br><span class="line">        <span class="keyword">del</span>(ytf_copy[j])</span><br><span class="line">        xtf_train = np.vstack(xtf_copy)</span><br><span class="line">        ytf_train = np.hstack(ytf_copy)</span><br><span class="line">        xtf_val = X_train_folds[j]</span><br><span class="line">        ytf_val = y_train_folds[j]</span><br><span class="line">        classifier.train(xtf_train, ytf_train)</span><br><span class="line">        cross_idx = num_folds - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cross_idx == j : </span><br><span class="line">            cross_idx = <span class="number">0</span></span><br><span class="line">        y_pred = classifier.predict(xtf_val, k)</span><br><span class="line">        num_correct = np.<span class="built_in">sum</span>(ytf_val == y_pred)</span><br><span class="line">        accuracy = <span class="built_in">float</span>(num_correct) / each_num</span><br><span class="line">        this_k_cross.append(accuracy)</span><br><span class="line">    k_to_accuracies[k] = this_k_cross</span><br></pre></td></tr></table></figure>
<p>画出的图如下：\
<img src="/images/cs231n/Cross-vaildation.png" alt="image" title="Cross-validation on k"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由图中看出最优的k值在10左右，这里选取10</span></span><br><span class="line">best_k = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">classifier = KNearestNeighbor()</span><br><span class="line">classifier.train(X_train, y_train)</span><br><span class="line">y_test_pred = classifier.predict(X_test, k=best_k)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute and display the accuracy</span></span><br><span class="line">num_correct = np.<span class="built_in">sum</span>(y_test_pred == y_test)</span><br><span class="line">accuracy = <span class="built_in">float</span>(num_correct) / num_test</span><br><span class="line">print(<span class="string">&#x27;Got %d / %d correct =&gt; accuracy: %f&#x27;</span> % (num_correct, num_test, accuracy))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Got 141 / 500 correct =&gt; accuracy: 0.282000</p>
</blockquote>
<p>得到在测试集上的准确率为28.2%。</p>
<h3 id="knn小结-："><a href="#knn小结-：" class="headerlink" title="knn小结 ："></a>knn小结 ：</h3><p><strong>knn</strong> 算法十分简单，主要涉及的就是距离的计算，所以它不能应对较为复杂的分类任务。\
最后得到的准确率30%不到，效果很不好，还要注意到本来就能有10%的准确率，因为一共有10个分类，所以随机划分的准确率就是10%。</p>
<hr>
<h2 id="svm-Support-Vector-Machine"><a href="#svm-Support-Vector-Machine" class="headerlink" title="svm (Support Vector Machine)"></a>svm (Support Vector Machine)</h2><p><strong>SVM</strong>，也就是支持向量机，是一个很常用的算法，也是一个很有效的算法，在分类任务中经常会使用到它。\
具体SVM的一些性质暂时先不管，因为它拥有很多的形式，也有很多的推导，加上它还有核函数的trick，所以算法实际上有很多的内容。但在这里就简单的使用即可。</p>
<p><strong>初始定义</strong> :</p>
<script type="math/tex; mode=display">f(x_i,W,b) = Wx_i+b</script><script type="math/tex; mode=display">s_j = f(x_i, W)_j</script><script type="math/tex; mode=display">L_i = \sum_{j \neq y_i}{max(0, s_j - s_{y_i} + \Delta)}</script><p>其中 <em>Li</em> 就是损失函数，首先这里我们判断一个检测样本的划分是看 <em>f</em> 函数得出的值最大的那一维，所以这里损失函数表达的是其它类的得分与正确类的得分之间的差值，并且差距至少为 <strong>Delta</strong>。这个损失函数一般称为 <strong>hinge loss</strong>。</p>
<p><strong>加入Regularization ：</strong></p>
<p>如果只用上面的损失函数来进行计算，它对权值 <em>W</em> 的取值大小是不敏感的，也就是 <em>W</em> 取值很大或很小时都能得到相同的结果，加入<strong>正则化</strong>，可以迫使 <em>W</em> 取较小的值，这里当然也有一定防止过拟合的作用。</p>
<p><strong>正则函数定义：</strong></p>
<script type="math/tex; mode=display">R(W) = \frac 12\sum_k{\sum_l{W_{k,l}^2}}</script><script type="math/tex; mode=display">L = \frac 1N \sum_i{L_i} + \lambda R(W)</script><p>正则化后的损失函数就是上面的 <em>L</em> , 在交叉验证中，<strong>Delta</strong> 的选取其实并不十分重要（一般等于1.0），因为算法总是能够适应过来，更为重要的是正则化强度 <strong>lambda</strong> 的选取。</p>
<h3 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook :"></a>jupyter notebook :</h3><p><strong>数据预处理 ：</strong></p>
<p>这里数据集选取的大小就不像 <strong>knn</strong> 这么保守，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># As a sanity check, print out the shapes of the data</span></span><br><span class="line">print(<span class="string">&#x27;Training data shape: &#x27;</span>, X_train.shape)</span><br><span class="line">print(<span class="string">&#x27;Validation data shape: &#x27;</span>, X_val.shape)</span><br><span class="line">print(<span class="string">&#x27;Test data shape: &#x27;</span>, X_test.shape)</span><br><span class="line">print(<span class="string">&#x27;dev data shape: &#x27;</span>, X_dev.shape)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Training data shape:  (49000, 3072)<br>Validation data shape:  (1000, 3072)<br>Test data shape:  (1000, 3072)<br>dev data shape:  (500, 3072)</p>
</blockquote>
<p>这里将训练数据划分为训练本分，交叉验证部分、测试部分和快速检测部分四个部分，其中训练部分数据远远大于剩下的部分，与通常所说的<strong>70%、20%、10%</strong> 不同，也许在数据较多的时候，只要保证验证集和测试集数据能够正确检验模型即可。其中的快速检测部分用来检验代码的正常性，首先利用它来证明算法的编写没有问题，然后再开始正常的表演。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># first: compute the image mean based on the training data</span></span><br><span class="line">mean_image = np.mean(X_train, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># second: subtract the mean image from train and test data</span></span><br><span class="line">X_train -= mean_image</span><br><span class="line">X_val -= mean_image</span><br><span class="line">X_test -= mean_image</span><br><span class="line">X_dev -= mean_image</span><br><span class="line"></span><br><span class="line"><span class="comment"># third: append the bias dimension of ones (i.e. bias trick) so that our SVM</span></span><br><span class="line"><span class="comment"># only has to worry about optimizing a single weight matrix W.</span></span><br><span class="line">X_train = np.hstack([X_train, np.ones((X_train.shape[<span class="number">0</span>], <span class="number">1</span>))])</span><br><span class="line">X_val = np.hstack([X_val, np.ones((X_val.shape[<span class="number">0</span>], <span class="number">1</span>))])</span><br><span class="line">X_test = np.hstack([X_test, np.ones((X_test.shape[<span class="number">0</span>], <span class="number">1</span>))])</span><br><span class="line">X_dev = np.hstack([X_dev, np.ones((X_dev.shape[<span class="number">0</span>], <span class="number">1</span>))])</span><br><span class="line"></span><br><span class="line">print(X_train.shape, X_val.shape, X_test.shape, X_dev.shape)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(49000, 3073) (1000, 3073) (1000, 3073) (500, 3073)</p>
</blockquote>
<p>这里首先进行了数据的零均值化，第二步使用了加入 <strong>bias</strong> 的 <strong>tirck</strong> ，也就是在训练数据中增加一维数据，值全部为1，这样我们就可以将 <strong>bias</strong> 并入权重里面，于是在计算时就无需再单独去考虑 <strong>bias</strong>。</p>
<p><strong>损失函数与梯度 ：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">svm_loss_naive</span>(<span class="params">W, X, y, reg</span>):</span></span><br><span class="line">    num_classes = W.shape[<span class="number">1</span>]</span><br><span class="line">    num_train = X.shape[<span class="number">0</span>]</span><br><span class="line">    loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(num_train):</span><br><span class="line">        scores = X[i].dot(W)</span><br><span class="line">        correct_class_score = scores[y[i]]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(num_classes):</span><br><span class="line">            <span class="keyword">if</span> j == y[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            margin = scores[j] - correct_class_score + <span class="number">1</span> <span class="comment"># note delta = 1</span></span><br><span class="line">            <span class="keyword">if</span> margin &gt; <span class="number">0</span>:</span><br><span class="line">                loss += margin</span><br><span class="line">                dW[:,j] += X[i]</span><br><span class="line">                dW[:,y[i]] += -X[i]</span><br><span class="line">                </span><br><span class="line">    loss /= num_train</span><br><span class="line">    loss += <span class="number">0.5</span> * reg * np.<span class="built_in">sum</span>(W * W)</span><br><span class="line">    </span><br><span class="line">    dW /= num_train</span><br><span class="line">    dW += reg * W</span><br></pre></td></tr></table></figure>
<p>首先是简单粗暴的循环版本，注意到在 <strong>max</strong> 函数的梯度计算时，对于为0的部分不计算梯度，只有非零的时候才去计算。在非零时，有两组权值加入了运算，<strong>正确分类的权值</strong>和<strong>当前分类的权值</strong>，所以这两组权值都会求得梯度。如下所示：</p>
<script type="math/tex; mode=display">max(0, W_j^Tx_i - W_{y_i}^Tx_i + \Delta) > 0</script><script type="math/tex; mode=display">l = W_j^Tx_i - W_{y_i}^Tx_i + \Delta</script><script type="math/tex; mode=display">\frac {\partial l}{\partial W_j} = x_i</script><script type="math/tex; mode=display">\frac {\partial l}{\partial W_{y_i}} = -x_i</script><p>上面的式子，就对应了上面代码中 <strong>margin &gt; 0</strong> 的部分，调整了 <strong>dW</strong> 的第 <strong>j</strong> 列和 <strong>y{i}</strong> 列。</p>
<p>第二步是尝试去除显式的循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># computer loss</span></span><br><span class="line">m = X.shape[<span class="number">0</span>]</span><br><span class="line">scores = X.dot(W)</span><br><span class="line">right_scores = scores[<span class="built_in">range</span>(m), y].reshape(m, <span class="number">1</span>)</span><br><span class="line">temp_loss = np.maximum(<span class="number">0</span>, scores - right_scores + <span class="number">1</span>)</span><br><span class="line">temp_loss[<span class="built_in">range</span>(m), y] = <span class="number">0</span></span><br><span class="line">loss = np.<span class="built_in">sum</span>(temp_loss)/m + <span class="number">0.5</span> * reg * np.<span class="built_in">sum</span>(W * W)</span><br><span class="line"></span><br><span class="line"><span class="comment"># computer gradient</span></span><br><span class="line">temp_loss[temp_loss &gt; <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">row_sum = np.<span class="built_in">sum</span>(temp_loss, axis = <span class="number">1</span>)</span><br><span class="line">temp_loss[<span class="built_in">range</span>(m), y] = -row_sum</span><br><span class="line">dW += np.dot(X.T, temp_loss)/m + reg * W</span><br></pre></td></tr></table></figure>
<p><strong>loss</strong> 的向量化计算并不复杂，将得分中的正确得分置零，再求和即可。</p>
<p>对 <strong>dW</strong> 的向量化就不这么好想（这里想了很久才做出来），</p>
<ul>
<li>对于 <strong>temp_loss</strong> 中的每一行，就代表了一个样本 <strong>x[i]</strong> 与 <strong>W</strong> 矩阵相乘，再与 <strong>0</strong> 取 <strong>maximum</strong> 所得到的取值。</li>
<li>单看 <strong>temp_loss</strong> 一行，在求取梯度之后，一个 <strong>j列</strong> 不为零的值，导致 <strong>dW</strong> 的 <strong>j</strong> 列需要加上一个 <strong>x[i]</strong> , <strong>y[i]</strong> 列则需要减去 <strong>x[i]</strong> , 所以 <strong>row_sum</strong> 就计算了需要调整的次数。</li>
<li>最后利用矩阵乘法的 <strong>trick</strong> ，注意乘出来的维度要与 <strong>dW</strong> 一致。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># compare time_use </span></span><br><span class="line">tic = time.time()</span><br><span class="line">_, grad_naive = svm_loss_naive(W, X_dev, y_dev, <span class="number">0.000005</span>)</span><br><span class="line">toc = time.time()</span><br><span class="line">print(<span class="string">&#x27;Naive loss and gradient: computed in %fs&#x27;</span> % (toc - tic))</span><br><span class="line"></span><br><span class="line">tic = time.time()</span><br><span class="line">_, grad_vectorized = svm_loss_vectorized(W, X_dev, y_dev, <span class="number">0.000005</span>)</span><br><span class="line">toc = time.time()</span><br><span class="line">print(<span class="string">&#x27;Vectorized loss and gradient: computed in %fs&#x27;</span> % (toc - tic))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Naive loss and gradient: computed in 0.097084s<br>Vectorized loss and gradient: computed in 0.004936s</p>
</blockquote>
<p>很明显，向量化之后效率大大提升。</p>
<p><strong>训练部分（随机梯度下降） ：</strong></p>
<p>通过上面的验证，保证了代码的正确性，开始使用训练集进行训练。</p>
<p>这里所说的是使用<strong>随机梯度下降</strong>（SGD, Stochastic Gradient Descent），但事实上这里其实使用的是 <strong>mini-batch</strong> 每次随机选出部分样本，进行迭代与权重的调整。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">self, X, y, learning_rate=<span class="number">1e-3</span>, reg=<span class="number">1e-5</span>, num_iters=<span class="number">100</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    batch_size=<span class="number">200</span>, verbose=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> xrange(num_iters):</span><br><span class="line">        idxs = np.random.choice(num_train, batch_size, replace = <span class="literal">True</span>)</span><br><span class="line">        X_batch = X[idxs,:]</span><br><span class="line">        y_batch = y[idxs]</span><br><span class="line">        loss, grad = self.loss(X_batch, y_batch, reg)</span><br><span class="line">        loss_history.append(loss)</span><br><span class="line">        self.W -= learning_rate * grad</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">svm = LinearSVM()</span><br><span class="line">loss_hist = svm.train(X_train, y_train, learning_rate=<span class="number">1e-7</span>, reg=<span class="number">2.5e4</span>,</span><br><span class="line">                    num_iters=<span class="number">1500</span>, verbose=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>画出 <strong>loss</strong> 随迭代变化的图：</p>
<p><img src="/images/cs231n/svm_loss.png" alt="image" title="loss"></p>
<p>这里的曲线十分光滑，不知道为什么，感觉在 <strong>mini-batch</strong> 下应该会有起伏才对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Accuracy in training and validation set</span></span><br><span class="line">y_train_pred = svm.predict(X_train)</span><br><span class="line">print(<span class="string">&#x27;training accuracy: %f&#x27;</span> % (np.mean(y_train == y_train_pred), ))</span><br><span class="line">y_val_pred = svm.predict(X_val)</span><br><span class="line">print(<span class="string">&#x27;validation accuracy: %f&#x27;</span> % (np.mean(y_val == y_val_pred), ))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>training accuracy: 0.376714<br>validation accuracy: 0.377000</p>
</blockquote>
<p><strong>交叉验证 ：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">learning_rates = [<span class="number">1e-7</span>, <span class="number">1e-6</span>, <span class="number">5e-5</span>]</span><br><span class="line">regularization_strengths = [<span class="number">1e5</span>, <span class="number">2.5e4</span>, <span class="number">5e4</span>, <span class="number">1e3</span>]</span><br><span class="line"></span><br><span class="line">num_iters = <span class="number">3000</span></span><br><span class="line"><span class="keyword">for</span> lr <span class="keyword">in</span> learning_rates:</span><br><span class="line">    <span class="keyword">for</span> rs <span class="keyword">in</span> regularization_strengths:</span><br><span class="line">        svm = LinearSVM()</span><br><span class="line">        svm.train(X_train, y_train, lr, rs, num_iters)</span><br><span class="line">        y_train_pred = svm.predict(X_train)</span><br><span class="line">        y_val_pred = svm.predict(X_val)</span><br><span class="line">        ytr_acc = np.mean(y_train == y_train_pred)</span><br><span class="line">        yval_acc = np.mean(y_val == y_val_pred)</span><br><span class="line">        results[(lr,rs)] = (ytr_acc, yval_acc)</span><br><span class="line">        <span class="keyword">if</span> yval_acc &gt; best_val : </span><br><span class="line">            best_val = yval_acc</span><br><span class="line">            best_svm = svm</span><br></pre></td></tr></table></figure>
<blockquote>
<p>best validation accuracy achieved during cross-validation: 0.394000</p>
</blockquote>
<p>这部分首先参数设置很诡异啊，学习步长非常小，正则强度又非常之大，计算时在学习步长为 <strong>5e-5</strong> 时会出现数值爆炸的情况。</p>
<p>取得在交叉验证集中的准确率为 <strong>39.4%</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Evaluate the best svm on test set</span></span><br><span class="line">y_test_pred = best_svm.predict(X_test)</span><br><span class="line">test_accuracy = np.mean(y_test == y_test_pred)</span><br><span class="line">print(<span class="string">&#x27;linear SVM on raw pixels final test set accuracy: %f&#x27;</span> % test_accuracy)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>linear SVM on raw pixels final test set accuracy: 0.370000</p>
</blockquote>
<p>取得在测试集中的准确率为 <strong>37.0%</strong>，比 <strong>knn</strong> 只好 <strong>10%</strong> 左右。</p>
<p>将权值可视化，如下图所示：</p>
<p><img src="/images/cs231n/svm_weight.png" alt="image" title="SVM weight"></p>
<p>从图像中可以看出图中大概的形状以及背景颜色与它所要区分的类别很相近。个人认为由于首先零均值化之后，数据中有正有负，然后这里 <strong>SVM</strong> 只涉及到乘法，当权值与样本数据接近时，得到的得分就会比较高，也是因为这里太简单了，所以导致效果并不是很好。</p>
<h4 id="SVM小结-："><a href="#SVM小结-：" class="headerlink" title="SVM小结 ："></a>SVM小结 ：</h4><p>这里使用了多分类的SVM，可以看出效果并不很好，事实上，可以使用 <strong>one-vs-all</strong> 的方式或者使用<strong>核函数</strong>来进行分类，相信会得到更好的结果。</p>
<hr>
<h2 id="softmax-classifier"><a href="#softmax-classifier" class="headerlink" title="softmax classifier"></a>softmax classifier</h2><p><strong>softmax classifier</strong> 也是一种常用的分类器，它其实长得很像 <strong>Logistic Regression</strong> ，下面是它的损失函数的定义：</p>
<script type="math/tex; mode=display">
L_i = -log \left(\frac {e^{f_{y_i}}}{\sum_j{e^{f_j}}}\right)</script><script type="math/tex; mode=display">f(x_i;W) = Wx_i</script><p>其中 <strong>W</strong> 为权值，<strong>xi</strong> 为第 <strong>i</strong> 个样本。可以把它写开成为等价形式，</p>
<script type="math/tex; mode=display">L_i = -f_{y_i} + log \sum_j{e^{f_j}}</script><p>这样的损失函数称为<strong>交叉熵损失</strong>（cross-entropy loss），其中，</p>
<script type="math/tex; mode=display">f_j(z) = \frac {e^{z_j}}{\sum_k{e^{z_k}}}</script><p>就是 <strong>softmax function</strong>。从直观来说，<strong>softmax function</strong> 把得分转化为了概率，然后用类似熵的式子来使得正确分类的概率最大化（因为要最小化损失函数）。</p>
<p>在实际计算中，如果不对分数进行处理就直接带入损失函数，由于其中涉及到 <strong>e</strong> 的幂次，可能导致计算上数值过大造成问题，所以需要对其做一些处理，如下，</p>
<script type="math/tex; mode=display">
\frac {e^{f_{y_i}}}{\sum_j{e^{f_j}}} 
\rightarrow
\frac {Ce^{f_{y_i}}}{C\sum_j{e^{f_j}}} =
\frac {e^{f_{y_i} + logC}}{\sum_j{e^{f_j + logC}}}</script><p>这样就相当于要所有得分共同加上一个固定值 <strong>logC</strong> ，并且这对计算的结果不会产生影响。于是，通常情况下我们取，</p>
<script type="math/tex; mode=display">
logC = -\max_jf_j</script><p>这样就不会带来计算上<strong>溢出</strong>的问题，同时也不会影响到计算结果，所以也不用花费额外的精力去关注它。</p>
<p>加入正则化（与 <strong>SVM</strong> 一样），写出最终的损失函数如下，</p>
<script type="math/tex; mode=display">
L = \sum_i^m -log\left(\frac {e^{f_{y_i} + logC}}{\sum_j{e^{f_j + logC}}}\right) + \lambda R(W)</script><h3 id="jupyter-notebook-1"><a href="#jupyter-notebook-1" class="headerlink" title="jupyter notebook :"></a>jupyter notebook :</h3><p><strong>数据预处理 ：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load the raw CIFAR-10 data</span></span><br><span class="line">X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preprocessing: reshape the image data into rows</span></span><br><span class="line">X_train = np.reshape(X_train, (X_train.shape[<span class="number">0</span>], -<span class="number">1</span>))</span><br><span class="line">X_val = np.reshape(X_val, (X_val.shape[<span class="number">0</span>], -<span class="number">1</span>))</span><br><span class="line">X_test = np.reshape(X_test, (X_test.shape[<span class="number">0</span>], -<span class="number">1</span>))</span><br><span class="line">X_dev = np.reshape(X_dev, (X_dev.shape[<span class="number">0</span>], -<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Normalize the data: subtract the mean image</span></span><br><span class="line">mean_image = np.mean(X_train, axis = <span class="number">0</span>)</span><br><span class="line">X_train -= mean_image</span><br><span class="line">X_val -= mean_image</span><br><span class="line">X_test -= mean_image</span><br><span class="line">X_dev -= mean_image</span><br><span class="line"></span><br><span class="line"><span class="comment"># add bias dimension and transform into columns</span></span><br><span class="line">X_train = np.hstack([X_train, np.ones((X_train.shape[<span class="number">0</span>], <span class="number">1</span>))])</span><br><span class="line">X_val = np.hstack([X_val, np.ones((X_val.shape[<span class="number">0</span>], <span class="number">1</span>))])</span><br><span class="line">X_test = np.hstack([X_test, np.ones((X_test.shape[<span class="number">0</span>], <span class="number">1</span>))])</span><br><span class="line">X_dev = np.hstack([X_dev, np.ones((X_dev.shape[<span class="number">0</span>], <span class="number">1</span>))])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Train data shape: &#x27;</span>, X_train.shape)</span><br><span class="line">print(<span class="string">&#x27;Train labels shape: &#x27;</span>, y_train.shape)</span><br><span class="line">print(<span class="string">&#x27;Validation data shape: &#x27;</span>, X_val.shape)</span><br><span class="line">print(<span class="string">&#x27;Validation labels shape: &#x27;</span>, y_val.shape)</span><br><span class="line">print(<span class="string">&#x27;Test data shape: &#x27;</span>, X_test.shape)</span><br><span class="line">print(<span class="string">&#x27;Test labels shape: &#x27;</span>, y_test.shape)</span><br><span class="line">print(<span class="string">&#x27;dev data shape: &#x27;</span>, X_dev.shape)</span><br><span class="line">print(<span class="string">&#x27;dev labels shape: &#x27;</span>, y_dev.shape)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Train data shape:  (49000, 3073)<br>Train labels shape:  (49000,)<br>Validation data shape:  (1000, 3073)<br>Validation labels shape:  (1000,)<br>Test data shape:  (1000, 3073)<br>Test labels shape:  (1000,)<br>dev data shape:  (500, 3073)<br>dev labels shape:  (500,) </p>
</blockquote>
<p>这里使用的数据同样是 <strong>CIFAR10</strong> ，</p>
<ul>
<li>代码首先读入数据，并将每一幅图片都转化为行向量。</li>
<li>将数据划分为四部分，和 <strong>SVM</strong> 时操作一样。</li>
<li>零均值化。</li>
<li>使用 <strong>bias trick</strong>，加入一列 <strong>1</strong> 向量。</li>
</ul>
<p><strong>损失函数和梯度 ：</strong></p>
<p>首先实现循环版本的代码，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = X.shape[<span class="number">0</span>]</span><br><span class="line">c = W.shape[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(m) :</span><br><span class="line">    score = X[i].dot(W)</span><br><span class="line">    score_mean = score - np.<span class="built_in">max</span>(score)</span><br><span class="line">    score_exp = np.exp(score_mean)</span><br><span class="line">    sum_se = np.<span class="built_in">sum</span>(score_exp)</span><br><span class="line">    loss += (np.log(sum_se) - score_mean[y[i]])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(c):</span><br><span class="line">        dW[:,j] += (score_exp[j] / sum_se) * X[i] </span><br><span class="line">        <span class="keyword">if</span> j == y[i]:</span><br><span class="line">            dW[:,j] -= X[i]</span><br><span class="line">loss /= m</span><br><span class="line">loss += <span class="number">0.5</span> * reg * np.<span class="built_in">sum</span>(W * W)</span><br><span class="line">dW /= m                                                     </span><br><span class="line">dW += reg * W</span><br></pre></td></tr></table></figure>
<p>循环中，将计算分为了每个样本分别计算，利用了损失函数的变形来编写，其中，</p>
<script type="math/tex; mode=display">
L_i = -f_{y_i} + log\sum_j{e^{f_j}}</script><script type="math/tex; mode=display">
\frac {\partial L_i}{\partial W_j} =
\frac {\partial L_i}{\partial f_j}
\frac {\partial f_j}{\partial W_j} = 
\begin{cases}
    \frac {e^{f_j}}{\sum_j{e^{f_j}}} x_i && ,j \neq y_i \\
    \frac {e^{f_j}}{\sum_j{e^{f_j}}} x_i - x_i && ,j = y_i
\end{cases}</script><p>循环中就体现了上面的式子，在最后再加入正则化即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Generate a random softmax weight matrix and use it to compute the loss.</span></span><br><span class="line">W = np.random.randn(<span class="number">3073</span>, <span class="number">10</span>) * <span class="number">0.0001</span></span><br><span class="line">loss, grad = softmax_loss_naive(W, X_dev, y_dev, <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># As a rough sanity check, our loss should be something close to -log(0.1).</span></span><br><span class="line">print(<span class="string">&#x27;loss: %f&#x27;</span> % loss)</span><br><span class="line">print(<span class="string">&#x27;sanity check: %f&#x27;</span> % (-np.log(<span class="number">0.1</span>)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>loss: 2.367492<br>sanity check: 2.302585</p>
</blockquote>
<p>上面这一段使用了随机的初始权值来对 <strong>loss</strong> 进行了计算，然后与 <strong>-log(0.1)</strong> 进行了比较，在期望下两个值之间应该十分接近，因为在随机情况下，每一个样本在 <strong>softmax</strong> 之后它得每一类划分的概率应该都是 <strong>0.1</strong>，在取熵之后就是接近 <strong>-log(0.1)</strong>。</p>
<p><strong>梯度检测 ：</strong></p>
<p>这部分留到最后在统一说，通常在算法实现时，我们要先检查自己的梯度计算是否有问题，以保证在正常训练时不会出现问题。</p>
<p><strong>向量化 ：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># loss</span></span><br><span class="line">m = X.shape[<span class="number">0</span>]</span><br><span class="line">scores = X.dot(W)</span><br><span class="line">scores_mean = scores - np.<span class="built_in">max</span>(scores, axis = <span class="number">1</span>).reshape(m, <span class="number">1</span>)</span><br><span class="line">scores_exp = np.exp(scores_mean)</span><br><span class="line">sum_row = np.<span class="built_in">sum</span>(scores_exp, <span class="number">1</span>)</span><br><span class="line">loss += -np.<span class="built_in">sum</span>(np.log(scores_exp[<span class="built_in">range</span>(m), y]/sum_row))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gradient</span></span><br><span class="line">coef = scores_exp / sum_row.reshape(m,<span class="number">1</span>)</span><br><span class="line">coef[np.arange(m), y] -= <span class="number">1</span></span><br><span class="line">dW = X.T.dot(coef)</span><br><span class="line"></span><br><span class="line"><span class="comment"># regularization</span></span><br><span class="line">loss /= m</span><br><span class="line">loss += <span class="number">0.5</span> * reg * np.<span class="built_in">sum</span>(W * W)</span><br><span class="line">dW /= m</span><br><span class="line">dW += reg * W</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在经历过 <strong>SVM</strong> 的向量化之后，这里的向量化就和它有一定类似，只不过 <strong>SVM</strong> 时，系数为 <strong>1</strong> ，在这里系数是概率，外加正确值减去一个 <strong>-1</strong>，然后同样使用矩阵乘法所得结果需要与 <strong>dW</strong> 的规模一致的 <strong>trick</strong>，得到代码的机构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tic = time.time()</span><br><span class="line">loss_naive, grad_naive = softmax_loss_naive(W, X_dev, y_dev, <span class="number">0.000005</span>)</span><br><span class="line">toc = time.time()</span><br><span class="line">print(<span class="string">&#x27;naive loss: %e computed in %fs&#x27;</span> % (loss_naive, toc - tic))</span><br><span class="line"></span><br><span class="line">tic = time.time()</span><br><span class="line">loss_vectorized, grad_vectorized = softmax_loss_vectorized(W, X_dev, y_dev, <span class="number">0.000005</span>)</span><br><span class="line">toc = time.time()</span><br><span class="line">print(<span class="string">&#x27;vectorized loss: %e computed in %fs&#x27;</span> % (loss_vectorized, toc - tic))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>naive loss: 2.349745e+00 computed in 0.113950s<br>vectorized loss: 2.349745e+00 computed in 0.011255s</p>
</blockquote>
<p>两次计算的结果一致，向量化的速度是非向量化的 <strong>10</strong> 倍。</p>
<p><strong>交叉验证 ：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">learning_rates = [<span class="number">1e-7</span>, <span class="number">5e-7</span>]</span><br><span class="line">regularization_strengths = [<span class="number">2.5e4</span>, <span class="number">5e4</span>]</span><br><span class="line"></span><br><span class="line">it_num = <span class="number">1500</span></span><br><span class="line"><span class="keyword">for</span> lr <span class="keyword">in</span> learning_rates :</span><br><span class="line">    <span class="keyword">for</span> rs <span class="keyword">in</span> regularization_strengths :</span><br><span class="line">        softmax = Softmax()</span><br><span class="line">        softmax.train(X_train, y_train, lr, rs, it_num)</span><br><span class="line">        y_train_pred = softmax.predict(X_train)</span><br><span class="line">        y_val_pred = softmax.predict(X_val)</span><br><span class="line">        ytr_acc = np.mean(y_train == y_train_pred)</span><br><span class="line">        yval_acc = np.mean(y_val == y_val_pred)</span><br><span class="line">        results[(lr,rs)] = (ytr_acc, yval_acc)</span><br><span class="line">        <span class="keyword">if</span> yval_acc &gt; best_val : </span><br><span class="line">            best_val = yval_acc</span><br><span class="line">            best_softmax = </span><br><span class="line">            </span><br><span class="line">print(<span class="string">&#x27;best validation accuracy achieved during cross-validation: %f&#x27;</span> % best_val)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>best validation accuracy achieved during cross-validation: 0.372000</p>
</blockquote>
<p>得到交叉验证集中的最高准确率为 <strong>37.2%</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Evaluate the best softmax on test set</span></span><br><span class="line">y_test_pred = best_softmax.predict(X_test)</span><br><span class="line">test_accuracy = np.mean(y_test == y_test_pred)</span><br><span class="line">print(<span class="string">&#x27;softmax on raw pixels final test set accuracy: %f&#x27;</span> % (test_accuracy, ))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>softmax on raw pixels final test set accuracy: 0.369000</p>
</blockquote>
<p>得到在测试集中的准确率为 <strong>36.9%</strong>。</p>
<p>将权值可视化之后得到图如下，</p>
<p><img src="/images/cs231n/softmax_weight.png" alt="image" title="softmax weight"></p>
<p>得到的图像与之前的 <strong>SVM</strong> 几乎是一样的，因为在实际上它们所观察的，都是在 <strong>W*xi</strong> 中的最大取值，它们之间的学习步长以及正则化强度的取值大小几乎也是一样的，所以最终得到的准确率几乎也一样。</p>
<p><strong>softmax小结 :</strong></p>
<p>从 <strong>softmax</strong> 的函数形式就可以看出，它适合的是多分类的场景，但它在 <strong>CIFAR10</strong> 上的表现并不好，说明在这种过于复杂的任务中，它很难轻易的表现的很好，可能还需要对数据进行一些特征提取的工作，来提升它的性能。</p>
<hr>
<h2 id="Two-Layer-Neural-Network"><a href="#Two-Layer-Neural-Network" class="headerlink" title="Two_Layer_Neural_Network"></a>Two_Layer_Neural_Network</h2><p>这里要求实现一个简单的二层神经网络（也可以称作一个隐藏层的神经网络），神经网络的东西单独写，先写题。</p>
<p><img src="/images/cs231n/two_layer_net.png" alt="image" title="two_layer_net"></p>
<p>如图所示就类似于题目要求的神经网络，输入层 + 隐藏层 + 输出层，完成多分类任务。更为具体的，题目要求网络结构为，</p>
<ul>
<li><strong>input - fully connected layer - ReLU - fully connected layer - softmax</strong>。</li>
</ul>
<h3 id="jupyter-notebook-2"><a href="#jupyter-notebook-2" class="headerlink" title="jupyter notebook :"></a>jupyter notebook :</h3><p><strong>前向传播（Forward Pass） ：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Forward Pass</span></span><br><span class="line">h = np.maximum(<span class="number">0</span>, X.dot(W1) + b1)</span><br><span class="line">scores = h.dot(W2) + b2</span><br></pre></td></tr></table></figure>
<p>前向传播十分简单，两个矩阵乘法就能搞定。</p>
<p><strong>损失函数(loss function) :</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># loss</span></span><br><span class="line">scores_mean = scores - np.<span class="built_in">max</span>(scores, <span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">scores_exp = np.exp(scores_mean)</span><br><span class="line">sc_sum = np.<span class="built_in">sum</span>(scores_exp, <span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">y_pred = scores_exp / sc_sum</span><br><span class="line">loss = -np.<span class="built_in">sum</span>(np.log(y_pred[<span class="built_in">range</span>(N), y]))</span><br><span class="line">loss /= N</span><br><span class="line">loss += reg * (np.<span class="built_in">sum</span>(W1 * W1) + np.<span class="built_in">sum</span>(W2 * W2)) </span><br></pre></td></tr></table></figure>
<p>注意这里的损失函数是 <strong>softmax</strong> 。</p>
<p><strong>反向传播(Backward Pass) :</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Backward Pass</span></span><br><span class="line">dscores = y_pred.copy()</span><br><span class="line">dscores[<span class="built_in">range</span>(N), y] -= <span class="number">1</span></span><br><span class="line">dscores /= N</span><br><span class="line">grads[<span class="string">&#x27;W2&#x27;</span>] = h.T.dot(dscores) + <span class="number">2</span> * reg * W2</span><br><span class="line">grads[<span class="string">&#x27;b2&#x27;</span>] = np.<span class="built_in">sum</span>(dscores, axis = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">h_grad = dscores.dot(W2.T)</span><br><span class="line">h_grad[h &lt;= <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">grads[<span class="string">&#x27;W1&#x27;</span>] = X.T.dot(h_grad) + <span class="number">2</span> * reg * W1</span><br><span class="line">grads[<span class="string">&#x27;b1&#x27;</span>] = np.<span class="built_in">sum</span>(h_grad, axis = <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里写了很多遍也不对，对照别人的代码才知道这里的误差起始直接用的就是 <strong>y_pred</strong> ，也就是说正确类的误差为 <strong>1 - fj</strong> ，错误类的误差为 <strong>fj - 0</strong>，也就是说我们期望正确类的概率为 <strong>1</strong> ，其余为 <strong>0</strong>， 不用先对 <strong>softmax</strong> 求导再传播。另外这里的误差还要除以样本数 <strong>N</strong>，<strong>没想明白？？？</strong>。</p>
<p>另外反向传播需要用到前向传播的中间值，这里就是 <strong>h, y_pred</strong> 。</p>
<p>反向传播在书写代码时，利用矩阵乘法的 <strong>trick</strong> 可以迅速梳理出写法。</p>
<ul>
<li>第一次传播就直接回传</li>
<li>第二次传播是 <strong>hinge function</strong> ，它是个不连续的函数，我们处理它的反向传播时，将前向传播时为 <strong>0</strong> 的值，不再反向传播即可。</li>
<li>加上正则化</li>
</ul>
<p><strong>训练部分 ：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mini-batch</span></span><br><span class="line">idx = np.random.choice(num_train, batch_size, replace=<span class="literal">True</span>)</span><br><span class="line">X_batch = X[idx]</span><br><span class="line">y_batch = y[idx]</span><br><span class="line"></span><br><span class="line"><span class="comment"># loss, grads</span></span><br><span class="line">loss, grads = self.loss(X_batch, y=y_batch, reg=reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># weight update</span></span><br><span class="line">self.params[<span class="string">&#x27;W1&#x27;</span>] -= learning_rate * grads[<span class="string">&#x27;W1&#x27;</span>]</span><br><span class="line">self.params[<span class="string">&#x27;b1&#x27;</span>] -= learning_rate * grads[<span class="string">&#x27;b1&#x27;</span>]</span><br><span class="line">self.params[<span class="string">&#x27;W2&#x27;</span>] -= learning_rate * grads[<span class="string">&#x27;W2&#x27;</span>]</span><br><span class="line">self.params[<span class="string">&#x27;b2&#x27;</span>] -= learning_rate * grads[<span class="string">&#x27;b2&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>使用mini-batch的方法来训练，权值更新十分简单，训练过程如下图，</p>
<p><img src="/images/cs231n/net_loss.png" alt="image" title="network train"></p>
<p>图像中 <strong>loss</strong> 的变化是一直在跳变的，但是它总体的趋势是在下降，这就是在训练中使用 <strong>batch model</strong> 以外的训练方法中会看到的场景，因为每次我们沿梯度下降时，寻找的是本次使用样本的梯度下降方向，而不是全局的下降方向。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_size = <span class="number">32</span> * <span class="number">32</span> * <span class="number">3</span></span><br><span class="line">hidden_size = <span class="number">50</span></span><br><span class="line">num_classes = <span class="number">10</span></span><br><span class="line">net = TwoLayerNet(input_size, hidden_size, num_classes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Train the network</span></span><br><span class="line">stats = net.train(X_train, y_train, X_val, y_val,</span><br><span class="line">            num_iters=<span class="number">1000</span>, batch_size=<span class="number">200</span>,</span><br><span class="line">            learning_rate=<span class="number">1e-4</span>, learning_rate_decay=<span class="number">0.95</span>,</span><br><span class="line">            reg=<span class="number">0.25</span>, verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Predict on the validation set</span></span><br><span class="line">val_acc = (net.predict(X_val) == y_val).mean()</span><br><span class="line">print(<span class="string">&#x27;Validation accuracy: &#x27;</span>, val_acc)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Validation accuracy:  0.287</p>
</blockquote>
<p>在上面定义了一个隐藏层为 <strong>50</strong> 个神经元的一个神经网络，这里只迭代 <strong>1000</strong> 次，得到一个粗略的 <strong>Validation accuracy</strong> 为 <strong>28.7%</strong> ，感觉很差。所以下面要进行交叉验证来找到一个好的参数，神经网络时常干的就是这么一个调参的工作。</p>
<p>先看当前训练得到权值的一个长相，</p>
<p><img src="/images/cs231n/nerual_weight.png" alt="image" title="nerual wright"></p>
<p>只有车的长相比较明显。</p>
<p><strong>交叉验证 ：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cross-validation</span></span><br><span class="line">hidden_size = [ <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span> ] </span><br><span class="line">learning_rate = [ <span class="number">1e-3</span>, <span class="number">1e-4</span>]</span><br><span class="line">reg = [ <span class="number">0.15</span>, <span class="number">0.25</span>, <span class="number">0.45</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> hs <span class="keyword">in</span> hidden_size:</span><br><span class="line">    <span class="keyword">for</span> lr <span class="keyword">in</span> learning_rate:</span><br><span class="line">        <span class="keyword">for</span> re <span class="keyword">in</span> reg:</span><br><span class="line">            net = TwoLayerNet(input_size, hs, num_classes)</span><br><span class="line">            <span class="comment"># Train the network</span></span><br><span class="line">            stats = net.train(X_train, y_train, X_val, y_val,</span><br><span class="line">                        num_iters=<span class="number">4000</span>, batch_size=<span class="number">400</span>,</span><br><span class="line">                        learning_rate=lr, learning_rate_decay=<span class="number">0.99</span>,</span><br><span class="line">                        reg=re, verbose=<span class="literal">True</span>)</span><br><span class="line">            <span class="comment"># Predict on the validation set</span></span><br><span class="line">            val_acc = (net.predict(X_val) == y_val).mean()</span><br><span class="line">            print(<span class="string">&#x27;Validation accuracy: &#x27;</span>, val_acc, <span class="string">&#x27; hs = &#x27;</span>,</span><br><span class="line">                        hs, <span class="string">&#x27; lr = &#x27;</span>, lr, <span class="string">&#x27; re = &#x27;</span>, re)</span><br><span class="line">            <span class="keyword">if</span> val_acc &gt; best_val:</span><br><span class="line">                best_val = val_acc</span><br><span class="line">                best_net = net</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Validation accuracy:  0.528  hs =  500  lr =  0.0005  re =  0.2</p>
</blockquote>
<p>这里的训练过程非常慢，事实上我看效果不好的参数就主动停止了它。已经可以预见在网络更为复杂的时候，光用 <strong>cpu</strong> 来跑神经网络的困难所在了。</p>
<p>这里得到了 <strong>52.8%</strong> 的验证集准确率。</p>
<p>将这个复杂的网络权值进行可视化，</p>
<p><img src="/images/cs231n/best_nerual_weight.png" alt="image" title="best nerual weight"></p>
<p>图中还是可以依稀辨识出形状的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_acc = (best_net.predict(X_test) == y_test).mean()</span><br><span class="line">print(<span class="string">&#x27;Test accuracy: &#x27;</span>, test_acc)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Test accuracy:  0.546</p>
</blockquote>
<p>得到最后在测试集上的准确率为 <strong>54.6%</strong> ，实际上我在测试时跑出的最高准确率为 <strong>56%</strong> ，再调整了一下参数，效果反而差了一点(；′⌒`) 。</p>
<p><strong>two_layer_net 小结 ：</strong></p>
<p>对于神经网络，还有很多神奇的操作现在还不明白，但是很明显它在这种复杂问题上的分类能力是要强于其它的分类方法的，起码在这里比 <strong>SVM、Softmax</strong> 强 <strong>20%</strong> 。</p>
<hr>
<h2 id="features"><a href="#features" class="headerlink" title="features :"></a>features :</h2><p>这一部分使用了原始图像的<strong>方向梯度直方图(HOG,Histogram of Oriented Gradient)</strong>的特征来进行训练，具体它是怎么完成的现在并不关心，总之它提取了特征，不再使用图像的原始特征，然后能够提高算法的准确率。</p>
<p><strong>特征与数据预处理 ：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_color_bins = <span class="number">10</span> <span class="comment"># Number of bins in the color histogram</span></span><br><span class="line">feature_fns = [hog_feature, <span class="keyword">lambda</span> img: color_histogram_hsv(img, nbin=num_color_bins)]</span><br><span class="line">X_train_feats = extract_features(X_train, feature_fns, verbose=<span class="literal">True</span>)</span><br><span class="line">X_val_feats = extract_features(X_val, feature_fns)</span><br><span class="line">X_test_feats = extract_features(X_test, feature_fns)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preprocessing: Subtract the mean feature</span></span><br><span class="line">mean_feat = np.mean(X_train_feats, axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">X_train_feats -= mean_feat</span><br><span class="line">X_val_feats -= mean_feat</span><br><span class="line">X_test_feats -= mean_feat</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preprocessing: Divide by standard deviation. This ensures that each feature</span></span><br><span class="line"><span class="comment"># has roughly the same scale.</span></span><br><span class="line">std_feat = np.std(X_train_feats, axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">X_train_feats /= std_feat</span><br><span class="line">X_val_feats /= std_feat</span><br><span class="line">X_test_feats /= std_feat</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preprocessing: Add a bias dimension</span></span><br><span class="line">X_train_feats = np.hstack([X_train_feats, np.ones((X_train_feats.shape[<span class="number">0</span>], <span class="number">1</span>))])</span><br><span class="line">X_val_feats = np.hstack([X_val_feats, np.ones((X_val_feats.shape[<span class="number">0</span>], <span class="number">1</span>))])</span><br><span class="line">X_test_feats = np.hstack([X_test_feats, np.ones((X_test_feats.shape[<span class="number">0</span>], <span class="number">1</span>))])</span><br></pre></td></tr></table></figure>
<p>上面的过程完成了以下操作：</p>
<ul>
<li>特征提取</li>
<li>零均值化</li>
<li>单位化方差</li>
<li>加入偏置</li>
</ul>
<p>此时数据的维度发生了很大的变化，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(X_train_feats.shape)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(49000, 155)</p>
</blockquote>
<p>数据直接由 <strong>3072</strong> 维，变到了 <strong>154</strong> 维（不考虑偏置维），算法复杂度也会显著降低。</p>
<p><strong>训练SVM ：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cross-validation</span></span><br><span class="line">learning_rates = [<span class="number">1e-9</span>, <span class="number">1e-8</span>, <span class="number">1e-7</span>]</span><br><span class="line">regularization_strengths = [<span class="number">5e4</span>, <span class="number">5e5</span>, <span class="number">5e6</span>]</span><br><span class="line"></span><br><span class="line">num_iters = <span class="number">3000</span></span><br><span class="line"><span class="keyword">for</span> lr <span class="keyword">in</span> learning_rates:</span><br><span class="line">    <span class="keyword">for</span> rs <span class="keyword">in</span> regularization_strengths:</span><br><span class="line">        svm = LinearSVM()</span><br><span class="line">        svm.train(X_train_feats, y_train, lr, rs, num_iters)</span><br><span class="line">        y_train_pred = svm.predict(X_train_feats)</span><br><span class="line">        y_val_pred = svm.predict(X_val_feats)</span><br><span class="line">        ytr_acc = np.mean(y_train == y_train_pred)</span><br><span class="line">        yval_acc = np.mean(y_val == y_val_pred)</span><br><span class="line">        results[(lr,rs)] = (ytr_acc, yval_acc)</span><br><span class="line">        <span class="keyword">if</span> yval_acc &gt; best_val : </span><br><span class="line">            best_val = yval_acc</span><br><span class="line">            best_svm = svm</span><br><span class="line">            </span><br><span class="line">print(<span class="string">&#x27;best validation accuracy achieved during cross-validation: %f&#x27;</span> % best_val)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>best validation accuracy achieved during cross-validation: 0.425000</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Evaluate your trained SVM on the test set</span></span><br><span class="line">y_test_pred = best_svm.predict(X_test_feats)</span><br><span class="line">test_accuracy = np.mean(y_test == y_test_pred)</span><br><span class="line">print(test_accuracy)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>0.424</p>
</blockquote>
<p>得到测试集准确率为 <strong>42.4%</strong>，比之前提升了 <strong>5%</strong> 左右。</p>
<p>来观察一下它的误分类的长相，</p>
<p><img src="/images/cs231n/svm_mis_classification.png" alt="image" title="svm_mis_classification"></p>
<p>恩，没什么规律可言O__O “…</p>
<p><strong>训练神经网络 ：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cross-validation</span></span><br><span class="line">hidden_dim = <span class="number">400</span></span><br><span class="line"></span><br><span class="line">hidden_size = [ hidden_dim, ] </span><br><span class="line">learning_rate = [<span class="number">0.2</span>, <span class="number">0.25</span>, <span class="number">0.30</span> ]</span><br><span class="line">reg = [ <span class="number">0.00005</span>, <span class="number">0.00001</span>, <span class="number">0.000005</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> hs <span class="keyword">in</span> hidden_size:</span><br><span class="line">    <span class="keyword">for</span> lr <span class="keyword">in</span> learning_rate:</span><br><span class="line">        <span class="keyword">for</span> re <span class="keyword">in</span> reg:</span><br><span class="line">            net = TwoLayerNet(input_dim, hs, num_classes)</span><br><span class="line">            <span class="comment"># Train the network</span></span><br><span class="line">            stats = net.train(X_train_feats, y_train, X_val_feats, y_val,</span><br><span class="line">                        num_iters=<span class="number">4000</span>, batch_size=<span class="number">400</span>,</span><br><span class="line">                        learning_rate=lr, learning_rate_decay=<span class="number">0.98</span>,</span><br><span class="line">                        reg=re, verbose=<span class="literal">False</span>)</span><br><span class="line">            <span class="comment"># Predict on the validation set</span></span><br><span class="line">            val_acc = (net.predict(X_val_feats) == y_val).mean()</span><br><span class="line">            print(<span class="string">&#x27;Validation accuracy: &#x27;</span>, val_acc, <span class="string">&#x27; hs = &#x27;</span>,</span><br><span class="line">                        hs, <span class="string">&#x27; lr = &#x27;</span>, lr, <span class="string">&#x27; re = &#x27;</span>, re)</span><br><span class="line">            <span class="keyword">if</span> val_acc &gt; best_val:</span><br><span class="line">                best_val = val_acc</span><br><span class="line">                best_net = net</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Validation accuracy:  0.63  hs =  400  lr =  0.2  re =  5e-05<br>Validation accuracy:  0.587  hs =  400  lr =  0.2  re =  1e-05<br>Validation accuracy:  0.58  hs =  400  lr =  0.2  re =  5e-06<br>Validation accuracy:  0.583  hs =  400  lr =  0.25  re =  5e-05<br>Validation accuracy:  0.582  hs =  400  lr =  0.25  re =  1e-05<br>Validation accuracy:  0.587  hs =  400  lr =  0.25  re =  5e-06<br>Validation accuracy:  0.593  hs =  400  lr =  0.3  re =  5e-05<br>Validation accuracy:  0.576  hs =  400  lr =  0.3  re =  1e-05<br>Validation accuracy:  0.588  hs =  400  lr =  0.3  re =  5e-06</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_acc = (net.predict(X_test_feats) == y_test).mean()</span><br><span class="line">print(test_acc)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>0.592</p>
</blockquote>
<p>这里得到测试集准确率为 <strong>59.2%</strong> ，比之前提高了 <strong>4%</strong> ，虽然提升不多，但是模型复杂度也降低了，所以训练速度比之前快了很多。</p>
<p><strong>特征提取小结：</strong></p>
<p>在没有广泛应用神经网络的时期，特征提取和数据的预处理是机器学习中非常重要的一部分，甚至是主要的一部分，神经网络的广泛应用，其实就将特征提取这个部分给简单化了，模型只带特征提取的能力。</p>
<p>具体的很多特征提取的方法目前还不知道，随着课程推进再慢慢学习。</p>
<p><strong>第一部分的笔记就先到这里，这算是我的第一次笔记！！！</strong></p>
]]></content>
      <categories>
        <category>cs231n</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>mechine learning</tag>
        <tag>homework</tag>
      </tags>
  </entry>
  <entry>
    <title>匈牙利算法和KM算法</title>
    <url>/2018/05/05/2018-05-05-KM/</url>
    <content><![CDATA[<hr>
<p>本来是在写最小费用最大流的，然后找到<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1533">Going Home</a>这道题。这道题的确是可以使用费用流来解，但是复杂度有点儿高，
然后想了一下，其实可以用匹配来解决。那么既然都用匹配了，这里就将算法进行一下记录，毕竟匹配算法还是比较常用的。</p>
<p>在这里，主要还是针对偶图来说，下面一步一步记录。</p>
<hr>
<h1 id="偶图"><a href="#偶图" class="headerlink" title="偶图"></a>偶图</h1><p><strong>偶图</strong>也称为二部图，是指具有二分类（X，Y）的图，它的点集可以分解为两个（非空）子集X和Y，使得每条边的一个端点在X中，
另一个端点在Y中。</p>
<p><strong>完全偶图</strong>就是X中每一个点与Y中每一个点都有连边。</p>
<p>下图就是一个偶图，但不是完全偶图：</p>
<p><img src="/images/algorithm/偶图.png" alt="偶图" title="偶图"></p>
<hr>
<h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><p>给定图G=(V,E)。设M是E的一个不包含环的子集，它的任意两条边在G中<strong>均不相邻</strong>，则称M为G的匹配。
M中一条边的两个端点称为在M下是配对的，同时这两个点也是<strong>饱和</strong>的。若在M下，G的每一个顶点都是饱和的，
则称M为G的<strong>完美匹配</strong>。若G没有另外的匹配M’，使得|M|&lt;|M’|，则称为G的<strong>最大匹配</strong>。<strong>完美匹配</strong>也是<strong>最大匹配</strong>，
反之不成立。</p>
<p>对于<strong>偶图</strong>来说，一条边连接了X中的一个点和Y中的一个点，通常在这里就是为了找到最大匹配或者是完美匹配，
使得X中（或Y中）的点能够都达到饱和。</p>
<p><strong>偶图</strong>都有最大匹配，但是只有在X的点数等于Y的点数的情况下，才可能有完美匹配。X与Y点数相等的<strong>完全偶图</strong>显然一定有完美匹配。</p>
<p>对于一个X与Y点数相等的<strong>完全偶图</strong>，如果每一条边都有一个权重，那么在其中寻找一个具有最大权和的完美匹配，就称这个匹配为<strong>最优匹配</strong>。</p>
<p><img src="/images/algorithm/最大匹配.png" alt="最大匹配" title="最大匹配"></p>
<p>上图是一个最大匹配，注意到它不是完美匹配（V8不饱和）。</p>
<hr>
<h1 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h1><p><strong>匈牙利算法</strong>可以用于在<strong>偶图</strong>中寻找<strong>最大匹配</strong>。</p>
<p>它的思路的确很简单，直接先举例：</p>
<p><img src="/images/algorithm/匈牙利算法_1.png" alt="匈牙利算法" title="匈牙利算法"></p>
<p>要在上图中寻找最大匹配。</p>
<p><img src="/images/algorithm/匈牙利算法_2.png" alt="匈牙利算法" title="匈牙利算法"></p>
<p>按照顺序来一个点一个点的进行匹配。</p>
<ul>
<li>x1直接匹配到y1。</li>
<li>x2先查看y1，发现y1已经匹配了，所以又查看y2，它还没有匹配，所以x2匹配上y2。</li>
<li>x3先查看y2，发现y2已经匹配了，所以又查看y3，它还没有匹配，所以x3匹配上y3。</li>
</ul>
<p><img src="/images/algorithm/匈牙利算法_3.png" alt="匈牙利算法" title="匈牙利算法"></p>
<p>但是对于x4，很尴尬，它会发现y2，y3都已经匹配了。</p>
<p>这时就是体现匈牙利算法思想的时候了，那就是去寻求一条<strong>可扩路</strong>。</p>
<p><strong>可扩路</strong>就是起点与终点均为非饱和点的<strong>交错路</strong>。<strong>交错路</strong>就是处于匹配中的边和未处于匹配中的边相互交错组成的路。</p>
<p><img src="/images/algorithm/匈牙利算法_4.png" alt="匈牙利算法" title="匈牙利算法"></p>
<p>如上图所示，黄色边表示不在当前匹配中的边，红色边表示在匹配中的边，红黄交错，所以这里就是交错路。</p>
<p>对于上面一条路，它的起点和终点都是非饱和点，所有就是一条可扩路。</p>
<p><strong>那么将黄色红色相互交换，就能得到下面那条路，相当于匹配边与未匹配边相互交换，这样这条路上所有的点就都饱和了，岂不美哉？</strong></p>
<p>那么回到x4，我们希望以x4这个未饱和点为起点，去找到一条可扩路，然后匹配边与非匹配边一交换，x4就能饱和了。</p>
<p><img src="/images/algorithm/匈牙利算法_5.png" alt="匈牙利算法" title="匈牙利算法"></p>
<p>这里使用深度优先搜索的方式来找可扩路，先找到y2，然后y2找到x2，然后x2再找到y4。于是就找到了可扩路（x4，y2，x2，y4）。</p>
<p><strong>PS：</strong>事实上在这里深度优先搜索时，要进过几次搜索失败才能到找到上面这条可扩路：</p>
<ul>
<li>x4，y2，x2，y1，x1，y2。（重复y2，搜索失败）</li>
<li>x4，y2，x2，y1，x1，y3，x3，y2（重复y2，搜索失败）</li>
<li>x4，y2，x2，y4。（搜索成功）</li>
</ul>
<p><img src="/images/algorithm/匈牙利算法_6.png" alt="匈牙利算法" title="匈牙利算法"></p>
<p>进行扩充，也就是将匹配（x2，y2）换成了（x2，y4）、（x4，y2）。</p>
<p><img src="/images/algorithm/匈牙利算法_7.png" alt="匈牙利算法" title="匈牙利算法"></p>
<p>最后将（x5，y5）匹配上，这里就找到了最大匹配。</p>
<p><strong>步骤总结：</strong></p>
<ol>
<li>初始化顶点编号，令n=1。</li>
<li>若n大于顶点数N，结束。否则步骤3。</li>
<li>深度优先搜索寻找顶点n的可扩路。如果找到，进行扩充，如果未找到，则这个顶点没法饱和。n = n + 1，返回步骤2.</li>
</ol>
<hr>
<h1 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h1><p>匈牙利算法用于在<strong>偶图</strong>中寻找<strong>最大匹配</strong>。</p>
<p>那么如果要在<strong>完全偶图</strong>中寻找<strong>最优匹配</strong>，就需要用到这里的<strong>KM算法</strong>。</p>
<p><strong>KM算法</strong>的思想实际上并不复杂，举个简单的例如描述一下它的思想：</p>
<blockquote>
<p>假如有<code>M</code>个工人去做<code>M</code>份工作，这些工作每个工人都会做，但是效率不一样，所以希望分配工作能够使得总效率最大。 
先假设你不会KM算法，那么你就按照正常人的思路去想：</p>
<ol>
<li>先让每个人都挑他们效率最高的那份工作，如果都不冲突，那显然分配已经最优了。否则有冲突，那么继续想办法。</li>
<li>对于冲突了的几个人，让他们中最叼的那个哥们换另一份工作试试，看看能不能解决冲突，这样损失的总效率最小。
比如A、B、C之间冲突了，假如一共5份工作<code>(a,b,c,d,e)</code>，
他们的效率分别是<code>A(100,100,99,99,99)</code>、<code>B(8,7,4,3,2)</code>、<code>C(5,5,1,1,1)</code>，
在第一轮里面，按照最大效率的选择，A想选ab中的一个，B想选a，C想选ab中的一个，显然他们三个冲突了。
假如这时d没人选，你如果拍脑袋想，“B你去做a，A你去做b，C你去做d，因为C你最垃圾，A做b的效率可是100”，
那么三人的总效率加起来就是<code>8 + 100 + 1 = 109</code>，但是很遗憾，不是最优。
这时你的分配应该是“B你去做a，C你去做b，A你去做d，因为C你就只能做这玩意，换一个别的你做不了，A换成d也差不多效率”，
这是三人的总效率加起来就是<code>8 + 5 + 99 = 112</code>，这时就是最好的分配方案。 </li>
</ol>
<p>当然这个例子比较简单，在复杂情况下冲突会发生多次。 </p>
</blockquote>
<p>那么按照<strong>完全偶图(X,Y)</strong>来说，思路就是：</p>
<ol>
<li>控制目前图上能选边的数量，第一轮每个X都只有权重最大边能选。</li>
<li>使用匈牙利算法来分配，如果分配成功，这就是最优匹配，否则转步骤3。</li>
<li>对于冲突的部分，想办法添加边进来解决冲突，添加的边是冲突的几个点中权重损失最小的那一条，然后转步骤2。</li>
</ol>
<p><strong>上面的都是语言上的描述，很不准确，下面搬一下书上的数学语言描述。</strong></p>
<hr>
<h2 id="可行顶点标号"><a href="#可行顶点标号" class="headerlink" title="可行顶点标号"></a>可行顶点标号</h2><p><strong>定义</strong>：若在顶点集$X \bigcup Y$上的实值函数L适合下述条件：对所有的$x \in X$及$y \in Y$均有</p>
<script type="math/tex; mode=display">
L(x) + L(y) \geqslant w(xy)</script><p>则把这个函数称为该偶图的一个可行顶点标号。</p>
<p>可行顶点标号也就是每条边的权重都没有它的两端点标号之和大，不管偶图是什么样子，都存在一个可行顶点标号：</p>
<script type="math/tex; mode=display">
\begin{cases}
L(x) = \max_{y \in Y} w(xy), 若 x \in X \\ 
L(y) = 0, 若y \in Y
\end{cases}</script><p>其实这就是上面的“每个X都只有权重最大边能选”。</p>
<hr>
<h2 id="相等子图"><a href="#相等子图" class="headerlink" title="相等子图"></a>相等子图</h2><p><strong>定义</strong>：若L是可行顶点标号，则$E_L$表示可行性顶点标号定义中，使得等式成立的那些边，即：</p>
<script type="math/tex; mode=display">
E_L=\{xy|xy \in E, L(x) + L(y) = w(xy)\}</script><p>则称具有边集$E_L$的G的生成子图为对应于可行顶点标号L的相等子图，记为$G_L$。</p>
<hr>
<h2 id="相关定理"><a href="#相关定理" class="headerlink" title="相关定理"></a>相关定理</h2><p>设L是G=(V,E)的可行顶点标号。若$G_L$包含完美匹配$M^*$，则$M^*$是G的最优匹配。</p>
<p><strong>证明：</strong></p>
<p>假设$G_L$包含完美匹配$M^*$。由于$G_L$是G的生成子图，所以$M^*$也就是G的完美匹配。于是</p>
<script type="math/tex; mode=display">
W(M^*) = \sum_{e \in M^*} w(e) = \sum_{v \in V} L(v)</script><p>这是因为每个$e \in M^*$都属于这个相等子图，且$M^*$的边的端点覆盖V的每个顶点恰好一次。
另一方面，若M是G的任一完美匹配，则有</p>
<script type="math/tex; mode=display">
W(M) = \sum_{e \in M}w(e) \leqslant \sum_{v \in V} L(v)</script><p>从上面两个式子可以看出，$W(M^*) \geqslant W(M)$。于是$M^*$是最优匹配。</p>
<hr>
<h2 id="Kuhn-Munkres"><a href="#Kuhn-Munkres" class="headerlink" title="Kuhn-Munkres"></a>Kuhn-Munkres</h2><p><strong>KM算法</strong>由Kuhn(1955)和Munkers(1957)提出，所以取名叫<code>KM</code>。</p>
<p>它的思想就是：</p>
<ol>
<li>给定一个可行顶点标号。</li>
<li>在相等子图上使用匈牙利算法，如果<strong>完美匹配</strong>，则也是<strong>最优匹配</strong>（上面已经证明）。否则进入下一步。</li>
<li><strong>修改</strong>可行顶点标号，使得相等子图中冲突的几个点的边更多，再回到步骤2。</li>
</ol>
<p>它的步骤如下（主要需要注意的就是它修改可行顶点标号的方式）：</p>
<blockquote>
<p>从任一可行顶点标号L开始，然后决定$G_L$，并且在$G_L$中选取任一匹配M。</p>
<ol>
<li><p>若X是M饱和的，则M是完美匹配，且由定理15知M是最优匹配，在这种情况下，算法终止。
否则，令u是一个M非饱和点，置$S=\{u\}$，$T= \varnothing$。</p>
</li>
<li><p>若$N_{G_L}(S) \supset T$，则转到步骤3。否则$N_{G_L}(S)=T$。计算</p>
<script type="math/tex; mode=display">
\alpha_L = \min_{x \in S \\ y \notin T} \{L(x) + L(y) - w(xy)\}</script><p>且由</p>
<script type="math/tex; mode=display">
\hat{L} = 
\begin{cases}
L(v) - \alpha_L , v \in S, \\
L(v) + \alpha_L , v \in T, \\
L(v), 其它
\end{cases}</script><p>给出可行顶点标号$\hat{L}$（注意$\alpha_L &gt; 0$且$N_{G_{\hat{L}}} \supseteq T$）。
以$\hat{L}$代替L，以$G_{\hat{L}}$代替$G_L$。</p>
</li>
<li><p>在$N_{G_L}(S) \setminus T$中选择一个顶点y。和上节中树的生长程序一样，考察y是否M饱和。
若y是M饱和的，且$yz \in M$，则用$S \cup \{z\}$代替S，用$T \cup \{y\}$代替T，再转到步骤2.
否则，设P是$G_L$中的M可扩(u,y)路，用${M}’=M \triangle E(P)$代替M，并转到步骤1。</p>
</li>
</ol>
</blockquote>
<p>上面的$N_{G_L}(S)$表示在$G_L$这个图中，S这个点集的所有相邻的点。<br>$N_{G_L}(S) \setminus T$表示$N_{G_L}(S)$这个集合减去T这个集合。<br>$M \triangle E(P)$在这里表示$M - M \cap E(p) + (E(p) - M \cap E(p))$，其实也就是在可扩路上进行匹配扩展，边集交换。 </p>
<hr>
<h2 id="例子实际操作"><a href="#例子实际操作" class="headerlink" title="例子实际操作"></a>例子实际操作</h2><p>只看上面的步骤其实还不太会实际操作，这里给一个实际的例子。</p>
<p><img src="/images/algorithm/KM算法_1.png" alt="KM算法" title="KM算法"></p>
<p>上图就是一个具体的例子，左边就是权重矩阵，行表示x点，列表示y点，
x顶点的标号已经初始化（按照上面描述的可行顶点标号中的方法初始化）。
图的右边就是现在的相等子图（边的权重等于两端点的标号之和）。</p>
<p>那么下面的步骤就是在相等子图上使用<strong>匈牙利算法</strong>。</p>
<p><img src="/images/algorithm/KM算法_2.png" alt="KM算法" title="KM算法"></p>
<p>很简单的，前三个x点就能找到匹配。</p>
<p><img src="/images/algorithm/KM算法_3.png" alt="KM算法" title="KM算法"></p>
<p>但是到x4时，发现找不到匹配，即使经过搜索也找不到（肉眼就能看出来x1，x3，x4三个点，一起抢y2，y3两个点，显然不能完美匹配）。</p>
<p>那么修改顶点标号。</p>
<p>按照上面的KM算法步骤2中的公式$\alpha_L = \min_{x \in S \ y \notin T} \{L(x) + L(y) - w(xy)\}$，
这里的S就是{x1,x3,x4}这三个点，
T就时{y2，y3}这两个点，可以算出$\alpha = 1$。</p>
<p>同样按照KM算法步骤2中的公式，用算出来的$\alpha = 1$，修改顶点标号，x1，x3，x4三个点标号减去$\alpha$，y2，y3两个点标号加上$\alpha$，</p>
<p><img src="/images/algorithm/KM算法_4.png" alt="KM算法" title="KM算法"></p>
<p>图中左边的顶点标号已经修改，右边相等子图发生了变化，蓝色边就是新加入的边。</p>
<p>另外需要注意的是(x2,y2)这条边不在相等子图里面了，<strong>这个细节表明了相等子图中的边可不是越来越多！增加边的同时也会有减少的边！
所以上面算法说了，可以从任一可行标点开始！当然，通常写代码时从X标号值最大开始，思考起来会比较连贯。</strong></p>
<p><img src="/images/algorithm/KM算法_5.png" alt="KM算法" title="KM算法"></p>
<p>然后很简单的就能得到完美匹配，也就是这里的最优匹配。</p>
<hr>
<h2 id="KM算法复杂度"><a href="#KM算法复杂度" class="headerlink" title="KM算法复杂度"></a>KM算法复杂度</h2><p>注意到每一次找可扩路失败会修改顶点标号，在修改顶点标号后，都会至少有一个新的y端点加入，
也就是对于一个未饱和点，最多修改$O(n)$次顶点标号就能找到可扩路。</p>
<ol>
<li>KM算法需要找到可扩路的数量为$O(n)$。</li>
<li>每次尝试寻找可扩路的复杂度$O(n^2)$。</li>
<li>尝试找到可扩路，最多尝试$O(n)$次，也就是最多需要修改$O(n)$次顶点标号。</li>
<li>每一次修改顶点标号需要$O(n^2)$的复杂度。</li>
</ol>
<p>从两个方面看，</p>
<ol>
<li><code>可扩路的数量 * 尝试寻找可扩路次数 * 尝试寻找可扩路的复杂度</code>为$O(n^4)$。</li>
<li><code>可扩路的数量 * 最多需要修改顶点标号的次数 * 每一次修改顶点标号的复杂度</code>为$O(n^4)$。</li>
</ol>
<p>所以KM算法的复杂度为上面两个部分相加，所有最后还是$O(n^4)$。</p>
<p><strong>
PS：网上很多博客都说可以把修改顶点标号的复杂度降到$O(n^3)$（的确可以），然后KM算法的复杂度就能降到$O(n^3)$???
但是他们用的都是DFS，对此我表示深刻的怀疑，感觉应该是把复杂度降到$O(n^4) + O(n^3)$，但是实际上应该还是$O(n^4)$的复杂度，
不过降低了常数因子，应该是快了一倍，但是并不能有数量级上的变化。</strong><br><strong>只有使用BFS的写法才能达到$O(n^3)$，后面进行解释。</strong></p>
<hr>
<h2 id="KM算法个人理解"><a href="#KM算法个人理解" class="headerlink" title="KM算法个人理解"></a>KM算法个人理解</h2><p>可以从上面例子看出KM算法的<strong>精髓</strong>，那就是<strong>在相等子图找不到完美匹配时，修改顶点标号，
让冲突的那几个点在相等子图里面能够有更多的边，并至少多连接一个y顶点。</strong></p>
<p><strong>这里之所以$\alpha$取min，是为了顶点标号之和损失最小。因为：</strong></p>
<ol>
<li><strong>最优匹配的值就等于所有点顶点标号之和。</strong></li>
<li><strong>在最优匹配里面每一个顶点出现一次仅一次，相等子图的每条边权重等于它两端点标号和。</strong></li>
</ol>
<p>这里对于X标号值从大到小的算法步骤而言，每一次发生冲突，都是因为几个x点它们共同可以选择的y点的数量比它们小（例如上面例子中三个x点竞争两个y点），
也就是KM算法步骤2中的S集合的规模一定大于T集合，$|S|&gt;|T|$。所以在进行标号修改时，由于S中的点减去标号值，T中的点加上标号值，
所以<strong>所有点的标号之和就一定会比之前小</strong>。</p>
<ul>
<li>如果发生冲突，S集合的规模一定大于T集合，$|S|&gt;|T|$。</li>
<li>标号修改量$\alpha$一定是个大于零的值。</li>
<li>在进行标号修改时，S中的每个点减去标号值，T中的每个点加上标号值。</li>
<li>所有点的标号之和一定减小。</li>
</ul>
<p>上面这段是为了表达<strong>KM算法</strong>有一种这个意味：<strong>“最开始期望一个最大的最优匹配，如果不行再一点一点降低期望。”</strong></p>
<hr>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>是时候上代码了。</p>
<hr>
<h2 id="DFS版本"><a href="#DFS版本" class="headerlink" title="DFS版本"></a>DFS版本</h2><p><strong>DFS版本（复杂度$O(n^4)$）:</strong></p>
<p>虽然我没有参考一个网络上的模板，但是写出来也大同小异…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KM_DFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] table = <span class="keyword">null</span>;     <span class="comment">// 权重矩阵（方阵）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] xl = <span class="keyword">null</span>;          <span class="comment">// X标号值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] yl = <span class="keyword">null</span>;          <span class="comment">// Y标号值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] xMatch = <span class="keyword">null</span>;      <span class="comment">// X点对应的匹配点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] yMatch = <span class="keyword">null</span>;      <span class="comment">// Y点对应的匹配点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;                <span class="comment">// 矩阵维度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;                <span class="comment">// 标号修改量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[][] table)</span> </span>&#123; <span class="comment">// 入口，输入权重矩阵</span></span><br><span class="line">        <span class="keyword">this</span>.table = table;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++ ) &#123;  <span class="comment">// 为每一个x寻找匹配</span></span><br><span class="line">            <span class="keyword">boolean</span>[] S = <span class="keyword">new</span> <span class="keyword">boolean</span>[n], T = <span class="keyword">new</span> <span class="keyword">boolean</span>[n]; <span class="comment">// S集合，T集合</span></span><br><span class="line">            a = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">while</span> ( !dfs(S, T, x) ) &#123;   <span class="comment">// 找到可扩路结束，否则修改标号值</span></span><br><span class="line">                LModified(S, T);</span><br><span class="line">                Arrays.fill(S, <span class="keyword">false</span>);</span><br><span class="line">                Arrays.fill(T, <span class="keyword">false</span>);</span><br><span class="line">                a = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++ ) &#123;</span><br><span class="line">            value += table[x][xMatch[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] S, <span class="keyword">boolean</span>[] T, <span class="keyword">int</span> x)</span> </span>&#123;  <span class="comment">// 深度优先搜索</span></span><br><span class="line">        S[x] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( T[y] ) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = xl[x] + yl[y] - table[x][y];</span><br><span class="line">            <span class="keyword">if</span> ( tmp == <span class="number">0</span> ) &#123;  <span class="comment">// 在相等子树中</span></span><br><span class="line">                T[y] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> ( yMatch[y] == -<span class="number">1</span> || dfs(S, T, yMatch[y]) ) &#123;     <span class="comment">// 1. y顶点没有匹配，那么进行匹配</span></span><br><span class="line">                    xMatch[x] = y;                                   <span class="comment">// 2. dfs寻找可扩路成功，那么这条x，y就会因为可扩路的扩展而交换到匹配中</span></span><br><span class="line">                    yMatch[y] = x;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 不在相等子树中</span></span><br><span class="line">                a = Math.min(tmp, a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = table.length;</span><br><span class="line">        <span class="keyword">this</span>.xl = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.yl = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(xl, Integer.MIN_VALUE);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( table[x][y] &gt; xl[x] ) &#123;</span><br><span class="line">                    xl[x] = table[x][y];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.xMatch = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.yMatch = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(xMatch, -<span class="number">1</span>);</span><br><span class="line">        Arrays.fill(yMatch, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LModified</span><span class="params">(<span class="keyword">boolean</span>[] S, <span class="keyword">boolean</span>[] T)</span> </span>&#123; <span class="comment">// 修改标号值</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( S[i] ) &#123;</span><br><span class="line">                xl[i] -= a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( T[i] ) &#123;</span><br><span class="line">                yl[i] += a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BFS版本"><a href="#BFS版本" class="headerlink" title="BFS版本"></a>BFS版本</h2><p><strong>版本1（复杂度$O(n^4)$）：</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KM_BFS_1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] table = <span class="keyword">null</span>;     <span class="comment">// 权重矩阵（方阵）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] xl = <span class="keyword">null</span>;          <span class="comment">// X标号值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] yl = <span class="keyword">null</span>;          <span class="comment">// Y标号值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] xMatch = <span class="keyword">null</span>;      <span class="comment">// X点对应的匹配点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] yMatch = <span class="keyword">null</span>;      <span class="comment">// Y点对应的匹配点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;                <span class="comment">// 矩阵维度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[][] table)</span> </span>&#123; <span class="comment">// 入口，输入权重矩阵</span></span><br><span class="line">        <span class="keyword">this</span>.table = table;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++ ) &#123;</span><br><span class="line">            bfs(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++ ) &#123;</span><br><span class="line">            value += table[x][xMatch[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> startX)</span> </span>&#123;   <span class="comment">// 为一个x点寻找匹配</span></span><br><span class="line">        <span class="keyword">boolean</span> find = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> endY = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] yPre = <span class="keyword">new</span> <span class="keyword">int</span>[n];     <span class="comment">// 标识搜索路径上y点的前一个点</span></span><br><span class="line">        <span class="keyword">boolean</span>[] S = <span class="keyword">new</span> <span class="keyword">boolean</span>[n], T = <span class="keyword">new</span> <span class="keyword">boolean</span>[n]; <span class="comment">// S集合，T集合</span></span><br><span class="line">        Arrays.fill(yPre, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] queue = <span class="keyword">new</span> <span class="keyword">int</span>[n];    <span class="comment">// 队列</span></span><br><span class="line">        <span class="keyword">int</span> qs = <span class="number">0</span>, qe = <span class="number">0</span>;          <span class="comment">// 队列开始结束索引</span></span><br><span class="line">        queue[qe++] = startX;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;               <span class="comment">// 循环直到找到匹配</span></span><br><span class="line">            <span class="keyword">while</span> (qs &lt; qe &amp;&amp; !find) &#123;   <span class="comment">// 队列不为空</span></span><br><span class="line">                <span class="keyword">int</span> x = queue[qs++];</span><br><span class="line">                S[x] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = xl[x] + yl[y] - table[x][y];</span><br><span class="line">                    <span class="keyword">if</span> ( tmp == <span class="number">0</span> ) &#123;  <span class="comment">// 相等子树中的边</span></span><br><span class="line">                        <span class="keyword">if</span> (T[y]) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        T[y] = <span class="keyword">true</span>;</span><br><span class="line">                        yPre[y] = x;</span><br><span class="line">                        <span class="keyword">if</span> (yMatch[y] == -<span class="number">1</span>) &#123;</span><br><span class="line">                            endY = y;</span><br><span class="line">                            find = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            queue[qe++] = yMatch[y];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;      <span class="comment">// 不在相等子树中的边，记录一下最小差值</span></span><br><span class="line">                        a = Math.min(a, tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( find ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            qs = qe = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;  <span class="comment">// 根据a修改标号值</span></span><br><span class="line">                <span class="keyword">if</span> ( S[i] ) &#123;</span><br><span class="line">                    xl[i] -= a;</span><br><span class="line">                    queue[qe++] = i;        <span class="comment">// 把所有在S中的点加回到队列中</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( T[i] ) &#123;</span><br><span class="line">                    yl[i] += a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( endY != -<span class="number">1</span> ) &#123;       <span class="comment">// 找到可扩路最后的y点后，回溯并扩充</span></span><br><span class="line">            <span class="keyword">int</span> preX = yPre[endY], preY = xMatch[preX];</span><br><span class="line">            xMatch[preX] = endY;</span><br><span class="line">            yMatch[endY] = preX;</span><br><span class="line">            endY = preY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = table.length;</span><br><span class="line">        <span class="keyword">this</span>.xl = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.yl = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(xl, Integer.MIN_VALUE);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( table[x][y] &gt; xl[x] ) &#123;</span><br><span class="line">                    xl[x] = table[x][y];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.xMatch = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.yMatch = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(xMatch, -<span class="number">1</span>);</span><br><span class="line">        Arrays.fill(yMatch, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p><strong>版本2（复杂度$O(n^3)$）：</strong></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KM_BFS_2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] table = <span class="keyword">null</span>;     <span class="comment">// 权重矩阵（方阵）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] xl = <span class="keyword">null</span>;          <span class="comment">// X标号值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] yl = <span class="keyword">null</span>;          <span class="comment">// Y标号值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] xMatch = <span class="keyword">null</span>;      <span class="comment">// X点对应的匹配点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] yMatch = <span class="keyword">null</span>;      <span class="comment">// Y点对应的匹配点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;                <span class="comment">// 矩阵维度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[][] table)</span> </span>&#123; <span class="comment">// 入口，输入权重矩阵</span></span><br><span class="line">        <span class="keyword">this</span>.table = table;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++ ) &#123;</span><br><span class="line">            bfs(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++ ) &#123;</span><br><span class="line">            value += table[x][xMatch[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> startX)</span> </span>&#123;    <span class="comment">// 为一个x点寻找匹配</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> find = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> endY = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] yPre = <span class="keyword">new</span> <span class="keyword">int</span>[n];      <span class="comment">// 标识搜索路径上y点的前一个点</span></span><br><span class="line">        <span class="keyword">boolean</span>[] S = <span class="keyword">new</span> <span class="keyword">boolean</span>[n], T = <span class="keyword">new</span> <span class="keyword">boolean</span>[n]; <span class="comment">// S集合，T集合</span></span><br><span class="line">        <span class="keyword">int</span>[] slackY = <span class="keyword">new</span> <span class="keyword">int</span>[n];    <span class="comment">// Y点的松弛变量</span></span><br><span class="line">        Arrays.fill(yPre, -<span class="number">1</span>);</span><br><span class="line">        Arrays.fill(slackY, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] queue = <span class="keyword">new</span> <span class="keyword">int</span>[n];     <span class="comment">// 队列</span></span><br><span class="line">        <span class="keyword">int</span> qs = <span class="number">0</span>, qe = <span class="number">0</span>;           <span class="comment">// 队列开始结束索引</span></span><br><span class="line">        queue[qe++] = startX;</span><br><span class="line">        <span class="keyword">while</span> (!find) &#123;       <span class="comment">// 循环直到找到匹配</span></span><br><span class="line">            <span class="keyword">while</span> (qs &lt; qe &amp;&amp; !find) &#123;   <span class="comment">// 队列不为空</span></span><br><span class="line">                <span class="keyword">int</span> x = queue[qs++];</span><br><span class="line">                S[x] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++ ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( T[y] ) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> tmp = xl[x] + yl[y] - table[x][y];</span><br><span class="line">                    <span class="keyword">if</span> ( tmp == <span class="number">0</span> ) &#123;  <span class="comment">// 相等子树中的边</span></span><br><span class="line">                        T[y] = <span class="keyword">true</span>;</span><br><span class="line">                        yPre[y] = x;</span><br><span class="line">                        <span class="keyword">if</span> ( yMatch[y] == -<span class="number">1</span> ) &#123;</span><br><span class="line">                            endY = y;</span><br><span class="line">                            find = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            queue[qe++] = yMatch[y];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( slackY[y] &gt; tmp ) &#123; <span class="comment">// 不在相等子树中的边，看是否能够更新松弛变量</span></span><br><span class="line">                        slackY[y] = tmp;</span><br><span class="line">                        yPre[y] = x;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( find ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> a = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++ ) &#123;  <span class="comment">// 找到最小的松弛值</span></span><br><span class="line">                <span class="keyword">if</span> ( !T[y] ) &#123;</span><br><span class="line">                    a = Math.min(a, slackY[y]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;  <span class="comment">// 根据a修改标号值</span></span><br><span class="line">                <span class="keyword">if</span> ( S[i] ) &#123;</span><br><span class="line">                    xl[i] -= a;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( T[i] ) &#123;</span><br><span class="line">                    yl[i] += a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            qs = qe = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++ ) &#123;        <span class="comment">// 重要！！！控制修改标号之后需要检查的x点</span></span><br><span class="line">                <span class="keyword">if</span> ( !T[y] &amp;&amp; slackY[y] == a ) &#123;   <span class="comment">// 查看那些y点新加入到T集合，注意，这些y点的前向x点都记录在了yPre里面，所以这些x点不用再次入队</span></span><br><span class="line">                    T[y] = <span class="keyword">true</span>;                </span><br><span class="line">                    <span class="keyword">if</span> ( yMatch[y] == -<span class="number">1</span> ) &#123;       <span class="comment">// 新加入的y点没有匹配，那么就找到可扩路了</span></span><br><span class="line">                        endY = y;</span><br><span class="line">                        find = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;   <span class="comment">// 新加入的y点已经有匹配了，将它匹配的x加到队列</span></span><br><span class="line">                        queue[qe++] = yMatch[y];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                slackY[y] -= a;   <span class="comment">// 所有松弛值减去a。(对于T集合中的松弛值已经没用了，对于不在T集合里面的y点，</span></span><br><span class="line">            &#125;                     <span class="comment">// 它们的松弛值是通过S集合中的x点求出的，S集合中的x点的标号值在上面都减去了a，所以这里松弛值也要减去a)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( endY != -<span class="number">1</span> ) &#123;    <span class="comment">// 找到可扩路最后的y点后，回溯并扩充</span></span><br><span class="line">            <span class="keyword">int</span> preX = yPre[endY], preY = xMatch[preX];</span><br><span class="line">            xMatch[preX] = endY;</span><br><span class="line">            yMatch[endY] = preX;</span><br><span class="line">            endY = preY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = table.length;</span><br><span class="line">        <span class="keyword">this</span>.xl = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.yl = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(xl, Integer.MIN_VALUE);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( table[x][y] &gt; xl[x] ) &#123;</span><br><span class="line">                    xl[x] = table[x][y];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.xMatch = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.yMatch = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(xMatch, -<span class="number">1</span>);</span><br><span class="line">        Arrays.fill(yMatch, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p>不把一个算法写成代码，真的不能算看懂了这个算法。</p>
<p>写这几份代码花费了一天的时间，大部分时间都用在了BFS代码上，巧妙的地方太多了，先说一下BFS算法的思想：</p>
<p><strong>BFS算法思想：</strong>BFS_1代码的思想其实没什么特殊的，只是和DFS的遍历方式不一样，所有减小了一些边的重复遍历次数。
<strong>但是对于BFS_2这份代码来说，第一个就是松弛变量，它使得每个x节点不用重复入队，第二个是数组实现队列，省掉了很多的容器操作。</strong></p>
<p><strong>松弛变量（slack数组）这个东西，在DFS里面没有很大的作用，但是在BFS里面就变得很重要，它是BFS_2算法的核心。</strong></p>
<p><strong>松弛变量：</strong></p>
<ol>
<li>每一次修改标号值，都在相等子图里面会增加y点。</li>
<li>每一次增加的y点，就是松弛变量值最小的那些y点。</li>
<li>加入的y点在可扩路中的前向点是在计算最小松弛变量$L(x) + L(y) - w(xy)$中的那个x点。</li>
<li>修改标号值时使用的最小松弛变量值是从那些不在T集合中的y点的松弛变量值中选出来的。</li>
<li>所有y点的松弛变量值都是由在S集合中的那些x点算出来的。</li>
<li><strong>未被加入T集合的y点，在修改标号值时，由于S集合的所有x点的标号值减去了$\alpha$，所以这些y点的松弛变量值也要减去$\alpha$。</strong></li>
</ol>
<p><strong>BFS中的queue：</strong>本来应该是使用集合Queue来操作，但是那样增加了许多复杂度，实际上<strong>每个x最多入队一次</strong>，所以这里可以使用数组来进行操作。</p>
<hr>
<h2 id="BenchMark"><a href="#BenchMark" class="headerlink" title="BenchMark"></a>BenchMark</h2><p>对上面三份代码进行测试，查看他们实际上的性能。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>例子数</th>
<th>矩阵最大维度</th>
<th>权重范围</th>
<th>DFS用时（秒）</th>
<th>BFS_1用时（秒）</th>
<th>BFS_2用时（秒）</th>
</tr>
</thead>
<tbody>
<tr>
<td>1000</td>
<td>300</td>
<td>10</td>
<td>2.013</td>
<td>0.34</td>
<td>0.389</td>
</tr>
<tr>
<td>1000</td>
<td>300</td>
<td>100</td>
<td>1.418</td>
<td>0.437</td>
<td>0.779</td>
</tr>
<tr>
<td>1000</td>
<td>300</td>
<td>1000</td>
<td>2.734</td>
<td>0.923</td>
<td>1.202</td>
</tr>
<tr>
<td>1000</td>
<td>300</td>
<td>10000</td>
<td>10.455</td>
<td>3.413</td>
<td>1.435</td>
</tr>
<tr>
<td>1000</td>
<td>300</td>
<td>100000</td>
<td>29.347</td>
<td>11.564</td>
<td>1.542</td>
</tr>
<tr>
<td>50</td>
<td>1000</td>
<td>10</td>
<td>3.651</td>
<td>0.231</td>
<td>0.263</td>
</tr>
<tr>
<td>50</td>
<td>1000</td>
<td>100</td>
<td>2.213</td>
<td>0.296</td>
<td>0.365</td>
</tr>
<tr>
<td>50</td>
<td>1000</td>
<td>1000</td>
<td>1.357</td>
<td>0.445</td>
<td>0.716</td>
</tr>
<tr>
<td>50</td>
<td>1000</td>
<td>10000</td>
<td>3.677</td>
<td>1.102</td>
<td>0.893</td>
</tr>
<tr>
<td>50</td>
<td>1000</td>
<td>100000</td>
<td>12.689</td>
<td>5.531</td>
<td>1.178</td>
</tr>
</tbody>
</table>
</div>
<p><strong>BFS全面优于DFS，BFS_2受到权重范围的影响较小。</strong></p>
<p><strong>上面的结果和之前的算法复杂度很接近，果然DFS是$O(n^4)$，BFS_1其实也是$O(n^4)$，BFS_2是真正的$O(n^3)$</strong>，当然在权重范围不大时，BFS_1是效果最好的。</p>
<hr>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>下面使用一些例题来参考。</p>
<hr>
<h2 id="1-Going-Home"><a href="#1-Going-Home" class="headerlink" title="1. Going Home"></a>1. Going Home</h2><p>这道题来自杭州电子科技大学的OJ，题号1533，<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1533">Going Home</a>。</p>
<p><img src="/images/algorithm/Going_Home.png" alt="Going Home" title="Going Home"></p>
<p>题目的意思就是，有几个人要回到房子里面去，每一个房子只能住一个人，现在人数和房子数一样，但是要怎么分配房子才能使的大家回房子的总路程最小。</p>
<p>我知道的解法有两种，第一种是将这看作图，然后使用最小费用最大流，这个方法可以AC，但是感觉太过于复杂了。</p>
<p>第二种方法就是把房子和人看成两个集合，相互连线，权重就是人到房子的距离，这样就转化为了一个寻找最优匹配的问题，不过这里是找路径总长最小，
那么为了沿用模板，把所有权重取一个负号就行。</p>
<p><strong>代码就是用的上面的模板，这里就不贴了。</strong></p>
<p><strong>用时:</strong></p>
<p><img src="/images/algorithm/Going_Home_2.png" alt="Use Time" title="Use Time"></p>
<hr>
<h2 id="2-奔小康赚大钱"><a href="#2-奔小康赚大钱" class="headerlink" title="2. 奔小康赚大钱"></a>2. 奔小康赚大钱</h2><p>这道题来自<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2255">HDU-2255</a>。</p>
<p><img src="/images/algorithm/奔小康赚大钱_1.png" alt="奔小康赚大钱" title="奔小康赚大钱"></p>
<p>这道题直接就是一个求最优匹配的问题。</p>
<p><strong>这道题对java不友好！！！</strong>，我上面的KM算法都试了一下，java就是过不了，艹了。看了提交统计，就没有java版本通过。</p>
<p>改成c++之后就通过了？？？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> table[N][N];    <span class="comment">// 权重矩阵（方阵）</span></span><br><span class="line"><span class="keyword">int</span> xl[N], yl[N];          <span class="comment">// 标号值</span></span><br><span class="line"><span class="keyword">int</span> xMatch[N], yMatch[N];  <span class="comment">// 点对应的匹配点</span></span><br><span class="line"><span class="keyword">bool</span> S[N], T[N];</span><br><span class="line"><span class="keyword">int</span> yPre[N], slackY[N];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">queue</span>[N];               <span class="comment">// 队列</span></span><br><span class="line"><span class="keyword">int</span> n;                      <span class="comment">// 矩阵维度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> startX)</span> </span>&#123;    <span class="comment">// 为一个x点寻找匹配</span></span><br><span class="line">	<span class="built_in">memset</span>(yPre, <span class="number">-1</span>, <span class="keyword">sizeof</span>(yPre));</span><br><span class="line">	<span class="built_in">memset</span>(S, <span class="number">0</span>, <span class="keyword">sizeof</span>(S));</span><br><span class="line">	<span class="built_in">memset</span>(T, <span class="number">0</span>, <span class="keyword">sizeof</span>(T));</span><br><span class="line">	<span class="built_in">memset</span>(T, <span class="number">0</span>, <span class="keyword">sizeof</span>(T));</span><br><span class="line">	<span class="built_in">memset</span>(slackY, INF, <span class="keyword">sizeof</span>(slackY));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> endY = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> qs = <span class="number">0</span>, qe = <span class="number">0</span>;           <span class="comment">// 队列开始结束索引</span></span><br><span class="line">	<span class="built_in">queue</span>[qe++] = startX;</span><br><span class="line">	<span class="keyword">while</span> (!find) &#123;       <span class="comment">// 循环直到找到匹配</span></span><br><span class="line">		<span class="keyword">while</span> (qs &lt; qe &amp;&amp; !find) &#123;   <span class="comment">// 队列不为空</span></span><br><span class="line">			<span class="keyword">int</span> x = <span class="built_in">queue</span>[qs++];</span><br><span class="line">			S[x] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (T[y]) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">int</span> tmp = xl[x] + yl[y] - table[x][y];</span><br><span class="line">				<span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;  <span class="comment">// 相等子树中的边</span></span><br><span class="line">					T[y] = <span class="literal">true</span>;</span><br><span class="line">					yPre[y] = x;</span><br><span class="line">					<span class="keyword">if</span> (yMatch[y] == <span class="number">-1</span>) &#123;</span><br><span class="line">						endY = y;</span><br><span class="line">						find = <span class="literal">true</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="built_in">queue</span>[qe++] = yMatch[y];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (slackY[y] &gt; tmp) &#123; <span class="comment">// 不在相等子树中的边，看是否能够更新松弛变量</span></span><br><span class="line">					slackY[y] = tmp;</span><br><span class="line">					yPre[y] = x;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (find) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> a = INF;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++) &#123;  <span class="comment">// 找到最小的松弛值</span></span><br><span class="line">			<span class="keyword">if</span> (!T[y] &amp;&amp; slackY[y] &lt; a) &#123;</span><br><span class="line">				a = slackY[y];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 根据a修改标号值</span></span><br><span class="line">			<span class="keyword">if</span> (S[i]) &#123;</span><br><span class="line">				xl[i] -= a;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (T[i]) &#123;</span><br><span class="line">				yl[i] += a;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		qs = qe = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!T[y] &amp;&amp; slackY[y] == a) &#123;   <span class="comment">// 查看那些y点新加入到T集合，注意，这些y点的前向x点都记录在了yPre里面，所以这些x点不用再次入队</span></span><br><span class="line">				T[y] = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (yMatch[y] == <span class="number">-1</span>) &#123;   <span class="comment">// 新加入的y点没有匹配，那么就找到可扩路了</span></span><br><span class="line">					endY = y;</span><br><span class="line">					find = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;      <span class="comment">// 新加入的y点已经有匹配了，将它匹配的x加到队列</span></span><br><span class="line">					<span class="built_in">queue</span>[qe++] = yMatch[y];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			slackY[y] -= a;   <span class="comment">// 所有松弛值减去a。(对于T集合中的松弛值已经没用了，对于不在T集合里面的y点，</span></span><br><span class="line">		&#125;                     <span class="comment">// 它们的松弛值是通过S集合中的x点求出的，S集合中的x点的标号值在上面都减去了a，所以这里松弛值也要减去a)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (endY != <span class="number">-1</span>) &#123;    <span class="comment">// 找到可扩路最后的y点后，回溯并扩充</span></span><br><span class="line">		<span class="keyword">int</span> preX = yPre[endY], preY = xMatch[preX];</span><br><span class="line">		xMatch[preX] = endY;</span><br><span class="line">		yMatch[endY] = preX;</span><br><span class="line">		endY = preY;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(xMatch, <span class="number">-1</span>, <span class="keyword">sizeof</span>(xMatch));</span><br><span class="line">	<span class="built_in">memset</span>(yMatch, <span class="number">-1</span>, <span class="keyword">sizeof</span>(yMatch));</span><br><span class="line">	<span class="built_in">memset</span>(yl, <span class="number">0</span>, <span class="keyword">sizeof</span>(yl));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (table[x][y] &gt; xl[x]) &#123;</span><br><span class="line">				xl[x] = table[x][y];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++) &#123;</span><br><span class="line">		bfs(x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++) &#123;</span><br><span class="line">		value += table[x][xMatch[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;table[i][j]);</span><br><span class="line">		<span class="keyword">int</span> ans = solve();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>用时：</strong></p>
<p><img src="/images/algorithm/奔小康赚大钱_2.png" alt="奔小康赚大钱" title="奔小康赚大钱"></p>
<hr>
<h2 id="3-Cyclic-Tour"><a href="#3-Cyclic-Tour" class="headerlink" title="3. Cyclic Tour"></a>3. Cyclic Tour</h2><p>这道题来自<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1853">HDU-1853</a></p>
<p><img src="/images/algorithm/Cyclic_Tour_1.png" alt="Cyclic Tour" title="Cyclic Tour"></p>
<p>每一个点需要经过一次仅一次，所有的点都是单向边，所以：</p>
<ol>
<li>每个点出入度都至少要大于1，否则不能形成环路。</li>
<li>每个点的出入度都大于1，那么一定有环路。</li>
<li>在最后的环游方案中，每个点被入度一次仅一次，出度一次仅一次。</li>
</ol>
<p>那么把所有点既放到X集合里面，又放到Y集合里面，然后这个偶图的最优匹配就是这个题目的解。</p>
<p>代码从上面那份C++代码改一下就完成了。</p>
<p><img src="/images/algorithm/Cyclic_Tour_2.png" alt="Cyclic Tour" title="Cyclic Tour"></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><strong>KM算法步骤比较简单，思想没那么简单，想写出一个好的代码更不简单。</strong></li>
<li><strong>HDU对java不友好。</strong></li>
</ol>
<hr>
<p>参考资料：</p>
<p>《图论及其应用》-高等教育出版社-张先迪、李正良</p>
<hr>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
</search>
